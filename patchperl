#!/usr/bin/env perl
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Devel/PatchPerl.pm"} = <<'DEVEL_PATCHPERL';
  package Devel::PatchPerl;
  BEGIN {
    $Devel::PatchPerl::VERSION = '0.36';
  }
  
  # ABSTRACT: Patch perl source a la Devel::PPort's buildperl.pl
  
  use strict;
  use warnings;
  use File::pushd qw[pushd];
  use File::Spec;
  use IO::File;
  use IPC::Cmd qw[can_run run];
  use Devel::PatchPerl::Hints qw[hint_file];
  use vars qw[@ISA @EXPORT_OK];
  
  @ISA       = qw(Exporter);
  @EXPORT_OK = qw(patch_source);
  
  my $patch_exe = can_run('patch');
  
  my @patch = (
    {
      perl => [
                qr/^5\.00[01234]/,
                qw/
                  5.005
                  5.005_01
                  5.005_02
                  5.005_03
                /,
              ],
      subs => [
                [ \&_patch_db, 1 ],
              ],
    },
    {
      perl => [
              qw/
                  5.6.0
                  5.6.1
                  5.7.0
                  5.7.1
                  5.7.2
                  5.7.3
                  5.8.0
              /,
              ],
      subs => [
                [ \&_patch_db, 3 ],
              ],
    },
    {
      perl => [
                qr/^5\.004_0[1234]$/,
              ],
      subs => [
                [ \&_patch_doio ],
              ],
    },
    {
      perl => [
                qw/
                  5.005
                  5.005_01
                  5.005_02
                /,
              ],
      subs => [
                [ \&_patch_sysv, old_format => 1 ],
              ],
    },
    {
      perl => [
                qw/
                  5.005_03
                  5.005_04
                /,
                qr/^5\.6\.[0-2]$/,
                qr/^5\.7\.[0-3]$/,
                qr/^5\.8\.[0-8]$/,
                qr/^5\.9\.[0-5]$/
              ],
      subs => [
                [ \&_patch_sysv, old_format => 0 ],
              ],
    },
    {
      perl => [
                qr/^5\.004_05$/,
                qr/^5\.005(?:_0[1-4])?$/,
                qr/^5\.6\.[01]$/,
              ],
      subs => [
                [ \&_patch_configure ],
                [ \&_patch_makedepend_lc ],
              ],
    },
    {
      perl => [
                '5.8.0',
              ],
      subs => [
                [ \&_patch_makedepend_lc ],
              ],
    },
    {
      perl => [
                qr/.*/,
              ],
      subs => [
                [ \&_patch_hints ],
              ],
    },
    {
      perl => [
                qr/^5\.6\.[0-2]$/,
                qr/^5\.7\.[0-3]$/,
                qr/^5\.8\.[0-8]$/,
              ],
      subs => [
                [ \&_patch_makedepend_SH ],
              ],
    },
    {
      perl => [
                qr/^5\.1[0-2]/,
              ],
      subs => [
                [ \&_patch_archive_tar_tests ],
                [ \&_patch_odbm_file_hints_linux ],
              ],
    },
  );
  
  sub patch_source {
    my $vers = shift;
    $vers = shift if eval { $vers->isa(__PACKAGE__) };
    my $source = shift || '.';
    if ( !$vers ) {
      $vers = _determine_version($source);
      if ( $vers ) {
        warn "Auto-guessed '$vers'\n";
      }
      else {
        die "You didn't provide a perl version and I don't appear to be in a perl source tree\n";
      }
    }
    $source = File::Spec->rel2abs($source);
    warn "No patch utility found\n" unless $patch_exe;
    {
      my $dir = pushd( $source );
      for my $p ( grep { _is( $_->{perl}, $vers ) } @patch ) {
         for my $s (@{$p->{subs}}) {
           my($sub, @args) = @$s;
           push @args, $vers unless scalar @args;
           $sub->(@args);
         }
      }
    }
  }
  
  sub _is
  {
    my($s1, $s2) = @_;
  
    defined $s1 != defined $s2 and return 0;
  
    ref $s2 and ($s1, $s2) = ($s2, $s1);
  
    if (ref $s1) {
      if (ref $s1 eq 'ARRAY') {
        _is($_, $s2) and return 1 for @$s1;
        return 0;
      }
      return $s2 =~ $s1;
    }
  
    return $s1 eq $s2;
  }
  
  sub _patch
  {
    my($patch) = @_;
    print "patching $_\n" for $patch =~ /^\+{3}\s+(\S+)/gm;
    my $diff = 'tmp.diff';
    _write_or_die($diff, $patch);
    _run_or_die("$patch_exe -f -s -p0 <$diff");
    unlink $diff or die "unlink $diff: $!\n";
  }
  
  sub _write_or_die
  {
    my($file, $data) = @_;
    my $fh = IO::File->new(">$file") or die "$file: $!\n";
    $fh->print($data);
  }
  
  sub _run_or_die
  {
    # print "[running @_]\n";
    die unless scalar run( command => [ @_ ], verbose => 1 );
  }
  
  sub _determine_version {
    my ($source) = @_;
    my $patchlevel_h = File::Spec->catfile($source, 'patchlevel.h');
    return unless -e $patchlevel_h;
    my $version;
    {
      open my $fh, '<', $patchlevel_h;
      my @vers;
      while (<$fh>) {
        chomp;
        next unless /^#define PERL_[RVS]/;
        push @vers, (split /\s+/)[2];
      }
      $version = join '.', @vers;
    }
    return $version;
  }
  
  sub _patch_hints {
    return unless my ($file,$data) = hint_file();
    my $path = File::Spec->catfile( 'hints', $file );
    chmod 0644, $path or die "$!\n";
    open my $fh, '>', $path or die "$!\n";
    print $fh $data;
    close $fh;
    return 1;
  }
  
  sub _patch_db
  {
    my $ver = shift;
    print "patching ext/DB_File/DB_File.xs\n";
    _run_or_die($^X, '-pi.bak', '-e', "s/<db.h>/<db$ver\\/db.h>/", 'ext/DB_File/DB_File.xs');
    unlink 'ext/DB_File/DB_File.xs.bak' if -e 'ext/DB_File/DB_File.xs.bak';
  }
  
  sub _patch_doio
  {
    _patch(<<'END');
  --- doio.c.org  2004-06-07 23:14:45.000000000 +0200
  +++ doio.c  2003-11-04 08:03:03.000000000 +0100
  @@ -75,6 +75,16 @@
   #  endif
   #endif
  
  +#if _SEM_SEMUN_UNDEFINED
  +union semun
  +{
  +  int val;
  +  struct semid_ds *buf;
  +  unsigned short int *array;
  +  struct seminfo *__buf;
  +};
  +#endif
  +
   bool
   do_open(gv,name,len,as_raw,rawmode,rawperm,supplied_fp)
   GV *gv;
  END
  }
  
  sub _patch_sysv
  {
    my %opt = @_;
  
    # check if patching is required
    return if $^O ne 'linux' or -f '/usr/include/asm/page.h';
  
    if ($opt{old_format}) {
      _patch(<<'END');
  --- ext/IPC/SysV/SysV.xs.org  1998-07-20 10:20:07.000000000 +0200
  +++ ext/IPC/SysV/SysV.xs  2007-08-12 10:51:06.000000000 +0200
  @@ -3,9 +3,6 @@
   #include "XSUB.h"
   
   #include <sys/types.h>
  -#ifdef __linux__
  -#include <asm/page.h>
  -#endif
   #if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
   #include <sys/ipc.h>
   #ifdef HAS_MSG
  END
    }
    else {
      _patch(<<'END');
  --- ext/IPC/SysV/SysV.xs.org  2007-08-11 00:12:46.000000000 +0200
  +++ ext/IPC/SysV/SysV.xs  2007-08-11 00:10:51.000000000 +0200
  @@ -3,9 +3,6 @@
   #include "XSUB.h"
   
   #include <sys/types.h>
  -#ifdef __linux__
  -#   include <asm/page.h>
  -#endif
   #if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
   #ifndef HAS_SEM
   #   include <sys/ipc.h>
  END
    }
  }
  
  sub _patch_configure
  {
    _patch(<<'END');
  --- Configure
  +++ Configure
  @@ -3380,6 +3380,18 @@
   test "X$gfpthkeep" != Xy && gfpth=""
   EOSC
   
  +# gcc 3.1 complains about adding -Idirectories that it already knows about,
  +# so we will take those off from locincpth.
  +case "$gccversion" in
  +3*)
  +    echo "main(){}">try.c
  +    for incdir in `$cc -v -c try.c 2>&1 | \
  +       sed '1,/^#include <\.\.\.>/d;/^End of search list/,$d;s/^ //'` ; do
  +       locincpth=`echo $locincpth | sed s!$incdir!!`
  +    done
  +    $rm -f try try.*
  +esac
  +
   : What should the include directory be ?
   echo " "
   $echo $n "Hmm...  $c"
  END
  }
  
  sub _patch_makedepend_lc
  {
    _patch(<<'END');
  --- makedepend.SH
  +++ makedepend.SH
  @@ -58,6 +58,10 @@ case $PERL_CONFIG_SH in
         ;;
   esac
   
  +# Avoid localized gcc/cc messages
  +LC_ALL=C
  +export LC_ALL
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  END
  }
  
  
  sub _patch_makedepend_SH
  {
    my $perl = shift;
    SWITCH: {
    # If 5.6.0
      if ( $perl eq '5.6.0' ) {
    _patch(<<'BADGER');
  --- makedepend.SH.org	2000-03-02 18:12:26.000000000 +0000
  +++ makedepend.SH	2010-09-01 10:13:37.000000000 +0100
  @@ -1,5 +1,5 @@
   #! /bin/sh
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -29,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -37,7 +44,7 @@
   
   export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
   
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -51,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -58,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -67,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -99,25 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				uwinfix=
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -130,22 +140,45 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
       if [ "$osname" = os390 -a "$file" = perly.c ]; then
           $echo '#endif' >>UU/$file.c
       fi
  -    $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  -    $sed \
  -	-e '1d' \
  -	-e '/^#.*<stdin>/d' \
  -	-e '/^#.*"-"/d' \
  -	-e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
  -	-e 's/^[	 ]*#[	 ]*line/#/' \
  -	-e '/^# *[0-9][0-9]* *[".\/]/!d' \
  -	-e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
  -	-e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
  -	-e 's|: \./|: |' \
  -	-e 's|\.c\.c|.c|' $uwinfix | \
  -    $uniq | $sort | $uniq >> .deptmp
  +
  +    if [ "$osname" = os390 ]; then
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $sed \
  +    	    -e '/^#.*<stdin>/d' \
  +	    -e '/^#.*"-"/d' \
  +	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
  +	    -e 's/^[	 ]*#[	 ]*line/#/' \
  +	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
  +	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
  +	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
  +	    -e 's|: \./|: |' \
  +	    -e 's|\.c\.c|.c|' $uwinfix | \
  +        $uniq | $sort | $uniq >> .deptmp
  +    else
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
  +        $sed \
  +	    -e '1d' \
  +	    -e '/^#.*<stdin>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
  +	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
  +	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
  +	    -e 's/^[	 ]*#[	 ]*line/#/' \
  +	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
  +	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
  +	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
  +	    -e 's|: \./|: |' \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
  +        $uniq | $sort | $uniq >> .deptmp
  +    fi
   done
   
   $sed <$mf >$mf.new -e '1,/^# AUTOMATICALLY/!d'
  @@ -177,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -208,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
    last SWITCH;
    }
    # If 5.6.1
      if ( $perl eq '5.6.1' ) {
    _patch(<<'BADGER');
  --- makedepend.SH.org	2001-03-19 07:33:17.000000000 +0000
  +++ makedepend.SH	2010-09-01 10:14:47.000000000 +0100
  @@ -1,5 +1,5 @@
   #! /bin/sh
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -29,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -37,7 +44,7 @@
   
   export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
   
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -51,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -58,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -67,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -99,29 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				if [ "$osname" = posix-bc ]; then
  -					uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/"
  -				else
  -					uwinfix=
  -				fi
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -134,10 +140,12 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
  -        if [ "$file" = perly.c ]; then
  -            $echo '#endif' >>UU/$file.c
  -        fi
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
       	    -e '/^#.*<stdin>/d' \
  @@ -151,18 +159,24 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
   	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -196,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -227,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
    last SWITCH;
    }
    # If 5.6.2
      if ( $perl eq '5.6.2' ) {
    _patch(<<'BADGER');
  --- makedepend.SH.org	2003-07-30 23:46:59.000000000 +0100
  +++ makedepend.SH	2010-09-01 10:15:47.000000000 +0100
  @@ -1,5 +1,5 @@
   #! /bin/sh
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -29,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -37,7 +44,7 @@
   
   export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
   
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -63,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -72,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -104,29 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				if [ "$osname" = posix-bc ]; then
  -					uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/"
  -				else
  -					uwinfix=
  -				fi
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -139,10 +140,12 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
  -        if [ "$file" = perly.c ]; then
  -            $echo '#endif' >>UU/$file.c
  -        fi
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
       	    -e '/^#.*<stdin>/d' \
  @@ -156,21 +159,24 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
  -	    -e '/^#.*<builtin>/d' \
  -	    -e '/^#.*<built-in>/d' \
  -	    -e '/^#.*<command line>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
   	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -204,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -235,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
    last SWITCH;
    }
    # If 5.7.0
      if ( $perl eq '5.7.0' ) {
    _patch(<<'BADGER');
  --- makedepend.SH.org	2000-08-13 19:35:04.000000000 +0100
  +++ makedepend.SH	2010-09-01 10:47:14.000000000 +0100
  @@ -1,5 +1,5 @@
   #! /bin/sh
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -29,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -37,7 +44,7 @@
   
   export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
   
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -51,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -58,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -67,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -99,25 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				uwinfix=
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -130,10 +140,12 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
  -        if [ "$file" = perly.c ]; then
  -            $echo '#endif' >>UU/$file.c
  -        fi
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
       	    -e '/^#.*<stdin>/d' \
  @@ -147,18 +159,24 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
   	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -192,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -223,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
    last SWITCH;
    }
    # If 5.7.1
      if ( $perl eq '5.7.1' ) {
    _patch(<<'BADGER');
  --- makedepend.SH.org	2001-03-11 16:30:08.000000000 +0000
  +++ makedepend.SH	2010-09-01 10:44:54.000000000 +0100
  @@ -1,5 +1,5 @@
   #! /bin/sh
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -29,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -37,7 +44,7 @@
   
   export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
   
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -51,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -58,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -67,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -99,29 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				if [ "$osname" = posix-bc ]; then
  -					uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/"
  -				else
  -					uwinfix=
  -				fi
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -134,10 +140,12 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
  -        if [ "$file" = perly.c ]; then
  -            $echo '#endif' >>UU/$file.c
  -        fi
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
       	    -e '/^#.*<stdin>/d' \
  @@ -151,18 +159,24 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
   	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -196,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -227,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
    last SWITCH;
    }
    # If 5.7.2
      if ( $perl eq '5.7.2' ) {
    _patch(<<'BADGER');
  --- makedepend.SH.org	2001-07-09 15:11:05.000000000 +0100
  +++ makedepend.SH	2010-09-01 10:45:32.000000000 +0100
  @@ -18,10 +18,6 @@
   */*) cd `expr X$0 : 'X\(.*\)/'` ;;
   esac
   
  -case "$osname" in
  -amigaos) cat=/bin/cat ;; # must be absolute
  -esac
  -
   echo "Extracting makedepend (with variable substitutions)"
   rm -f makedepend
   $spitshell >makedepend <<!GROK!THIS!
  @@ -33,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -55,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -62,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -71,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -103,29 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				if [ "$osname" = posix-bc ]; then
  -					uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/"
  -				else
  -					uwinfix=
  -				fi
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -138,10 +140,12 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
  -        if [ "$file" = perly.c ]; then
  -            $echo '#endif' >>UU/$file.c
  -        fi
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
       	    -e '/^#.*<stdin>/d' \
  @@ -155,18 +159,24 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
   	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -200,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -231,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
    last SWITCH;
    }
    # If 5.7.3
      if ( $perl eq '5.7.3' ) {
    _patch(<<'BADGER');
  --- makedepend.SH.org	2002-03-05 01:10:22.000000000 +0000
  +++ makedepend.SH	2010-09-01 10:46:13.000000000 +0100
  @@ -18,10 +18,6 @@
   */*) cd `expr X$0 : 'X\(.*\)/'` ;;
   esac
   
  -case "$osname" in
  -amigaos) cat=/bin/cat ;; # must be absolute
  -esac
  -
   echo "Extracting makedepend (with variable substitutions)"
   rm -f makedepend
   $spitshell >makedepend <<!GROK!THIS!
  @@ -33,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -55,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -62,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -71,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -116,7 +127,7 @@
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -129,6 +140,11 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
  @@ -143,13 +159,16 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c 2>&1 |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
               -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
               -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
   	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
  @@ -157,7 +176,7 @@
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -191,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -222,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
    last SWITCH;
    }
    # If 5.8.0
      if ( $perl eq '5.8.0' ) {
    _patch(<<'BADGER');
  --- makedepend.SH.org	2002-07-09 15:06:42.000000000 +0100
  +++ makedepend.SH	2010-09-01 10:16:37.000000000 +0100
  @@ -58,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -78,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -123,7 +127,7 @@
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -136,6 +140,11 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
  @@ -157,7 +166,9 @@
               -e '/^#.*<builtin>/d' \
               -e '/^#.*<built-in>/d' \
               -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
   	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
  @@ -199,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  BADGER
    last SWITCH;
    }
    # If 5.8.[12345678]
    _patch(<<'BADGER');
  --- makedepend.SH.org	2003-06-05 19:11:10.000000000 +0100
  +++ makedepend.SH	2010-09-01 10:24:39.000000000 +0100
  @@ -83,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -128,7 +127,7 @@
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -167,7 +166,9 @@
               -e '/^#.*<builtin>/d' \
               -e '/^#.*<built-in>/d' \
               -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
   	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
  @@ -209,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  BADGER
    }
  }
  
  sub _patch_archive_tar_tests
  {
    my $perl = shift;
    if ($perl =~ /^5\.10/) {
      _patch(<<'END');
  --- lib/Archive/Tar/t/02_methods.t
  +++ lib/Archive/Tar/t/02_methods.t
  @@ -70,6 +70,20 @@ my $LONG_FILE = qq[directory/really-really-really-really-really-really-really-re
   my $TOO_LONG    =   ($^O eq 'MSWin32' or $^O eq 'cygwin' or $^O eq 'VMS')
                       && length( cwd(). $LONG_FILE ) > 247;
   
  +if(!$TOO_LONG) {
  +    my $alt = File::Spec->catfile( cwd(), $LONG_FILE);
  +    eval 'mkpath([$alt]);';
  +    if($@)
  +    {
  +        $TOO_LONG = 1;
  +    }
  +    else
  +    {
  +        $@ = '';
  +        my $base = File::Spec->catfile( cwd(), 'directory');
  +        rmtree $base;
  +    }
  +}
   ### warn if we are going to skip long file names
   if ($TOO_LONG) {
       diag("No long filename support - long filename extraction disabled") if ! $ENV{PERL_CORE};
  END
    }
    else {
      _patch(<<'END');
  --- cpan/Archive-Tar/t/02_methods.t
  +++ cpan/Archive-Tar/t/02_methods.t
  @@ -70,6 +70,20 @@ my $LONG_FILE = qq[directory/really-really-really-really-really-really-really-re
   my $TOO_LONG    =   ($^O eq 'MSWin32' or $^O eq 'cygwin' or $^O eq 'VMS')
                       && length( cwd(). $LONG_FILE ) > 247;
   
  +if(!$TOO_LONG) {
  +    my $alt = File::Spec->catfile( cwd(), $LONG_FILE);
  +    eval 'mkpath([$alt]);';
  +    if($@)
  +    {
  +        $TOO_LONG = 1;
  +    }
  +    else
  +    {
  +        $@ = '';
  +        my $base = File::Spec->catfile( cwd(), 'directory');
  +        rmtree $base;
  +    }
  +}
   ### warn if we are going to skip long file names
   if ($TOO_LONG) {
       diag("No long filename support - long filename extraction disabled") if ! $ENV{PERL_CORE};
  END
    }
  }
  
  sub _patch_odbm_file_hints_linux
  {
      _patch(<<'END');
  --- ext/ODBM_File/hints/linux.pl
  +++ ext/ODBM_File/hints/linux.pl
  @@ -1,8 +1,8 @@
   # uses GDBM dbm compatibility feature - at least on SuSE 8.0
   $self->{LIBS} = ['-lgdbm'];
   
  -# Debian/Ubuntu have /usr/lib/libgdbm_compat.so.3* but not this file,
  +# Debian/Ubuntu have libgdbm_compat.so but not this file,
   # so linking may fail
  -if (-e '/usr/lib/libgdbm_compat.so' or -e '/usr/lib64/libgdbm_compat.so') {
  -    $self->{LIBS}->[0] .= ' -lgdbm_compat';
  +foreach (split / /, $Config{libpth}) {
  +    $self->{LIBS}->[0] .= ' -lgdbm_compat' if -e $_.'/libgdbm_compat.so';
   }
  END
  }
  
  qq[patchin'];
  
  
  
  __END__
  =pod
  
  =head1 NAME
  
  Devel::PatchPerl - Patch perl source a la Devel::PPort's buildperl.pl
  
  =head1 VERSION
  
  version 0.36
  
  =head1 SYNOPSIS
  
    use strict;
    use warnings;
  
    use Devel::PatchPerl;
  
    Devel::PatchPerl->patch_source( '5.6.1', '/path/to/untarred/perl/source/perl-5.6.1' );
  
  =head1 DESCRIPTION
  
  Devel::PatchPerl is a modularisation of the patching code contained in L<Devel::PPort>'s
  C<buildperl.pl>.
  
  It does not build perls, it merely provides an interface to the source patching
  functionality.
  
  =head1 FUNCTION
  
  =over
  
  =item C<patch_source>
  
  Takes two parameters, a C<perl> version and the path to unwrapped perl source for that version.
  It dies on any errors.
  
  If you don't supply a C<perl> version, it will attempt to auto-determine the
  C<perl> version from the specified path.
  
  If you don't supply the path to unwrapped perl source, it will assume the
  current working directory.
  
  =back
  
  =head1 SEE ALSO
  
  L<Devel::PPPort>
  
  =head1 AUTHOR
  
  Chris Williams <chris@bingosnet.co.uk>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Chris Williams and Marcus Holland-Moritz.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
DEVEL_PATCHPERL

$fatpacked{"Devel/PatchPerl/Hints.pm"} = <<'DEVEL_PATCHPERL_HINTS';
  package Devel::PatchPerl::Hints;
  BEGIN {
    $Devel::PatchPerl::Hints::VERSION = '0.36';
  }
  
  #ABSTRACT: replacement 'hints' files
  
  use strict;
  use warnings;
  use MIME::Base64 qw[decode_base64];
  use File::Spec;
  
  our @ISA            = qw[Exporter];
  our @EXPORT_OK      = qw[hint_file];
  
  my %hints = (
  'netbsd' =>
  'IyBoaW50cy9uZXRic2Quc2gKIwojIFBsZWFzZSBjaGVjayB3aXRoIHBhY2thZ2VzQG5ldGJzZC5v
  cmcgYmVmb3JlIG1ha2luZyBtb2RpZmljYXRpb25zCiMgdG8gdGhpcyBmaWxlLgoKY2FzZSAiJGFy
  Y2huYW1lIiBpbgonJykKICAgIGFyY2huYW1lPWB1bmFtZSAtbWAtJHtvc25hbWV9CiAgICA7Owpl
  c2FjCgojIE5ldEJTRCBrZWVwcyBkeW5hbWljIGxvYWRpbmcgZGwqKCkgZnVuY3Rpb25zIGluIC91
  c3IvbGliL2NydDAubywKIyBzbyBDb25maWd1cmUgZG9lc24ndCBmaW5kIHRoZW0gKHVubGVzcyB5
  b3UgYWJhbmRvbiB0aGUgbm0gc2NhbikuCiMgQWxzbywgTmV0QlNEIDAuOWEgd2FzIHRoZSBmaXJz
  dCByZWxlYXNlIHRvIGludHJvZHVjZSBzaGFyZWQKIyBsaWJyYXJpZXMuCiMKY2FzZSAiJG9zdmVy
  cyIgaW4KMC45fDAuOCopCgl1c2VkbD0iJHVuZGVmIgoJOzsKKikKCWNhc2UgYHVuYW1lIC1tYCBp
  bgoJcG1heCkKCQkjIE5ldEJTRCAxLjMgYW5kIDEuMy4xIG9uIHBtYXggc2hpcHBlZCBhbiBgb2xk
  JyBsZC5zbywKCQkjIHdoaWNoIHdpbGwgbm90IHdvcmsuCgkJY2FzZSAiJG9zdmVycyIgaW4KCQkx
  LjN8MS4zLjEpCgkJCWRfZGxvcGVuPSR1bmRlZgoJCQk7OwoJCWVzYWMKCQk7OwoJZXNhYwoJaWYg
  dGVzdCAtZiAvdXNyL2xpYmV4ZWMvbGQuZWxmX3NvOyB0aGVuCgkJIyBFTEYKCQlkX2Rsb3Blbj0k
  ZGVmaW5lCgkJZF9kbGVycm9yPSRkZWZpbmUKCQljY2NkbGZsYWdzPSItRFBJQyAtZlBJQyAkY2Nj
  ZGxmbGFncyIKCQlsZGRsZmxhZ3M9Ii0td2hvbGUtYXJjaGl2ZSAtc2hhcmVkICRsZGRsZmxhZ3Mi
  CgkJcnBhdGhmbGFnPSItV2wsLXJwYXRoLCIKCQljYXNlICIkb3N2ZXJzIiBpbgoJCTEuWzAtNV0q
  KQoJCQkjCgkJCSMgSW5jbHVkZSB0aGUgd2hvbGUgbGliZ2NjLmEgaW50byB0aGUgcGVybCBleGVj
  dXRhYmxlCgkJCSMgc28gdGhhdCBjZXJ0YWluIHN5bWJvbHMgbmVlZGVkIGJ5IGxvYWRhYmxlIG1v
  ZHVsZXMKCQkJIyBidWlsdCBhcyBDKysgb2JqZWN0cyAoX19laF9hbGxvYywgX19wdXJlX3ZpcnR1
  YWwsCgkJCSMgZXRjLikgd2lsbCBhbHdheXMgYmUgZGVmaW5lZC4KCQkJIwoJCQljY2RsZmxhZ3M9
  Ii1XbCwtd2hvbGUtYXJjaGl2ZSAtbGdjYyBcCgkJCQktV2wsLW5vLXdob2xlLWFyY2hpdmUgLVds
  LC1FICRjY2RsZmxhZ3MiCgkJCTs7CgkJKikKCQkJY2NkbGZsYWdzPSItV2wsLUUgJGNjZGxmbGFn
  cyIKCQkJOzsKCQllc2FjCgllbGlmIHRlc3QgLWYgL3Vzci9saWJleGVjL2xkLnNvOyB0aGVuCgkJ
  IyBhLm91dAoJCWRfZGxvcGVuPSRkZWZpbmUKCQlkX2RsZXJyb3I9JGRlZmluZQoJCWNjY2RsZmxh
  Z3M9Ii1EUElDIC1mUElDICRjY2NkbGZsYWdzIgoJCWxkZGxmbGFncz0iLUJzaGFyZWFibGUgJGxk
  ZGxmbGFncyIKCQlycGF0aGZsYWc9Ii1SIgoJZWxzZQoJCWRfZGxvcGVuPSR1bmRlZgoJCXJwYXRo
  ZmxhZz0KCWZpCgk7Owplc2FjCgojIG5ldGJzZCBoYWQgdGhlc2UgYnV0IHRoZXkgZG9uJ3QgcmVh
  bGx5IHdvcmsgYXMgYWR2ZXJ0aXNlZCwgaW4gdGhlCiMgdmVyc2lvbnMgbGlzdGVkIGJlbG93LiAg
  aWYgdGhleSBhcmUgZGVmaW5lZCwgdGhlbiB0aGVyZSBpc24ndCBhCiMgd2F5IHRvIG1ha2UgcGVy
  bCBjYWxsIHNldHVpZCgpIG9yIHNldGdpZCgpLiAgaWYgdGhleSBhcmVuJ3QsIHRoZW4KIyAoJDws
  ICQ+KSA9ICgkdSwgJHUpOyB3aWxsIHdvcmsgKHNhbWUgZm9yICQoLyQpKS4gIHRoaXMgaXMgYmVj
  YXVzZQojIHlvdSBjYW4gbm90IGNoYW5nZSB0aGUgcmVhbCB1c2VyaWQgb2YgYSBwcm9jZXNzIHVu
  ZGVyIDQuNEJTRC4KIyBuZXRic2QgZml4ZWQgdGhpcyBpbiAxLjMuMi4KY2FzZSAiJG9zdmVycyIg
  aW4KMC45KnwxLlswMTJdKnwxLjN8MS4zLjEpCglkX3NldHJlZ2lkPSIkdW5kZWYiCglkX3NldHJl
  dWlkPSIkdW5kZWYiCgk7Owplc2FjCmNhc2UgIiRvc3ZlcnMiIGluCjAuOSp8MS4qfDIuKnwzLip8
  NC4qfDUuKikKCWRfZ2V0cHJvdG9lbnRfcj0iJHVuZGVmIgoJZF9nZXRwcm90b2J5bmFtZV9yPSIk
  dW5kZWYiCglkX2dldHByb3RvYnludW1iZXJfcj0iJHVuZGVmIgoJZF9zZXRwcm90b2VudF9yPSIk
  dW5kZWYiCglkX2VuZHByb3RvZW50X3I9IiR1bmRlZiIKCWRfZ2V0c2VydmVudF9yPSIkdW5kZWYi
  CglkX2dldHNlcnZieW5hbWVfcj0iJHVuZGVmIgoJZF9nZXRzZXJ2Ynlwb3J0X3I9IiR1bmRlZiIK
  CWRfc2V0c2VydmVudF9yPSIkdW5kZWYiCglkX2VuZHNlcnZlbnRfcj0iJHVuZGVmIgoJZF9nZXRw
  cm90b2VudF9yX3Byb3RvPSIwIgoJZF9nZXRwcm90b2J5bmFtZV9yX3Byb3RvPSIwIgoJZF9nZXRw
  cm90b2J5bnVtYmVyX3JfcHJvdG89IjAiCglkX3NldHByb3RvZW50X3JfcHJvdG89IjAiCglkX2Vu
  ZHByb3RvZW50X3JfcHJvdG89IjAiCglkX2dldHNlcnZlbnRfcl9wcm90bz0iMCIKCWRfZ2V0c2Vy
  dmJ5bmFtZV9yX3Byb3RvPSIwIgoJZF9nZXRzZXJ2Ynlwb3J0X3JfcHJvdG89IjAiCglkX3NldHNl
  cnZlbnRfcl9wcm90bz0iMCIKCWRfZW5kc2VydmVudF9yX3Byb3RvPSIwIgoJOzsKZXNhYwoKIyBU
  aGVzZSBhcmUgb2Jzb2xldGUgaW4gYW55IG5ldGJzZC4KZF9zZXRyZ2lkPSIkdW5kZWYiCmRfc2V0
  cnVpZD0iJHVuZGVmIgoKIyB0aGVyZSdzIG5vIHByb2JsZW0gd2l0aCB2Zm9yay4KdXNldmZvcms9
  dHJ1ZQoKIyBUaGlzIGlzIHRoZXJlIGJ1dCBpbiBtYWNoaW5lL2llZWVmcF9oLgppZWVlZnBfaD0i
  ZGVmaW5lIgoKIyBUaGlzIHNjcmlwdCBVVS91c2V0aHJlYWRzLmNidSB3aWxsIGdldCAnY2FsbGVk
  LWJhY2snIGJ5IENvbmZpZ3VyZQojIGFmdGVyIGl0IGhhcyBwcm9tcHRlZCB0aGUgdXNlciBmb3Ig
  d2hldGhlciB0byB1c2UgdGhyZWFkcy4KY2F0ID4gVVUvdXNldGhyZWFkcy5jYnUgPDwnRU9DQlUn
  CmNhc2UgIiR1c2V0aHJlYWRzIiBpbgokZGVmaW5lfHRydWV8W3lZXSopCglscHRocmVhZD0KCWZv
  ciB4eHggaW4gcHRocmVhZDsgZG8KCQlmb3IgeXl5IGluICRsb2NsaWJwdGggJHBsaWJwdGggJGds
  aWJwdGggZHVtbXk7IGRvCgkJCXp6ej0keXl5L2xpYiR4eHguYQoJCQlpZiB0ZXN0IC1mICIkenp6
  IjsgdGhlbgoJCQkJbHB0aHJlYWQ9JHh4eAoJCQkJYnJlYWs7CgkJCWZpCgkJCXp6ej0keXl5L2xp
  YiR4eHguc28KCQkJaWYgdGVzdCAtZiAiJHp6eiI7IHRoZW4KCQkJCWxwdGhyZWFkPSR4eHgKCQkJ
  CWJyZWFrOwoJCQlmaQoJCQl6eno9YGxzICR5eXkvbGliJHh4eC5zby4qIDI+L2Rldi9udWxsYAoJ
  CQlpZiB0ZXN0ICJYJHp6eiIgIT0gWDsgdGhlbgoJCQkJbHB0aHJlYWQ9JHh4eAoJCQkJYnJlYWs7
  CgkJCWZpCgkJZG9uZQoJCWlmIHRlc3QgIlgkbHB0aHJlYWQiICE9IFg7IHRoZW4KCQkJYnJlYWs7
  CgkJZmkKCWRvbmUKCWlmIHRlc3QgIlgkbHB0aHJlYWQiICE9IFg7IHRoZW4KCQkjIEFkZCAtbHB0
  aHJlYWQuCgkJbGlic3dhbnRlZD0iJGxpYnN3YW50ZWQgJGxwdGhyZWFkIgoJCSMgVGhlcmUgaXMg
  bm8gbGliY19yIGFzIG9mIE5ldEJTRCAxLjUuMiwgc28gbm8gYyAtPiBjX3IuCgkJIyBUaGlzIHdp
  bGwgYmUgcmV2aXNpdGVkIHdoZW4gTmV0QlNEIGdhaW5zIGEgbmF0aXZlIHB0aHJlYWRzCgkJIyBp
  bXBsZW1lbnRhdGlvbi4KCWVsc2UKCQllY2hvICIkMDogTm8gUE9TSVggdGhyZWFkcyBsaWJyYXJ5
  ICgtbHB0aHJlYWQpIGZvdW5kLiAgIiBcCgkJICAgICAiWW91IG1heSB3YW50IHRvIGluc3RhbGwg
  R05VIHB0aC4gIEFib3J0aW5nLiIgPiY0CgkJZXhpdCAxCglmaQoJdW5zZXQgbHB0aHJlYWQKCgkj
  IHNldmVyYWwgcmVlbnRyYW50IGZ1bmN0aW9ucyBhcmUgZW1iZWRkZWQgaW4gbGliYywgYnV0IGhh
  dmVuJ3QKCSMgYmVlbiBhZGRlZCB0byB0aGUgaGVhZGVyIGZpbGVzIHlldC4gIExldCdzIGhvbGQg
  b2ZmIG9uIHVzaW5nCgkjIHRoZW0gdW50aWwgdGhleSBhcmUgYSB2YWxpZCBwYXJ0IG9mIHRoZSBB
  UEkKCWNhc2UgIiRvc3ZlcnMiIGluCglbMDEyXS4qfDMuWzAtMV0pCgkJZF9nZXRwcm90b2J5bmFt
  ZV9yPSR1bmRlZgoJCWRfZ2V0cHJvdG9ieW51bWJlcl9yPSR1bmRlZgoJCWRfZ2V0cHJvdG9lbnRf
  cj0kdW5kZWYKCQlkX2dldHNlcnZieW5hbWVfcj0kdW5kZWYKCQlkX2dldHNlcnZieXBvcnRfcj0k
  dW5kZWYKCQlkX2dldHNlcnZlbnRfcj0kdW5kZWYKCQlkX3NldHByb3RvZW50X3I9JHVuZGVmCgkJ
  ZF9zZXRzZXJ2ZW50X3I9JHVuZGVmCgkJZF9lbmRwcm90b2VudF9yPSR1bmRlZgoJCWRfZW5kc2Vy
  dmVudF9yPSR1bmRlZiA7OwoJZXNhYwoJOzsKCmVzYWMKRU9DQlUKCiMgU2V0IHNlbnNpYmxlIGRl
  ZmF1bHRzIGZvciBOZXRCU0Q6IGxvb2sgZm9yIGxvY2FsIHNvZnR3YXJlIGluCiMgL3Vzci9wa2cg
  KE5ldEJTRCBQYWNrYWdlcyBDb2xsZWN0aW9uKSBhbmQgaW4gL3Vzci9sb2NhbC4KIwpsb2NsaWJw
  dGg9Ii91c3IvcGtnL2xpYiAvdXNyL2xvY2FsL2xpYiIKbG9jaW5jcHRoPSIvdXNyL3BrZy9pbmNs
  dWRlIC91c3IvbG9jYWwvaW5jbHVkZSIKY2FzZSAiJHJwYXRoZmxhZyIgaW4KJycpCglsZGZsYWdz
  PQoJOzsKKikKCWxkZmxhZ3M9Cglmb3IgeXl5IGluICRsb2NsaWJwdGg7IGRvCgkJbGRmbGFncz0i
  JGxkZmxhZ3MgJHJwYXRoZmxhZyR5eXkiCglkb25lCgk7Owplc2FjCgpjYXNlIGB1bmFtZSAtbWAg
  aW4KYWxwaGEpCiAgICBlY2hvICdpbnQgbWFpbigpIHt9JyA+IHRyeS5jCiAgICBnY2M9YCR7Y2M6
  LWNjfSAtdiAtYyB0cnkuYyAyPiYxfGdyZXAgJ2djYyB2ZXJzaW9uIGVnY3MtMidgCiAgICBjYXNl
  ICIkZ2NjIiBpbgogICAgJycgfCAiZ2NjIHZlcnNpb24gZWdjcy0yLjk1LiJbMy05XSopIDs7ICMg
  Mi45NS4zIG9yIGJldHRlciBva2F5CiAgICAqKQljYXQgPiY0IDw8RU9GCioqKgoqKiogWW91ciBn
  Y2MgKCRnY2MpIGlzIGtub3duIHRvIGJlCioqKiB0b28gYnVnZ3kgb24gbmV0YnNkL2FscGhhIHRv
  IGNvbXBpbGUgUGVybCB3aXRoIG9wdGltaXphdGlvbi4KKioqIEl0IGlzIHN1Z2dlc3RlZCB5b3Ug
  aW5zdGFsbCB0aGUgbGFuZy9nY2MgcGFja2FnZSB3aGljaCBzaG91bGQKKioqIGhhdmUgYXQgbGVh
  c3QgZ2NjIDIuOTUuMyB3aGljaCBzaG91bGQgd29yayBva2F5OiB1c2UgZm9yIGV4YW1wbGUKKioq
  IENvbmZpZ3VyZSAtRGNjPS91c3IvcGtnL2djYy0yLjk1LjMvYmluL2NjLiAgWW91IGNvdWxkIGFs
  c28KKioqIENvbmZpZ3VyZSAtRG9wdGltaXplPS1PMCB0byBjb21waWxlIFBlcmwgd2l0aG91dCBh
  bnkgb3B0aW1pemF0aW9uCioqKiBidXQgdGhhdCBpcyBub3QgcmVjb21tZW5kZWQuCioqKgpFT0YK
  CWV4aXQgMQoJOzsKICAgIGVzYWMKICAgIHJtIC1mIHRyeS4qCiAgICA7Owplc2FjCgojIE5ldEJT
  RC9zcGFyYyAxLjUuMy8xLjYuMSBkdW1wcyBjb3JlIGluIHRoZSBzZW1pZF9kcyB0ZXN0IG9mIENv
  bmZpZ3VyZS4KY2FzZSBgdW5hbWUgLW1gIGluCnNwYXJjKSBkX3NlbWN0bF9zZW1pZF9kcz11bmRl
  ZiA7Owplc2FjCgojIG1hbGxvYyB3cmFwIHdvcmtzCmNhc2UgIiR1c2VtYWxsb2N3cmFwIiBpbgon
  JykgdXNlbWFsbG9jd3JhcD0nZGVmaW5lJyA7Owplc2FjCgojIGRvbid0IHVzZSBwZXJsIG1hbGxv
  YyBieSBkZWZhdWx0CmNhc2UgIiR1c2VteW1hbGxvYyIgaW4KJycpIHVzZW15bWFsbG9jPW4gOzsK
  ZXNhYwo=',
  'freebsd' =>
  'IyBPcmlnaW5hbCBiYXNlZCBvbiBpbmZvIGZyb20KIyBDYXJsIE0uIEZvbmdoZWlzZXIgPGNtZkBp
  bnMuaW5mb25ldC5uZXQ+CiMgRGF0ZTogVGh1LCAyOCBKdWwgMTk5NCAxOToxNzowNSAtMDUwMCAo
  Q0RUKQojCiMgQWRkaXRpb25hbCAxLjEuNSBkZWZpbmVzIGZyb20gCiMgT2xsaXZpZXIgUm9iZXJ0
  IDxPbGxpdmllci5Sb2JlcnRAa2VsdGlhLmZybXVnLmZyLm5ldD4KIyBEYXRlOiBXZWQsIDI4IFNl
  cCAxOTk0IDAwOjM3OjQ2ICswMTAwIChNRVQpCiMKIyBBZGRpdGlvbmFsIDIuKiBkZWZpbmVzIGZy
  b20KIyBPbGxpdmllciBSb2JlcnQgPE9sbGl2aWVyLlJvYmVydEBrZWx0aWEuZnJtdWcuZnIubmV0
  PgojIERhdGU6IFNhdCwgOCBBcHIgMTk5NSAyMDo1Mzo0MSArMDIwMCAoTUVUIERTVCkKIwojIEFk
  ZGl0aW9uYWwgMi4wLjUgYW5kIDIuMSBkZWZpbmVkIGZyb20KIyBPbGxpdmllciBSb2JlcnQgPE9s
  bGl2aWVyLlJvYmVydEBrZWx0aWEuZnJtdWcuZnIubmV0PgojIERhdGU6IEZyaSwgMTIgTWF5IDE5
  OTUgMTQ6MzA6MzggKzAyMDAgKE1FVCBEU1QpCiMKIyBBZGRpdGlvbmFsIDIuMiBkZWZpbmVzIGZy
  b20KIyBNYXJrIE11cnJheSA8bWFya0Bncm9uZGFyLnphPgojIERhdGU6IFdlZCwgNiBOb3YgMTk5
  NiAwOTo0NDo1OCArMDIwMCAoTUVUKQojCiMgTW9kaWZpZWQgdG8gZW5zdXJlIHdlIHJlcGxhY2Ug
  LWxjIHdpdGggLWxjX3IsIGFuZAojIHRvIHB1dCBpbiBwbGFjZS1ob2xkZXJzIGZvciB2YXJpb3Vz
  IHNwZWNpZmljIGhpbnRzLgojIEFuZHkgRG91Z2hlcnR5IDxkb3VnaGVyYUBsYWZheWV0dGUuZWR1
  PgojIERhdGU6IFR1ZSBNYXIgMTAgMTY6MDc6MDAgRVNUIDE5OTgKIwojIFN1cHBvcnQgZm9yIEZy
  ZWVCU0QvRUxGCiMgT2xsaXZpZXIgUm9iZXJ0IDxyb2JlcnRvQGtlbHRpYS5mcmVlbml4LmZyPgoj
  IERhdGU6IFdlZCBTZXAgIDIgMTY6MjI6MTIgQ0VTVCAxOTk4CiMKIyBUaGUgdHdvIGZsYWdzICIt
  ZnBpYyAtRFBJQyIgYXJlIHVzZWQgdG8gaW5kaWNhdGUgYQojIHdpbGwtYmUtc2hhcmVkIG9iamVj
  dC4gIENvbmZpZ3VyZSB3aWxsIGd1ZXNzIHRoZSAtZnBpYywgKGFuZCB0aGUKIyAtRFBJQyBpcyBu
  b3QgdXNlZCBieSBwZXJsIHByb3BlcikgYnV0IHRoZSBmdWxsIGRlZmluZSBpcyBpbmNsdWRlZCB0
  byAKIyBiZSBjb25zaXN0ZW50IHdpdGggdGhlIEZyZWVCU0QgZ2VuZXJhbCBzaGFyZWQgbGlicyBi
  dWlsZGluZyBwcm9jZXNzLgojCiMgc2V0cmV1aWQgYW5kIGZyaWVuZHMgYXJlIGluaGVyZW50bHkg
  YnJva2VuIGluIGFsbCB2ZXJzaW9ucyBvZiBGcmVlQlNECiMgYmVmb3JlIDIuMS1jdXJyZW50IChi
  ZWZvcmUgYXBwcm94IGRhdGUgNC8xNS85NSkuIEl0IGlzIGZpeGVkIGluIDIuMC41CiMgYW5kIHdo
  YXQtd2lsbC1iZS0yLjEKIwoKY2FzZSAiJG9zdmVycyIgaW4KMC4qfDEuMCopCgl1c2VkbD0iJHVu
  ZGVmIgoJOzsKMS4xKikKCW1hbGxvY3R5cGU9J3ZvaWQgKicKCWdyb3Vwc3R5cGU9J2ludCcKCWRf
  c2V0cmVnaWQ9J3VuZGVmJwoJZF9zZXRyZXVpZD0ndW5kZWYnCglkX3NldHJnaWQ9J3VuZGVmJwoJ
  ZF9zZXRydWlkPSd1bmRlZicKCTs7CjIuMC1yZWxlYXNlKikKCWRfc2V0cmVnaWQ9J3VuZGVmJwoJ
  ZF9zZXRyZXVpZD0ndW5kZWYnCglkX3NldHJnaWQ9J3VuZGVmJwoJZF9zZXRydWlkPSd1bmRlZicK
  CTs7CiMKIyBUcnlpbmcgdG8gY292ZXIgMi4wLjUsIDIuMS1jdXJyZW50IGFuZCBmdXR1cmUgMi4x
  LzIuMgojIEl0IGRvZXMgbm90IGNvdmVydCBhbGwgMi4xLWN1cnJlbnQgdmVyc2lvbnMgYXMgdGhl
  IG91dHB1dCBvZiB1bmFtZQojIGNoYW5nZWQgYSBmZXcgdGltZXMuCiMKIyBFdmVuIHRob3VnaCBz
  ZXRldWlkL3NldGVnaWQgYXJlIGF2YWlsYWJsZSwgdGhleSd2ZSBiZWVuIHR1cm5lZCBvZmYKIyBi
  ZWNhdXNlIHBlcmwgaXNuJ3QgY29kZWQgd2l0aCBzYXZlZCBzZXRbdWddaWQgdmFyaWFibGVzIGlu
  IG1pbmQuCiMgSW4gYWRkaXRpb24sIGEgc21hbGwgcGF0Y2ggaXMgcmVxdWlyZWQgdG8gc3VpZHBl
  cmwgdG8gYXZvaWQgYSBzZWN1cml0eQojIHByb2JsZW0gd2l0aCBGcmVlQlNELgojCjIuMC41Knwy
  LjAtYnVpbHQqfDIuMSopCiAJdXNldmZvcms9J3RydWUnCgljYXNlICIkdXNlbXltYWxsb2MiIGlu
  CgkgICAgIiIpIHVzZW15bWFsbG9jPSduJwoJICAgICAgICA7OwoJZXNhYwoJZF9zZXRyZWdpZD0n
  ZGVmaW5lJwoJZF9zZXRyZXVpZD0nZGVmaW5lJwoJZF9zZXRlZ2lkPSd1bmRlZicKCWRfc2V0ZXVp
  ZD0ndW5kZWYnCgl0ZXN0IC1yIC4vYnJva2VuLWRiLm1zZyAmJiAuIC4vYnJva2VuLWRiLm1zZwoJ
  OzsKIwojIDIuMiBhbmQgYWJvdmUgaGF2ZSBwaGttYWxsb2MoMykuCiMgZG9uJ3QgdXNlIC1sbWFs
  bG9jIChtYXliZSB0aGVyZSdzIGFuIG9sZCBvbmUgZnJvbSAxLjEuNS4xIGZsb2F0aW5nIGFyb3Vu
  ZCkKMi4yKikKIAl1c2V2Zm9yaz0ndHJ1ZScKCWNhc2UgIiR1c2VteW1hbGxvYyIgaW4KCSAgICAi
  IikgdXNlbXltYWxsb2M9J24nCgkgICAgICAgIDs7Cgllc2FjCglsaWJzd2FudGVkPWBlY2hvICRs
  aWJzd2FudGVkIHwgc2VkICdzLyBtYWxsb2MgLyAvJ2AKCWxpYnN3YW50ZWQ9YGVjaG8gJGxpYnN3
  YW50ZWQgfCBzZWQgJ3MvIGJpbmQgLyAvJ2AKCSMgaWNvbnYgZ29uZSBpbiBQZXJsIDUuOC4xLCBi
  dXQgaWYgc29tZW9uZSBjb21waWxlcyA1LjguMCBvciBlYXJsaWVyLgoJbGlic3dhbnRlZD1gZWNo
  byAkbGlic3dhbnRlZCB8IHNlZCAncy8gaWNvbnYgLyAvJ2AKCWRfc2V0cmVnaWQ9J2RlZmluZScK
  CWRfc2V0cmV1aWQ9J2RlZmluZScKCWRfc2V0ZWdpZD0nZGVmaW5lJwoJZF9zZXRldWlkPSdkZWZp
  bmUnCgkjIGRfZG9zdWlkPSdkZWZpbmUnICMgT2Jzb2xldGUuCgk7OwoqKQl1c2V2Zm9yaz0ndHJ1
  ZScKCWNhc2UgIiR1c2VteW1hbGxvYyIgaW4KCSAgICAiIikgdXNlbXltYWxsb2M9J24nCgkgICAg
  ICAgIDs7Cgllc2FjCglsaWJzd2FudGVkPWBlY2hvICRsaWJzd2FudGVkIHwgc2VkICdzLyBtYWxs
  b2MgLyAvJ2AKCTs7CmVzYWMKCiMgRHluYW1pYyBMb2FkaW5nIGZsYWdzIGhhdmUgbm90IGNoYW5n
  ZWQgbXVjaCwgc28gdGhleSBhcmUgc2VwYXJhdGVkCiMgb3V0IGhlcmUgdG8gYXZvaWQgZHVwbGlj
  YXRpbmcgdGhlbSBldmVyeXdoZXJlLgpjYXNlICIkb3N2ZXJzIiBpbgowLip8MS4wKikgOzsKCjEq
  fDIqKQljY2NkbGZsYWdzPSctRFBJQyAtZnBpYycKCWxkZGxmbGFncz0iLUJzaGFyZWFibGUgJGxk
  ZGxmbGFncyIKCTs7CgozKnw0Knw1Knw2KikKICAgICAgICBvYmpmb3JtYXQ9YC91c3IvYmluL29i
  amZvcm1hdGAKICAgICAgICBpZiBbIHgkb2JqZm9ybWF0ID0geGFvdXQgXTsgdGhlbgogICAgICAg
  ICAgICBpZiBbIC1lIC91c3IvbGliL2FvdXQgXTsgdGhlbgogICAgICAgICAgICAgICAgbGlicHRo
  PSIvdXNyL2xpYi9hb3V0IC91c3IvbG9jYWwvbGliIC91c3IvbGliIgogICAgICAgICAgICAgICAg
  Z2xpYnB0aD0iL3Vzci9saWIvYW91dCAvdXNyL2xvY2FsL2xpYiAvdXNyL2xpYiIKICAgICAgICAg
  ICAgZmkKICAgICAgICAgICAgbGRkbGZsYWdzPSctQnNoYXJlYWJsZScKICAgICAgICBlbHNlCiAg
  ICAgICAgICAgIGxpYnB0aD0iL3Vzci9saWIgL3Vzci9sb2NhbC9saWIiCiAgICAgICAgICAgIGds
  aWJwdGg9Ii91c3IvbGliIC91c3IvbG9jYWwvbGliIgogICAgICAgICAgICBsZGZsYWdzPSItV2ws
  LUUgIgogICAgICAgICAgICBsZGRsZmxhZ3M9Ii1zaGFyZWQgIgogICAgICAgIGZpCiAgICAgICAg
  Y2NjZGxmbGFncz0nLURQSUMgLWZQSUMnCiAgICAgICAgOzsKKikKICAgICAgIGxpYnB0aD0iL3Vz
  ci9saWIgL3Vzci9sb2NhbC9saWIiCiAgICAgICBnbGlicHRoPSIvdXNyL2xpYiAvdXNyL2xvY2Fs
  L2xpYiIKICAgICAgIGxkZmxhZ3M9Ii1XbCwtRSAiCiAgICAgICAgbGRkbGZsYWdzPSItc2hhcmVk
  ICIKICAgICAgICBjY2NkbGZsYWdzPSctRFBJQyAtZlBJQycKICAgICAgIDs7CmVzYWMKCmNhc2Ug
  IiRvc3ZlcnMiIGluCjAqfDEqfDIqfDMqKSA7OwoKKikKCWNjZmxhZ3M9IiR7Y2NmbGFnc30gLURI
  QVNfRlBTRVRNQVNLIC1ESEFTX0ZMT0FUSU5HUE9JTlRfSCIKCWlmIC91c3IvYmluL2ZpbGUgLUwg
  L3Vzci9saWIvbGliYy5zbyB8IC91c3IvYmluL2dyZXAgLXZxICJub3Qgc3RyaXBwZWQiIDsgdGhl
  bgoJICAgIHVzZW5tPWZhbHNlCglmaQogICAgICAgIDs7CmVzYWMKCmNhdCA8PCdFT00nID4mNAoK
  U29tZSB1c2VycyBoYXZlIHJlcG9ydGVkIHRoYXQgQ29uZmlndXJlIGhhbHRzIHdoZW4gdGVzdGlu
  ZyBmb3IKdGhlIE9fTk9OQkxPQ0sgc3ltYm9sIHdpdGggYSBzeW50YXggZXJyb3IuICBUaGlzIGlz
  IGFwcGFyZW50bHkgYQpzaCBlcnJvci4gIFJlcnVubmluZyBDb25maWd1cmUgd2l0aCBrc2ggYXBw
  YXJlbnRseSBmaXhlcyB0aGUKcHJvYmxlbS4gIFRyeQoJa3NoIENvbmZpZ3VyZSBbeW91ciBvcHRp
  b25zXQoKRU9NCgojIEZyb206IEFudG9uIEJlcmV6aW4gPHRvYmV6QHBsYWIua3UuZGs+CiMgVG86
  IHBlcmw1LXBvcnRlcnNAcGVybC5vcmcKIyBTdWJqZWN0OiBbUEFUQ0ggNS4wMDVfNTRdIENvbmZp
  Z3VyZSAtIGhpbnRzL2ZyZWVic2Quc2ggc2lnbmFsIGhhbmRsZXIgdHlwZQojIERhdGU6IDMwIE5v
  diAxOTk4IDE5OjQ2OjI0ICswMTAwCiMgTWVzc2FnZS1JRDogPDg2NHNyaGh2Y3YuZnNmQGxpb24u
  cGxhYi5rdS5kaz4KCnNpZ25hbF90PSd2b2lkJwpkX3ZvaWRzaWc9J2RlZmluZScKCiMgc2V0IGxp
  YnBlcmwuc28uWC5YIGZvciAyLjIuWApjYXNlICIkb3N2ZXJzIiBpbgoyLjIqKQogICAgIyB1bmZv
  cnR1bmF0ZWx5IHRoaXMgY29kZSBnZXRzIGV4ZWN1dGVkIGJlZm9yZQogICAgIyB0aGUgZXF1aXZh
  bGVudCBpbiB0aGUgbWFpbiBDb25maWd1cmUgc28gd2UgY29weSBhIGxpdHRsZQogICAgIyBmcm9t
  IENvbmZpZ3VyZSBYWFggQ29uZmlndXJlIHNob3VsZCBiZSBmaXhlZC4KICAgIGlmICR0ZXN0IC1y
  ICRzcmMvcGF0Y2hsZXZlbC5oO3RoZW4KICAgICAgIHBhdGNobGV2ZWw9YGF3ayAnL2RlZmluZVsg
  CV0rUEVSTF9WRVJTSU9OLyB7cHJpbnQgJDN9JyAkc3JjL3BhdGNobGV2ZWwuaGAKICAgICAgIHN1
  YnZlcnNpb249YGF3ayAnL2RlZmluZVsgCV0rUEVSTF9TVUJWRVJTSU9OLyB7cHJpbnQgJDN9JyAk
  c3JjL3BhdGNobGV2ZWwuaGAKICAgIGVsc2UKICAgICAgIHBhdGNobGV2ZWw9MAogICAgICAgc3Vi
  dmVyc2lvbj0wCiAgICBmaQogICAgbGlicGVybD0ibGlicGVybC5zby4kcGF0Y2hsZXZlbC4kc3Vi
  dmVyc2lvbiIKICAgIHVuc2V0IHBhdGNobGV2ZWwKICAgIHVuc2V0IHN1YnZlcnNpb24KICAgIDs7
  CmVzYWMKCiMgVGhpcyBzY3JpcHQgVVUvdXNldGhyZWFkcy5jYnUgd2lsbCBnZXQgJ2NhbGxlZC1i
  YWNrJyBieSBDb25maWd1cmUgCiMgYWZ0ZXIgaXQgaGFzIHByb21wdGVkIHRoZSB1c2VyIGZvciB3
  aGV0aGVyIHRvIHVzZSB0aHJlYWRzLgpjYXQgPiBVVS91c2V0aHJlYWRzLmNidSA8PCdFT0NCVScK
  Y2FzZSAiJHVzZXRocmVhZHMiIGluCiRkZWZpbmV8dHJ1ZXxbeVldKikKICAgICAgICBsY19yPWAv
  c2Jpbi9sZGNvbmZpZyAtcnxncmVwICc6LWxjX3InfGF3ayAne3ByaW50ICRORn0nfHNlZCAtbiAn
  JHAnYAogICAgICAgIGNhc2UgIiRvc3ZlcnMiIGluICAKCTAqfDEqfDIuMCp8Mi4xKikgICBjYXQg
  PDxFT00gPiY0CkkgZGlkIG5vdCBrbm93IHRoYXQgRnJlZUJTRCAkb3N2ZXJzIHN1cHBvcnRzIFBP
  U0lYIHRocmVhZHMuCgpGZWVsIGZyZWUgdG8gdGVsbCBwZXJsYnVnQHBlcmwub3JnIG90aGVyd2lz
  ZS4KRU9NCgkgICAgICBleGl0IDEKCSAgICAgIDs7CgogICAgICAgIDIuMi5bMC03XSopCiAgICAg
  ICAgICAgICAgY2F0IDw8RU9NID4mNApQT1NJWCB0aHJlYWRzIGFyZSBub3Qgc3VwcG9ydGVkIHdl
  bGwgYnkgRnJlZUJTRCAkb3N2ZXJzLgoKUGxlYXNlIGNvbnNpZGVyIHVwZ3JhZGluZyB0byBhdCBs
  ZWFzdCBGcmVlQlNEIDIuMi44LApvciBwcmVmZXJhYmx5IHRvIHRoZSBtb3N0IHJlY2VudCAtUkVM
  RUFTRSBvciAtU1RBQkxFCnZlcnNpb24gKHNlZSBodHRwOi8vd3d3LmZyZWVic2Qub3JnL3JlbGVh
  c2VzLykuCgooV2hpbGUgMi4yLjcgZG9lcyBoYXZlIHB0aHJlYWRzLCBpdCBoYXMgc29tZSBwcm9i
  bGVtcwogd2l0aCB0aGUgY29tYmluYXRpb24gb2YgdGhyZWFkcyBhbmQgcGlwZXMgYW5kIHRoZXJl
  Zm9yZQogbWFueSBQZXJsIHRlc3RzIHdpbGwgZWl0aGVyIGhhbmcgb3IgZmFpbC4pCkVPTQoJICAg
  ICAgZXhpdCAxCgkgICAgICA7OwoKCVszLTVdLiopCgkgICAgICBpZiBbICEgLXIgIiRsY19yIiBd
  OyB0aGVuCgkgICAgICBjYXQgPDxFT00gPiY0ClBPU0lYIHRocmVhZHMgc2hvdWxkIGJlIHN1cHBv
  cnRlZCBieSBGcmVlQlNEICRvc3ZlcnMgLS0KYnV0IHlvdXIgc3lzdGVtIGlzIG1pc3NpbmcgdGhl
  IHNoYXJlZCBsaWJjX3IuCigvc2Jpbi9sZGNvbmZpZyAtciBkb2Vzbid0IGZpbmQgYW55KS4KCkNv
  bnNpZGVyIHVzaW5nIHRoZSBsYXRlc3QgU1RBQkxFIHJlbGVhc2UuCkVPTQoJCSBleGl0IDEKCSAg
  ICAgIGZpCgkgICAgICAjIDUwMDAxNiBpcyB0aGUgZmlyc3Qgb3NyZWxkYXRlIGluIHdoaWNoIG9u
  ZSBjb3VsZAoJICAgICAgIyBqdXN0IGxpbmsgYWdhaW5zdCBsaWJjX3Igd2l0aG91dCBkaXNwb3Np
  bmcgb2YgbGliYwoJICAgICAgIyBhdCB0aGUgc2FtZSB0aW1lLiAgNTAwMDE2IC4uLiB1cCB0byB3
  aGF0ZXZlciBpdCB3YXMKCSAgICAgICMgb24gdGhlIDMxc3Qgb2YgQXVndXN0IDIwMDMgY2FuIHN0
  aWxsIGJlIHVzZWQgd2l0aCAtcHRocmVhZCwKCSAgICAgICMgYnV0IGl0IGlzIG5vdCBuZWNlc3Nh
  cnkuCgoJICAgICAgIyBBbnRvbiBCZXJlemluIHNheXMgdGhhdCBwb3N0IDUwMHNvbWV0aGluZyB3
  ZSdyZSB3cm9uZyB0byBiZQoJICAgICAgIyB0byBiZSB1c2luZyAtbGNfciwgYW5kIHNob3VsZCBq
  dXN0IGJlIHVzaW5nIC1wdGhyZWFkIG9uIHRoZQoJICAgICAgIyBsaW5rZXIgbGluZS4KCSAgICAg
  ICMgU28gcHJlc3VtYWJseSByZWFsbHkgd2Ugc2hvdWxkIGJlIGNoZWNraW5nIHRoYXQgJG9zdmVy
  IGlzIDUuKikKCSAgICAgICMgYW5kIHRoYXQgYC9zYmluL3N5c2N0bCAtbiBrZXJuLm9zcmVsZGF0
  ZWAgLWdlIDUwMDAxNgoJICAgICAgIyBvciAtbHQgNTAwc29tZXRoaW5nIGFuZCBvbmx5IGluIHRo
  YXQgcmFuZ2Ugbm90IGRvaW5nIHRoaXM6CgkgICAgICBsZGZsYWdzPSItcHRocmVhZCAkbGRmbGFn
  cyIKCgkgICAgICAjIEJvdGggaW4gNC54IGFuZCA1LnggZ2V0aG9zdGJ5YWRkcl9yIGV4aXN0cyBi
  dXQKCSAgICAgICMgaXQgaXMgIlRlbXBvcmFyeSBmdW5jdGlvbiwgbm90IHRocmVhZHNhZmUiLi4u
  CgkgICAgICAjIFByZXN1bWFibHkgZWFybGllciBpdCBkaWRuJ3QgZXZlbiBleGlzdC4KCSAgICAg
  IGRfZ2V0aG9zdGJ5YWRkcl9yPSJ1bmRlZiIKCSAgICAgIGRfZ2V0aG9zdGJ5YWRkcl9yX3Byb3Rv
  PSIwIgoJICAgICAgOzsKCgkqKQoJICAgICAgIyA3LnggZG9lc24ndCBpbnN0YWxsIGxpYmNfciBi
  eSBkZWZhdWx0LCBhbmQgQ29uZmlndXJlCgkgICAgICAjIHdvdWxkIGZhaWwgaW4gdGhlIGNvZGUg
  Zm9sbG93aW5nCgkgICAgICAjCgkgICAgICAjIGdldGhvc3RieWFkZHJfcigpIGFwcGVhcnMgdG8g
  aGF2ZSBiZWVuIGltcGxlbWVudGVkIGluIDYueCsKCSAgICAgIGxkZmxhZ3M9Ii1wdGhyZWFkICRs
  ZGZsYWdzIgoJICAgICAgOzsKCgllc2FjCgogICAgICAgIGNhc2UgIiRvc3ZlcnMiIGluCiAgICAg
  ICAgWzEtNF0qKQoJICAgIHNldCBgZWNobyBYICIkbGlic3dhbnRlZCAifCBzZWQgLWUgJ3MvIGMg
  LyBjX3IgLydgCgkgICAgc2hpZnQKCSAgICBsaWJzd2FudGVkPSIkKiIKCSAgICA7OwogICAgICAg
  ICopCgkgICAgc2V0IGBlY2hvIFggIiRsaWJzd2FudGVkICJ8IHNlZCAtZSAncy8gYyAvLydgCgkg
  ICAgc2hpZnQKCSAgICBsaWJzd2FudGVkPSIkKiIKCSAgICA7OwoJZXNhYwoJICAgIAoJIyBDb25m
  aWd1cmUgd2lsbCBwcm9iYWJseSBwaWNrIHRoZSB3cm9uZyBsaWJjIHRvIHVzZSBmb3Igbm0gc2Nh
  bi4KCSMgVGhlIHNhZmVzdCBxdWljay1maXggaXMganVzdCB0byBub3QgdXNlIG5tIGF0IGFsbC4u
  LgoJdXNlbm09ZmFsc2UKCiAgICAgICAgY2FzZSAiJG9zdmVycyIgaW4KICAgICAgICAyLjIuOCop
  CiAgICAgICAgICAgICMgLi4uIGJ1dCB0aGlzIGRvZXMgbm90IGFwcGx5IGZvciAyLjIuOCAtIHdl
  IGtub3cgaXQncyBzYWZlCiAgICAgICAgICAgIGxpYmM9IiRsY19yIgogICAgICAgICAgICB1c2Vu
  bT10cnVlCiAgICAgICAgICAgOzsKICAgICAgICBlc2FjCgogICAgICAgIHVuc2V0IGxjX3IKCgkj
  IEV2ZW4gd2l0aCB0aGUgbWFsbG9jIG11dGV4ZXMgdGhlIFBlcmwgbWFsbG9jIGRvZXMgbm90Cgkj
  IHNlZW0gdG8gYmUgdGhyZWFkc2FmZSBpbiBGcmVlQlNEPwoJY2FzZSAiJHVzZW15bWFsbG9jIiBp
  bgoJJycpIHVzZW15bWFsbG9jPW4gOzsKCWVzYWMKZXNhYwpFT0NCVQoKIyBtYWxsb2Mgd3JhcCB3
  b3JrcwpjYXNlICIkdXNlbWFsbG9jd3JhcCIgaW4KJycpIHVzZW1hbGxvY3dyYXA9J2RlZmluZScg
  OzsKZXNhYwoKIyBYWFggVW5kZXIgRnJlZUJTRCA2LjAgKGFuZCBwcm9iYWJseSBtb3N0IG90aGVy
  IHNpbWlsYXIgdmVyc2lvbnMpCiMgUGVybF9kaWUoTlVMTCkgZ2VuZXJhdGVzIGEgd2FybmluZzoK
  IyAgICBwcF9zeXMuYzo0OTE6IHdhcm5pbmc6IG51bGwgZm9ybWF0IHN0cmluZwojIENvbmZpZ3Vy
  ZSBzdXBwb3NlZGVseSB0ZXN0cyBmb3IgdGhpcywgYnV0IGFwcGFyZW50bHkgdGhlIHRlc3QgZG9l
  c24ndAojIHdvcmsuICBWb2x1bnRlZXJzIHdpdGggRnJlZUJTRCBhcmUgbmVlZGVkIHRvIGltcHJv
  dmluZyB0aGUgQ29uZmlndXJlIHRlc3QuCiMgTWVhbndoaWxlLCB0aGUgZm9sbG93aW5nIHdvcmth
  cm91bmQgc2hvdWxkIGJlIHNhZmUgb24gYWxsIHZlcnNpb25zCiMgb2YgRnJlZUJTRC4KZF9wcmlu
  dGZfZm9ybWF0X251bGw9J3VuZGVmJwo=',
  'openbsd' =>
  'IyBoaW50cy9vcGVuYnNkLnNoCiMKIyBoaW50cyBmaWxlIGZvciBPcGVuQlNEOyBUb2RkIE1pbGxl
  ciA8bWlsbGVydEBvcGVuYnNkLm9yZz4KIyBFZGl0ZWQgdG8gYWxsb3cgQ29uZmlndXJlIGNvbW1h
  bmQtbGluZSBvdmVycmlkZXMgYnkKIyAgQW5keSBEb3VnaGVydHkgPGRvdWdoZXJhQGxhZmF5ZXR0
  ZS5lZHU+CiMKIyBUbyBidWlsZCB3aXRoIGRpc3RyaWJ1dGlvbiBwYXRocywgdXNlOgojCS4vQ29u
  ZmlndXJlIC1kZXMgLURvcGVuYnNkX2Rpc3RyaWJ1dGlvbj1kZWZpbmVkCiMKCiMgSW4gT3BlbkJT
  RCA+IDMuNywgdXNlIHBlcmwncyBtYWxsb2MgW3BlcmwgIzc1NzQyXQpjYXNlICIkb3N2ZXJzIiBp
  bgozLls4OV0qfFs0LTldKikKICAgIHRlc3QgIiR1c2VteW1hbGxvYyIgfHwgdXNlbXltYWxsb2M9
  eQogICAgOzsKZXNhYwoKIyBtYWxsb2Mgd3JhcCB3b3JrcwpjYXNlICIkdXNlbWFsbG9jd3JhcCIg
  aW4KJycpIHVzZW1hbGxvY3dyYXA9J2RlZmluZScgOzsKZXNhYwoKIyBDdXJyZW50bHksIHZmb3Jr
  KDIpIGlzIG5vdCBhIHJlYWwgd2luIG92ZXIgZm9yaygyKS4KdXNldmZvcms9IiR1bmRlZiIKCiMg
  SW4gT3BlbkJTRCA8IDMuMywgdGhlIHNldHJlP1t1Z11pZCgpIGFyZSBlbXVsYXRlZCB1c2luZyB0
  aGUKIyBfUE9TSVhfU0FWRURfSURTIGZ1bmN0aW9uYWxpdHkgd2hpY2ggZG9lcyBub3QgaGF2ZSB0
  aGUgc2FtZQojIHNlbWFudGljcyBhcyA0LjNCU0QuICBTdGFydGluZyB3aXRoIE9wZW5CU0QgMy4z
  LCB0aGUgb3JpZ2luYWwKIyBzZW1hbnRpY3MgaGF2ZSBiZWVuIHJlc3RvcmVkLgpjYXNlICIkb3N2
  ZXJzIiBpbgpbMC0yXS4qfDMuWzAtMl0pCglkX3NldHJlZ2lkPSR1bmRlZgoJZF9zZXRyZXVpZD0k
  dW5kZWYKCWRfc2V0cmdpZD0kdW5kZWYKCWRfc2V0cnVpZD0kdW5kZWYKZXNhYwoKIwojIE5vdCBh
  bGwgcGxhdGZvcm1zIHN1cHBvcnQgZHluYW1pYyBsb2FkaW5nLi4uCiMgRm9yIHRoZSBjYXNlIG9m
  ICIkb3BlbmJzZF9kaXN0cmlidXRpb24iLCB0aGUgaGludHMgZmlsZQojIG5lZWRzIHRvIGtub3cg
  d2hldGhlciB3ZSBhcmUgdXNpbmcgZHluYW1pYyBsb2FkaW5nIHNvIHRoYXQKIyBpdCBjYW4gc2V0
  IHRoZSBsaWJwZXJsIG5hbWUgYXBwcm9wcmlhdGVseS4KIyBBbGxvdyBjb21tYW5kIGxpbmUgb3Zl
  cnJpZGVzLgojCkFSQ0g9YGFyY2ggfCBzZWQgJ3MvXk9wZW5CU0QuLy8nYApjYXNlICIke0FSQ0h9
  LSR7b3N2ZXJzfSIgaW4KYWxwaGEtMi5bMC04XXxtaXBzLTIuWzAtOF18cG93ZXJwYy0yLlswLTdd
  fG04OGstKnxocHBhLSp8dmF4LSopCgl0ZXN0IC16ICIkdXNlZGwiICYmIHVzZWRsPSR1bmRlZgoJ
  OzsKKikKCXRlc3QgLXogIiR1c2VkbCIgJiYgdXNlZGw9JGRlZmluZQoJIyBXZSB1c2UgLWZQSUMg
  aGVyZSBiZWNhdXNlIC1mcGljIGlzICpOT1QqIGVub3VnaCBmb3Igc29tZSBvZiB0aGUKCSMgZXh0
  ZW5zaW9ucyBsaWtlIFRrIG9uIHNvbWUgT3BlbkJTRCBwbGF0Zm9ybXMgKGllOiBzcGFyYykKCWNj
  Y2RsZmxhZ3M9Ii1EUElDIC1mUElDICRjY2NkbGZsYWdzIgoJY2FzZSAiJG9zdmVycyIgaW4KCVsw
  MV0uKnwyLlswLTddfDIuWzAtN10uKikKCQlsZGRsZmxhZ3M9Ii1Cc2hhcmVhYmxlICRsZGRsZmxh
  Z3MiCgkJOzsKCTIuWzgtOV18My4wKQoJCWxkPSR7Y2M6LWNjfQoJCWxkZGxmbGFncz0iLXNoYXJl
  ZCAtZlBJQyAkbGRkbGZsYWdzIgoJCTs7CgkqKSAjIGZyb20gMy4xIG9ud2FyZHMKCQlsZD0ke2Nj
  Oi1jY30KCQlsZGRsZmxhZ3M9Ii1zaGFyZWQgLWZQSUMgJGxkZGxmbGFncyIKCQlsaWJzd2FudGVk
  PWBlY2hvICRsaWJzd2FudGVkIHwgc2VkICdzLyBkbCAvIC8nYAoJCTs7Cgllc2FjCgoJIyBXZSBu
  ZWVkIHRvIGZvcmNlIGxkIHRvIGV4cG9ydCBzeW1ib2xzIG9uIEVMRiBwbGF0Zm9ybXMuCgkjIFdp
  dGhvdXQgdGhpcywgZGxvcGVuKCkgaXMgY3JpcHBsZWQuCglFTEY9YCR7Y2M6LWNjfSAtZE0gLUUg
  LSA8L2Rldi9udWxsIHwgZ3JlcCBfX0VMRl9fYAoJdGVzdCAtbiAiJEVMRiIgJiYgbGRmbGFncz0i
  LVdsLC1FICRsZGZsYWdzIgoJOzsKZXNhYwoKIwojIFR3ZWFrcyBmb3IgdmFyaW91cyB2ZXJzaW9u
  cyBvZiBPcGVuQlNECiMKY2FzZSAiJG9zdmVycyIgaW4KMi41KQoJIyBPcGVuQlNEIDIuNSBoYXMg
  YnJva2VuIG9kYm0gc3VwcG9ydAoJaV9kYm09JHVuZGVmCgk7Owplc2FjCgojIE9wZW5CU0QgZG9l
  c24ndCBuZWVkIGxpYmNyeXB0IGJ1dCBtYW55IGZvbGtzIGtlZXAgYSBzdHViIGxpYgojIGFyb3Vu
  ZCBmb3Igb2xkIE5ldEJTRCBiaW5hcmllcy4KbGlic3dhbnRlZD1gZWNobyAkbGlic3dhbnRlZCB8
  IHNlZCAncy8gY3J5cHQgLyAvJ2AKCiMgQ29uZmlndXJlIGNhbid0IGZpZ3VyZSB0aGlzIG91dCBu
  b24taW50ZXJhY3RpdmVseQpkX3N1aWRzYWZlPSRkZWZpbmUKCiMgY2MgaXMgZ2NjIHNvIHdlIGNh
  biBkbyBiZXR0ZXIgdGhhbiAtTwojIEFsbG93IGEgY29tbWFuZC1saW5lIG92ZXJyaWRlLCBzdWNo
  IGFzIC1Eb3B0aW1pemU9LWcKY2FzZSAke0FSQ0h9IGluCm04OGspCiAgIG9wdGltaXplPSctTzAn
  CiAgIDs7CmhwcGEpCiAgIG9wdGltaXplPSctTzAnCiAgIDs7CiopCiAgIHRlc3QgIiRvcHRpbWl6
  ZSIgfHwgb3B0aW1pemU9Jy1PMicKICAgOzsKZXNhYwoKIyBUaGlzIHNjcmlwdCBVVS91c2V0aHJl
  YWRzLmNidSB3aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZpZ3VyZSAKIyBhZnRlciBpdCBo
  YXMgcHJvbXB0ZWQgdGhlIHVzZXIgZm9yIHdoZXRoZXIgdG8gdXNlIHRocmVhZHMuCmNhdCA+IFVV
  L3VzZXRocmVhZHMuY2J1IDw8J0VPQ0JVJwpjYXNlICIkdXNldGhyZWFkcyIgaW4KJGRlZmluZXx0
  cnVlfFt5WV0qKQoJIyBhbnkgb3BlbmJzZCB2ZXJzaW9uIGRlcGVuZGVuY2llcyB3aXRoIHB0aHJl
  YWRzPwoJY2NmbGFncz0iLXB0aHJlYWQgJGNjZmxhZ3MiCglsZGZsYWdzPSItcHRocmVhZCAkbGRm
  bGFncyIKCWNhc2UgIiRvc3ZlcnMiIGluCglbMC0yXS4qfDMuWzAtMl0pCgkJIyBDaGFuZ2UgZnJv
  bSAtbGMgdG8gLWxjX3IKCQlzZXQgYGVjaG8gIlggJGxpYnN3YW50ZWQgIiB8IHNlZCAncy8gYyAv
  IGNfciAvJ2AKCQlzaGlmdAoJCWxpYnN3YW50ZWQ9IiQqIgoJOzsKCWVzYWMKCWNhc2UgIiRvc3Zl
  cnMiIGluCglbMDEyXS4qfDMuWzAtNl0pCiAgICAgICAgCSMgQnJva2VuIGF0IGxlYXN0IHVwIHRv
  IE9wZW5CU0QgMy42LCB3ZSdsbCBzZWUgYWJvdXQgMy43CgkJZF9nZXRzZXJ2YnluYW1lX3I9JHVu
  ZGVmIDs7Cgllc2FjCmVzYWMKRU9DQlUKCiMgVGhpcyBzY3JpcHQgVVUvdXNlNjRiaXRpbnQuY2J1
  IHdpbGwgZ2V0ICdjYWxsZWQtYmFjaycgYnkgQ29uZmlndXJlIAojIGFmdGVyIGl0IGhhcyBwcm9t
  cHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byB1c2UgNjQtYml0bmVzcy4KY2F0ID4gVVUvdXNl
  NjRiaXRpbnQuY2J1IDw8J0VPQ0JVJwpjYXNlICIkdXNlNjRiaXRpbnQiIGluCiRkZWZpbmV8dHJ1
  ZXxbeVldKikKCWVjaG8gIiAiCgllY2hvICJDaGVja2luZyBpZiB5b3VyIEMgbGlicmFyeSBoYXMg
  YnJva2VuIDY0LWJpdCBmdW5jdGlvbnMuLi4iID4mNAoJJGNhdCA+Y2hlY2suYyA8PEVPQ1AKI2lu
  Y2x1ZGUgPHN0ZGlvLmg+CnR5cGVkZWYgJHVxdWFkdHlwZSBteVVMTDsKaW50IG1haW4gKHZvaWQp
  CnsKICAgIHN0cnVjdCB7Cglkb3VibGUgZDsKCW15VUxMICB1OwogICAgfSAqcCwgdGVzdFtdID0g
  ewoJezQyOTQ5NjczMDMuMTUsIDQyOTQ5NjczMDNVTEx9LAoJezQyOTQ5NjcyOTQuMiwgIDQyOTQ5
  NjcyOTRVTEx9LAoJezQyOTQ5NjcyOTUuNywgIDQyOTQ5NjcyOTVVTEx9LAoJezAuMCwgMFVMTH0K
  ICAgIH07CiAgICBmb3IgKHAgPSB0ZXN0OyBwLT51OyBwKyspIHsKCW15VUxMIHggPSAobXlVTEwp
  cC0+ZDsKCWlmICh4ICE9IHAtPnUpIHsKCSAgICBwcmludGYoImJ1Z2d5XG4iKTsKCSAgICByZXR1
  cm4gMDsKCX0KICAgIH0KICAgIHByaW50Zigib2tcbiIpOwogICAgcmV0dXJuIDA7Cn0KRU9DUAoJ
  c2V0IGNoZWNrCglpZiBldmFsICRjb21waWxlX29rOyB0aGVuCgkgICAgbGliY3F1YWQ9YC4vY2hl
  Y2tgCgkgICAgZWNobyAiWW91ciBDIGxpYnJhcnkncyA2NC1iaXQgZnVuY3Rpb25zIGFyZSAkbGli
  Y3F1YWQuIgoJZWxzZQoJICAgIGVjaG8gIihJIGNhbid0IHNlZW0gdG8gY29tcGlsZSB0aGUgdGVz
  dCBwcm9ncmFtLikiCgkgICAgZWNobyAiQXNzdW1pbmcgdGhhdCB5b3VyIEMgbGlicmFyeSdzIDY0
  LWJpdCBmdW5jdGlvbnMgYXJlIG9rLiIKCSAgICBsaWJjcXVhZD0ib2siCglmaQoJJHJtIC1mIGNo
  ZWNrLmMgY2hlY2sKCgljYXNlICIkbGliY3F1YWQiIGluCgkgICAgYnVnZ3kqKQoJCWNhdCA+JjQg
  PDxFT00KCioqKiBZb3UgaGF2ZSBhIEMgbGlicmFyeSB3aXRoIGJyb2tlbiA2NC1iaXQgZnVuY3Rp
  b25zLgoqKiogNjQtYml0IHN1cHBvcnQgZG9lcyBub3Qgd29yayByZWxpYWJseSBpbiB0aGlzIGNv
  bmZpZ3VyYXRpb24uCioqKiBQbGVhc2UgcmVydW4gQ29uZmlndXJlIHdpdGhvdXQgLUR1c2U2NGJp
  dGludCBhbmQvb3IgLUR1c2Vtb3JlYml0cy4KKioqIENhbm5vdCBjb250aW51ZSwgYWJvcnRpbmcu
  CgpFT00KCQlleGl0IDEKCQk7OwoJZXNhYwplc2FjCkVPQ0JVCgojIFdoZW4gYnVpbGRpbmcgaW4g
  dGhlIE9wZW5CU0QgdHJlZSB3ZSB1c2UgZGlmZmVyZW50IHBhdGhzCiMgVGhpcyBpcyBvbmx5IHBh
  cnQgb2YgdGhlIHN0b3J5LCB0aGUgcmVzdCBjb21lcyBmcm9tIGNvbmZpZy5vdmVyCmNhc2UgIiRv
  cGVuYnNkX2Rpc3RyaWJ1dGlvbiIgaW4KJyd8JHVuZGVmfGZhbHNlKSA7OwoqKQoJIyBXZSBwdXQg
  dGhpbmdzIGluIC91c3IsIG5vdCAvdXNyL2xvY2FsCglwcmVmaXg9Jy91c3InCglwcmVmaXhleHA9
  Jy91c3InCglzeXNtYW49Jy91c3Ivc2hhcmUvbWFuL21hbjEnCglsaWJwdGg9Jy91c3IvbGliJwoJ
  Z2xpYnB0aD0nL3Vzci9saWInCgkjIExvY2FsIHRoaW5ncywgaG93ZXZlciwgZG8gZ28gaW4gL3Vz
  ci9sb2NhbAoJc2l0ZXByZWZpeD0nL3Vzci9sb2NhbCcKCXNpdGVwcmVmaXhleHA9Jy91c3IvbG9j
  YWwnCgkjIFBvcnRzIGluc3RhbGxzIG5vbi1zdGQgbGlicyBpbiAvdXNyL2xvY2FsL2xpYiBzbyBs
  b29rIHRoZXJlIHRvbwoJbG9jaW5jcHRoPScvdXNyL2xvY2FsL2luY2x1ZGUnCglsb2NsaWJwdGg9
  Jy91c3IvbG9jYWwvbGliJwoJIyBMaW5rIHBlcmwgd2l0aCBzaGFyZWQgbGlicGVybAoJaWYgWyAi
  JHVzZWRsIiA9ICIkZGVmaW5lIiAtYSAtciBzaGxpYl92ZXJzaW9uIF07IHRoZW4KCQl1c2VzaHJw
  bGliPXRydWUKCQlsaWJwZXJsPWAuIC4vc2hsaWJfdmVyc2lvbjsgZWNobyBsaWJwZXJsLnNvLiR7
  bWFqb3J9LiR7bWlub3J9YAoJZmkKCTs7CmVzYWMKCiMgZW5kCg==',
  'linux' =>
  'IyBoaW50cy9saW51eC5zaAojIE9yaWdpbmFsIHZlcnNpb24gYnkgcnNhbmRlcnMKIyBBZGRpdGlv
  bmFsIHN1cHBvcnQgYnkgS2VubmV0aCBBbGJhbm93c2tpIDxramFoZHNAa2phaGRzLmNvbT4KIwoj
  IEVMRiBzdXBwb3J0IGJ5IEguSi4gTHUgPGhqbEBueW5leHN0LmNvbT4KIyBBZGRpdGlvbmFsIGlu
  Zm8gZnJvbSBOaWdlbCBIZWFkIDxuaGVhZEBFU09DLmJpdG5ldD4KIyBhbmQgS2VubmV0aCBBbGJh
  bm93c2tpIDxramFoZHNAa2phaGRzLmNvbT4KIwojIENvbnNvbGlkYXRlZCBieSBBbmR5IERvdWdo
  ZXJ0eSA8ZG91Z2hlcmFAbGFmYXlldHRlLmVkdT4KIwojIFVwZGF0ZWQgVGh1IEZlYiAgOCAxMTo1
  NjoxMCBFU1QgMTk5NgoKIyBVcGRhdGVkIFRodSBNYXkgMzAgMTA6NTA6MjIgRURUIDE5OTYgYnkg
  PGRvdWdoZXJhQGxhZmF5ZXR0ZS5lZHU+CgojIFVwZGF0ZWQgRnJpIEp1biAyMSAxMTowNzo1NCBF
  RFQgMTk5NgojIE5EQk0gc3VwcG9ydCBmb3IgRUxGIHJlLWVuYWJsZWQgYnkgPGtqYWhkc0BramFo
  ZHMuY29tPgoKIyBObyB2ZXJzaW9uIG9mIExpbnV4IHN1cHBvcnRzIHNldHVpZCBzY3JpcHRzLgpk
  X3N1aWRzYWZlPSd1bmRlZicKCiMgRGViaWFuIGFuZCBSZWQgSGF0LCBhbmQgcGVyaGFwcyBvdGhl
  ciB2ZW5kb3JzLCBwcm92aWRlIGJvdGggcnVudGltZSBhbmQKIyBkZXZlbG9wbWVudCBwYWNrYWdl
  cyBmb3Igc29tZSBsaWJyYXJpZXMuICBUaGUgcnVudGltZSBwYWNrYWdlcyBjb250YWluIHNoYXJl
  ZAojIGxpYnJhcmllcyB3aXRoIHZlcnNpb24gaW5mb3JtYXRpb24gaW4gdGhlaXIgbmFtZXMgKGUu
  Zy4sIGxpYmdkYm0uc28uMS43LjMpOwojIHRoZSBkZXZlbG9wbWVudCBwYWNrYWdlcyBzdXBwbGVt
  ZW50IHRoaXMgd2l0aCB2ZXJzaW9ubGVzcyBzaGFyZWQgbGlicmFyaWVzCiMgKGUuZy4sIGxpYmdk
  Ym0uc28pLgojCiMgSWYgeW91IHdhbnQgdG8gbGluayBhZ2FpbnN0IHN1Y2ggYSBsaWJyYXJ5LCB5
  b3UgbXVzdCBpbnN0YWxsIHRoZSBkZXZlbG9wbWVudAojIHZlcnNpb24gb2YgdGhlIHBhY2thZ2Uu
  CiMKIyBUaGVzZSBwYWNrYWdlcyB1c2UgYSAtZGV2IG5hbWluZyBjb252ZW50aW9uIGluIGJvdGgg
  RGViaWFuIGFuZCBSZWQgSGF0OgojICAgbGliZ2RibWcxICAobm9uLWRldmVsb3BtZW50IHZlcnNp
  b24gb2YgR05VIGxpYmMgMi1saW5rZWQgR0RCTSBsaWJyYXJ5KQojICAgbGliZ2RibWcxLWRldiAo
  ZGV2ZWxvcG1lbnQgdmVyc2lvbiBvZiBHTlUgbGliYyAyLWxpbmtlZCBHREJNIGxpYnJhcnkpCiMg
  U28gbWFrZSBzdXJlIHRoYXQgZm9yIGFueSBsaWJyYXJpZXMgeW91IHdpc2ggdG8gbGluayBQZXJs
  IHdpdGggdW5kZXIKIyBEZWJpYW4gb3IgUmVkIEhhdCB5b3UgaGF2ZSB0aGUgLWRldiBwYWNrYWdl
  cyBpbnN0YWxsZWQuCgojIFN1U0UgTGludXggY2FuIGJlIHVzZWQgYXMgY3Jvc3MtY29tcGlsYXRp
  b24gaG9zdCBmb3IgQ3JheSBYVDQgQ2F0YW1vdW50L1FrLgppZiB0ZXN0IC1kIC9vcHQveHQtcGUK
  dGhlbgogIGNhc2UgImBjYyAtViAyPiYxYCIgaW4KICAqY2F0YW1vdW50KikgLiBoaW50cy9jYXRh
  bW91bnQuc2g7IHJldHVybiA7OwogIGVzYWMKZmkKCiMgU29tZSBvcGVyYXRpbmcgc3lzdGVtcyAo
  ZS5nLiwgU29sYXJpcyAyLjYpIHdpbGwgbGluayB0byBhIHZlcnNpb25lZCBzaGFyZWQKIyBsaWJy
  YXJ5IGltcGxpY2l0bHkuICBGb3IgZXhhbXBsZSwgb24gU29sYXJpcywgYGxkIGZvby5vIC1sZ2Ri
  bScgd2lsbCBmaW5kIGFuCiMgYXBwcm9wcmlhdGUgdmVyc2lvbiBvZiBsaWJnZGJtLCBpZiBvbmUg
  aXMgYXZhaWxhYmxlOyBMaW51eCwgaG93ZXZlciwgZG9lc24ndAojIGRvIHRoZSBpbXBsaWNpdCBt
  YXBwaW5nLgppZ25vcmVfdmVyc2lvbmVkX3NvbGlicz0neScKCiMgQlNEIGNvbXBhdGliaWxpdHkg
  bGlicmFyeSBubyBsb25nZXIgbmVlZGVkCiMgJ2thZmZlJyBoYXMgYSAvdXNyL2xpYi9saWJuZXQu
  c28gd2hpY2ggaXMgbm90IGF0IGFsbCByZWxldmFudCBmb3IgcGVybC4KIyBiaW5kIGNhdXNlcyBp
  c3N1ZXMgd2l0aCBzZXZlcmFsIHJlZW50cmFudCBmdW5jdGlvbnMKc2V0IGBlY2hvIFggIiRsaWJz
  d2FudGVkICJ8IHNlZCAtZSAncy8gYnNkIC8gLycgLWUgJ3MvIG5ldCAvIC8nIC1lICdzLyBiaW5k
  IC8gLydgCnNoaWZ0CmxpYnN3YW50ZWQ9IiQqIgoKIyBEZWJpYW4gNC4wIHB1dHMgbmRibSBpbiB0
  aGUgLWxnZGJtX2NvbXBhdCBsaWJyYXJ5LgpsaWJzd2FudGVkPSIkbGlic3dhbnRlZCBnZGJtX2Nv
  bXBhdCIKCiMgSWYgeW91IGhhdmUgZ2xpYmMsIHRoZW4gcmVwb3J0IHRoZSB2ZXJzaW9uIGZvciAu
  L215Y29uZmlnIGJ1ZyByZXBvcnRpbmcuCiMgKENvbmZpZ3VyZSBkb2Vzbid0IG5lZWQgdG8ga25v
  dyB0aGUgc3BlY2lmaWMgdmVyc2lvbiBzaW5jZSBpdCBqdXN0IHVzZXMKIyBnY2MgdG8gbG9hZCB0
  aGUgbGlicmFyeSBmb3IgYWxsIHRlc3RzLikKIyBXZSBkb24ndCB1c2UgX19HTElCQ19fIGFuZCAg
  X19HTElCQ19NSU5PUl9fIGJlY2F1c2UgdGhleQojIGFyZSBpbnN1ZmZpY2llbnRseSBwcmVjaXNl
  IHRvIGRpc3Rpbmd1aXNoIHRoaW5ncyBsaWtlCiMgbGliYy0yLjAuNiBhbmQgbGliYy0yLjAuNy4K
  aWYgdGVzdCAtTCAvbGliL2xpYmMuc28uNjsgdGhlbgogICAgbGliYz1gbHMgLWwgL2xpYi9saWJj
  LnNvLjYgfCBhd2sgJ3twcmludCAkTkZ9J2AKICAgIGxpYmM9L2xpYi8kbGliYwpmaQoKIyBDb25m
  aWd1cmUgbWF5IGZhaWwgdG8gZmluZCBsc3RhdCgpIHNpbmNlIGl0J3MgYSBzdGF0aWMvaW5saW5l
  CiMgZnVuY3Rpb24gaW4gPHN5cy9zdGF0Lmg+LgpkX2xzdGF0PWRlZmluZQoKIyBtYWxsb2Mgd3Jh
  cCB3b3JrcwpjYXNlICIkdXNlbWFsbG9jd3JhcCIgaW4KJycpIHVzZW1hbGxvY3dyYXA9J2RlZmlu
  ZScgOzsKZXNhYwoKIyBUaGUgc3lzdGVtIG1hbGxvYygpIGlzIGFib3V0IGFzIGZhc3QgYW5kIGFz
  IGZydWdhbCBhcyBwZXJsJ3MuCiMgU2luY2UgdGhlIHN5c3RlbSBtYWxsb2MoKSBoYXMgYmVlbiB0
  aGUgZGVmYXVsdCBzaW5jZSBhdCBsZWFzdAojIDUuMDAxLCB3ZSBtaWdodCBhcyB3ZWxsIGxlYXZl
  IGl0IHRoYXQgd2F5LiAgLS1BRCAgMTAgSmFuIDIwMDIKY2FzZSAiJHVzZW15bWFsbG9jIiBpbgon
  JykgdXNlbXltYWxsb2M9J24nIDs7CmVzYWMKCiMgQ2hlY2sgaWYgd2UncmUgYWJvdXQgdG8gdXNl
  IEludGVsJ3MgSUNDIGNvbXBpbGVyCmNhc2UgImAke2NjOi1jY30gLVYgMj4mMWAiIGluCioiSW50
  ZWwoUikgQysrIENvbXBpbGVyIip8KiJJbnRlbChSKSBDIENvbXBpbGVyIiopCiAgICAjIHJlY29y
  ZCB0aGUgdmVyc2lvbiwgZm9ybWF0czoKICAgICMgaWNjIChJQ0MpIDEwLjEgMjAwODA4MDEKICAg
  ICMgaWNwYyAoSUNDKSAxMC4xIDIwMDgwODAxCiAgICAjIGZvbGxvd2VkIGJ5IGEgY29weXJpZ2h0
  IG9uIHRoZSBzZWNvbmQgbGluZQogICAgY2N2ZXJzaW9uPWAke2NjOi1jY30gLS12ZXJzaW9uIHwg
  c2VkIC1uIC1lICdzL15pY3BcP2MgXCgoSUNDKSBcKVw/Ly9wJ2AKICAgICMgVGhpcyBpcyBuZWVk
  ZWQgZm9yIENvbmZpZ3VyZSdzIHByb3RvdHlwZSBjaGVja3MgdG8gd29yayBjb3JyZWN0bHkKICAg
  ICMgVGhlIC1tcCBmbGFnIGlzIG5lZWRlZCB0byBwYXNzIHZhcmlvdXMgZmxvYXRpbmcgcG9pbnQg
  cmVsYXRlZCB0ZXN0cwogICAgIyBUaGUgLW5vLWdjYyBmbGFnIGlzIG5lZWRlZCBvdGhlcndpc2Us
  IGljYyBwcmV0ZW5kcyAocG9vcmx5KSB0byBiZSBnY2MKICAgIGNjZmxhZ3M9Ii13ZTE0NyAtbXAg
  LW5vLWdjYyAkY2NmbGFncyIKICAgICMgUHJldmVudCByZWxvY2F0aW9uIGVycm9ycyBvbiA2NGJp
  dHMgYXJjaAogICAgY2FzZSAiYHVuYW1lIC1tYCIgaW4KCSppYTY0KnwqeDg2XzY0KikKCSAgICBj
  Y2NkbGZsYWdzPSctZlBJQycKCTs7CiAgICBlc2FjCiAgICAjIElmIHdlJ3JlIHVzaW5nIElDQywg
  d2UgdXN1YWxseSB3YW50IHRoZSBiZXN0IHBlcmZvcm1hbmNlCiAgICBjYXNlICIkb3B0aW1pemUi
  IGluCiAgICAnJykgb3B0aW1pemU9Jy1PMycgOzsKICAgIGVzYWMKICAgIDs7CioiIFN1biAiKiJD
  IiopCiAgICAjIFN1bidzIEMgY29tcGlsZXIsIHdoaWNoIG1pZ2h0IGhhdmUgYSAndGFnJyBuYW1l
  IGJldHdlZW4KICAgICMgJ1N1bicgYW5kIHRoZSAnQyc6ICBFeGFtcGxlczoKICAgICMgY2M6IFN1
  biBDIDUuOSBMaW51eF9pMzg2IFBhdGNoIDEyNDg3MS0wMSAyMDA3LzA3LzMxCiAgICAjIGNjOiBT
  dW4gQ2VyZXMgQyA1LjEwIExpbnV4X2kzODYgMjAwOC8wNy8xMAogICAgdGVzdCAiJG9wdGltaXpl
  IiB8fCBvcHRpbWl6ZT0nLXhPMicKICAgIGNjY2RsZmxhZ3M9Jy1LUElDJwogICAgbGRkbGZsYWdz
  PSctRyAtQmR5bmFtaWMnCiAgICAjIFN1biBDIGRvZXNuJ3Qgc3VwcG9ydCBnY2MgYXR0cmlidXRl
  cywgYnV0LCBpbiBtYW55IGNhc2VzLCBkb2Vzbid0CiAgICAjIGNvbXBsYWluIGVpdGhlci4gIE5v
  dCBhbGwgY2FzZXMsIHRob3VnaC4KICAgIGRfYXR0cmlidXRlX2Zvcm1hdD0ndW5kZWYnCiAgICBk
  X2F0dHJpYnV0ZV9tYWxsb2M9J3VuZGVmJwogICAgZF9hdHRyaWJ1dGVfbm9ubnVsbD0ndW5kZWYn
  CiAgICBkX2F0dHJpYnV0ZV9ub3JldHVybj0ndW5kZWYnCiAgICBkX2F0dHJpYnV0ZV9wdXJlPSd1
  bmRlZicKICAgIGRfYXR0cmlidXRlX3VudXNlZD0ndW5kZWYnCiAgICBkX2F0dHJpYnV0ZV93YXJu
  X3VudXNlZF9yZXN1bHQ9J3VuZGVmJwogICAgOzsKZXNhYwoKY2FzZSAiJG9wdGltaXplIiBpbgoj
  IHVzZSAtTzIgYnkgZGVmYXVsdCA7IC1PMyBkb2Vzbid0IHNlZW0gdG8gYnJpbmcgc2lnbmlmaWNh
  bnQgYmVuZWZpdHMgd2l0aCBnY2MKJycpCiAgICBvcHRpbWl6ZT0nLU8yJwogICAgY2FzZSAiYHVu
  YW1lIC1tYCIgaW4KICAgICAgICBwcGMqKQogICAgICAgICAgICAjIG9uIHBwYywgaXQgc2VlbXMg
  dGhhdCBnY2MgKGF0IGxlYXN0IGdjYyAzLjMuMikgaXNuJ3QgaGFwcHkKICAgICAgICAgICAgIyB3
  aXRoIC1PMiA7IHNvIGRvd25ncmFkZSB0byAtTzEuCiAgICAgICAgICAgIG9wdGltaXplPSctTzEn
  CiAgICAgICAgOzsKICAgICAgICBpYTY0KikKICAgICAgICAgICAgIyBUaGlzIGFyY2hpdGVjdHVy
  ZSBoYXMgaGFkIHZhcmlvdXMgcHJvYmxlbXMgd2l0aCBnY2MncwogICAgICAgICAgICAjIGluIHRo
  ZSAzLjIsIDMuMywgYW5kIDMuNCByZWxlYXNlcyB3aGVuIG9wdGltaXplZCB0byAtTzIuICBTZWUK
  ICAgICAgICAgICAgIyBSVCAjMzcxNTYgZm9yIGEgZGlzY3Vzc2lvbiBvZiB0aGUgcHJvYmxlbS4K
  ICAgICAgICAgICAgY2FzZSAiYCR7Y2M6LWdjY30gLXYgMj4mMWAiIGluCiAgICAgICAgICAgICoi
  dmVyc2lvbiAzLjIiKnwqInZlcnNpb24gMy4zIip8KiJ2ZXJzaW9uIDMuNCIqKQogICAgICAgICAg
  ICAgICAgY2NmbGFncz0iLWZuby1kZWxldGUtbnVsbC1wb2ludGVyLWNoZWNrcyAkY2NmbGFncyIK
  ICAgICAgICAgICAgOzsKICAgICAgICAgICAgZXNhYwogICAgICAgIDs7CiAgICBlc2FjCiAgICA7
  Owplc2FjCgojIFVidW50dSAxMS4wNCAoYW5kIGxhdGVyLCBwcmVzdW1hYmx5KSBkb2Vzbid0IGtl
  ZXAgbW9zdCBsaWJyYXJpZXMKIyAoc3VjaCBhcyAtbG0pIGluIC9saWIgb3IgL3Vzci9saWIuICBT
  byB3ZSBoYXZlIHRvIGFzayBnY2MgdG8gdGVsbCB1cwojIHdoZXJlIHRvIGxvb2suICBXZSBkb24n
  dCB3YW50IGdjYydzIG93biBsaWJyYXJpZXMsIGhvd2V2ZXIsIHNvIHdlCiMgZmlsdGVyIHRob3Nl
  IG91dC4KIyBUaGlzIGNvdWxkIGJlIGNvbmRpdGlvbmFsIG9uIFVuYnVudHUsIGJ1dCBvdGhlciBk
  aXN0cmlidXRpb25zIG1heQojIGZvbGxvdyBzdWl0LCBhbmQgdGhpcyBzY2hlbWUgc2VlbXMgdG8g
  d29yayBldmVuIG9uIHJhdGhlciBvbGQgZ2NjJ3MuCiMgVGhpcyB1bmNvbmRpdGlvbmFsbHkgdXNl
  cyBnY2MgYmVjYXVzZSBldmVuIGlmIHRoZSB1c2VyIGlzIHVzaW5nIGFub3RoZXIKIyBjb21waWxl
  ciwgd2Ugc3RpbGwgbmVlZCB0byBmaW5kIHRoZSBtYXRoIGxpYnJhcnkgYW5kIGZyaWVuZHMsIGFu
  ZCBJIGRvbid0CiMga25vdyBob3cgb3RoZXIgY29tcGlsZXJzIHdpbGwgY29wZSB3aXRoIHRoYXQg
  c2l0dWF0aW9uLgojIFN0aWxsLCBhcyBhbiBlc2NhcGUgaGF0Y2gsIGFsbG93IENvbmZpZ3VyZSBj
  b21tYW5kIGxpbmUgb3ZlcnJpZGVzIHRvCiMgcGxpYnB0aCB0byBieXBhc3MgdGhpcyBjaGVjay4K
  Y2FzZSAiJHBsaWJwdGgiIGluCicnKSBwbGlicHRoPWBnY2MgLXByaW50LXNlYXJjaC1kaXJzIHwg
  Z3JlcCBsaWJyYXJpZXMgfAoJY3V0IC1mMi0gLWQ9IHwgdHIgJzonICR0cm5sIHwgZ3JlcCAtdiAn
  Z2NjJyB8IHNlZCAtZSAnczovJDo6J2AKICAgIHNldCBYICRwbGlicHRoICMgQ29sbGFwc2UgYWxs
  IGVudHJpZXMgb24gb25lIGxpbmUKICAgIHNoaWZ0CiAgICBwbGlicHRoPSIkKiIKICAgIDs7CmVz
  YWMKCiMgQXJlIHdlIHVzaW5nIEVMRj8gIFRoYW5rcyB0byBLZW5uZXRoIEFsYmFub3dza2kgPGtq
  YWhkc0BramFoZHMuY29tPgojIGZvciB0aGlzIHRlc3QuCmNhdCA+dHJ5LmMgPDwnRU9NJwovKiBU
  ZXN0IGZvciB3aGV0aGVyIEVMRiBiaW5hcmllcyBhcmUgcHJvZHVjZWQgKi8KI2luY2x1ZGUgPGZj
  bnRsLmg+CiNpbmNsdWRlIDxzdGRsaWIuaD4KI2luY2x1ZGUgPHVuaXN0ZC5oPgptYWluKCkgewoJ
  Y2hhciBidWZmZXJbNF07CglpbnQgaT1vcGVuKCJhLm91dCIsT19SRE9OTFkpOwoJaWYoaT09LTEp
  CgkJZXhpdCgxKTsgLyogZmFpbCAqLwoJaWYocmVhZChpLCZidWZmZXJbMF0sNCk8NCkKCQlleGl0
  KDEpOyAvKiBmYWlsICovCglpZihidWZmZXJbMF0gIT0gMTI3IHx8IGJ1ZmZlclsxXSAhPSAnRScg
  fHwKICAgICAgICAgICBidWZmZXJbMl0gIT0gJ0wnIHx8IGJ1ZmZlclszXSAhPSAnRicpCgkJZXhp
  dCgxKTsgLyogZmFpbCAqLwoJZXhpdCgwKTsgLyogc3VjY2VlZCAoeWVzLCBpdCdzIEVMRikgKi8K
  fQpFT00KaWYgJHtjYzotZ2NjfSB0cnkuYyA+L2Rldi9udWxsIDI+JjEgJiYgJHJ1biAuL2Eub3V0
  OyB0aGVuCiAgICBjYXQgPDwnRU9NJyA+JjQKCllvdSBhcHBlYXIgdG8gaGF2ZSBFTEYgc3VwcG9y
  dC4gIEknbGwgdHJ5IHRvIHVzZSBpdCBmb3IgZHluYW1pYyBsb2FkaW5nLgpJZiBkeW5hbWljIGxv
  YWRpbmcgZG9lc24ndCB3b3JrLCByZWFkIGhpbnRzL2xpbnV4LnNoIGZvciBmdXJ0aGVyIGluZm9y
  bWF0aW9uLgpFT00KCmVsc2UKICAgIGNhdCA8PCdFT00nID4mNAoKWW91IGRvbid0IGhhdmUgYW4g
  RUxGIGdjYy4gIEkgd2lsbCB1c2UgZGxkIGlmIHBvc3NpYmxlLiAgSWYgeW91IGFyZQp1c2luZyBh
  IHZlcnNpb24gb2YgRExEIGVhcmxpZXIgdGhhbiAzLjIuNiwgb3IgZG9uJ3QgaGF2ZSBpdCBhdCBh
  bGwsIHlvdQpzaG91bGQgcHJvYmFibHkgdXBncmFkZS4gSWYgeW91IGFyZSBmb3JjZWQgdG8gdXNl
  IDMuMi40LCB5b3Ugc2hvdWxkCnVuY29tbWVudCBhIGNvdXBsZSBvZiBsaW5lcyBpbiBoaW50cy9s
  aW51eC5zaCBhbmQgcmVzdGFydCBDb25maWd1cmUgc28KdGhhdCBzaGFyZWQgbGlicmFyaWVzIHdp
  bGwgYmUgZGlzYWxsb3dlZC4KCkVPTQogICAgbGRkbGZsYWdzPSItciAkbGRkbGZsYWdzIgogICAg
  IyBUaGVzZSBlbXB0eSB2YWx1ZXMgYXJlIHNvIHRoYXQgQ29uZmlndXJlIGRvZXNuJ3QgcHV0IGlu
  IHRoZQogICAgIyBMaW51eCBFTEYgdmFsdWVzLgogICAgY2NkbGZsYWdzPScgJwogICAgY2NjZGxm
  bGFncz0nICcKICAgIGNjZmxhZ3M9Ii1ET1ZSX0RCTF9ESUc9MTQgJGNjZmxhZ3MiCiAgICBzbz0n
  c2EnCiAgICBkbGV4dD0nbycKICAgIG5tX3NvX29wdD0nICcKICAgICMjIElmIHlvdSBhcmUgdXNp
  bmcgRExEIDMuMi40IHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgc2hhcmVkIGxpYnMsCiAgICAjIyB1
  bmNvbW1lbnQgdGhlIG5leHQgdHdvIGxpbmVzOgogICAgI2xkZmxhZ3M9Ii1zdGF0aWMiCiAgICAj
  c289J25vbmUnCgoJIyBJbiBhZGRpdGlvbiwgb24gc29tZSBzeXN0ZW1zIHRoZXJlIGlzIGEgcHJv
  YmxlbSB3aXRoIHBlcmwgYW5kIE5EQk0KCSMgd2hpY2ggY2F1c2VzIEFueURCTSBhbmQgTkRCTV9G
  aWxlIHRvIGxvY2sgdXAuIFRoaXMgaXMgZXZpZGVuY2VkCgkjIGluIHRoZSB0ZXN0cyBhcyBBbnlE
  Qk0ganVzdCBmcmVlemluZy4gIEFwcGFyZW50bHksIHRoaXMgb25seQoJIyBoYXBwZW5zIG9uIGEu
  b3V0IHN5c3RlbXMsIHNvIHdlIGRpc2FibGUgTkRCTSBmb3IgYWxsIGEub3V0IGxpbnV4CgkjIHN5
  c3RlbXMuICBJZiBzb21lb25lIGNhbiBzdWdnZXN0IGEgbW9yZSByb2J1c3QgdGVzdAoJIyAgdGhh
  dCB3b3VsZCBiZSBhcHByZWNpYXRlZC4KCSMKCSMgTW9yZSBpbmZvOgoJIyBEYXRlOiBXZWQsIDcg
  RmViIDE5OTYgMDM6MjE6MDQgKzA5MDAKCSMgRnJvbTogSmVmZnJleSBGcmllZGwgPGpmcmllZGxA
  bmZmLm5jbC5vbXJvbi5jby5qcD4KCSMKCSMgSSB0cmllZCBjb21waWxpbmcgd2l0aCBEQk0gc3Vw
  cG9ydCBhbmQgc3VyZSBlbm91Z2ggdGhpbmdzIGxvY2tlZCB1cAoJIyBqdXN0IGFzIGFkdmVydGlz
  ZWQuIENoZWNraW5nIGludG8gaXQsIEkgZm91bmQgdGhhdCB0aGUgbG9ja3VwIHdhcwoJIyBkdXJp
  bmcgdGhlIGNhbGwgdG8gZGJtX29wZW4uIE5vdCAqaW4qIGRibV9vcGVuIC0tIGJ1dCBiZXR3ZWVu
  IHRoZSBjYWxsCgkjIHRvIGFuZCB0aGUganVtcCBpbnRvLgoJIwoJIyBUbyBtYWtlIGEgbG9uZyBz
  dG9yeSBzaG9ydCwgbWFraW5nIHN1cmUgdGhhdCB0aGUgKi5hIGFuZCAqLnNhIHBhaXJzIG9mCgkj
  ICAgL3Vzci9saWIvbGlie20sZGIsZ2RibX0ue2Esc2F9CgkjIHdlcmUgcGVyZmVjdGx5IGluIHN5
  bmMgdG9vayBjYXJlIG9mIGl0LgoJIwoJIyBUaGlzIHdpbGwgZ2VuZXJhdGUgYSBoYXJtbGVzcyBX
  aG9hIFRoZXJlISBtZXNzYWdlCgljYXNlICIkZF9kYm1fb3BlbiIgaW4KCScnKQljYXQgPDwnRU9N
  JyA+JjQKCkRpc2FibGluZyBuZGJtLiAgVGhpcyB3aWxsIGdlbmVyYXRlIGEgV2hvYSBUaGVyZSBt
  ZXNzYWdlIGluIENvbmZpZ3VyZS4KUmVhZCBoaW50cy9saW51eC5zaCBmb3IgZnVydGhlciBpbmZv
  cm1hdGlvbi4KRU9NCgkJIyBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgd2l0aCBDb25maWd1cmUgLURk
  X2RibV9vcGVuCgkJZF9kYm1fb3Blbj11bmRlZgoJCTs7Cgllc2FjCmZpCgpybSAtZiB0cnkuYyBh
  Lm91dAoKaWYgL2Jpbi9zaCAtYyBleGl0OyB0aGVuCiAgZWNobyAnJwogIGVjaG8gJ1lvdSBhcHBl
  YXIgdG8gaGF2ZSBhIHdvcmtpbmcgYmFzaC4gIEdvb2QuJwplbHNlCiAgY2F0IDw8ICdFT00nID4m
  NAoKKioqKioqKioqKioqKioqKioqKioqKiogV2FybmluZyEgKioqKioqKioqKioqKioqKioqKioq
  Ckl0IHdvdWxkIGFwcGVhciB5b3UgaGF2ZSBhIGRlZmVjdGl2ZSBiYXNoIHNoZWxsIGluc3RhbGxl
  ZC4gVGhpcyBpcyBsaWtlbHkgdG8KZ2l2ZSB5b3UgYSBmYWlsdXJlIG9mIG9wL2V4ZWMgdGVzdCAj
  NSBkdXJpbmcgdGhlIHRlc3QgcGhhc2Ugb2YgdGhlIGJ1aWxkLApVcGdyYWRpbmcgdG8gYSByZWNl
  bnQgdmVyc2lvbiAoMS4xNC40IG9yIGxhdGVyKSBzaG91bGQgZml4IHRoZSBwcm9ibGVtLgoqKioq
  KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioKRU9NCgpm
  aQoKIyBPbiBTUEFSQ2xpbnV4LAojIFRoZSBmb2xsb3dpbmcgY3NoIGNvbnNpc3RlbnRseSBjb3Jl
  ZHVtcGVkIGluIHRoZSB0ZXN0IGRpcmVjdG9yeQojICIvaG9tZS9taWtlZGxyL3Blcmw1LjAwM185
  NC90IiwgdGhvdWdoIG5vdCBtb3N0IG90aGVyIGRpcmVjdG9yaWVzLgoKI05hbWUgICAgICAgIDog
  Y3NoICAgICAgICAgICAgICAgICAgICBEaXN0cmlidXRpb246IFJlZCBIYXQgTGludXggKFJlbWJy
  YW5kdCkKI1ZlcnNpb24gICAgIDogNS4yLjYgICAgICAgICAgICAgICAgICAgICAgICBWZW5kb3I6
  IFJlZCBIYXQgU29mdHdhcmUKI1JlbGVhc2UgICAgIDogMyAgICAgICAgICAgICAgICAgICAgICAg
  IEJ1aWxkIERhdGU6IEZyaSBNYXkgMjQgMTk6NDI6MTQgMTk5NgojSW5zdGFsbCBkYXRlOiBUaHUg
  SnVsIDExIDE2OjIwOjE0IDE5OTYgQnVpbGQgSG9zdDogaXRjaHkucmVkaGF0LmNvbQojR3JvdXAg
  ICAgICAgOiBTaGVsbHMgICAgICAgICAgICAgICAgICAgU291cmNlIFJQTTogY3NoLTUuMi42LTMu
  c3JjLnJwbQojU2l6ZSAgICAgICAgOiAxODQ0MTcKI0Rlc2NyaXB0aW9uIDogQlNEIGMtc2hlbGwK
  CiMgRm9yIHRoaXMgcmVhc29uIEkgc3VnZ2VzdCB1c2luZyB0aGUgbXVjaCBidWctZml4ZWQgdGNz
  aCBmb3IgZ2xvYmJpbmcKIyB3aGVyZSBhdmFpbGFibGUuCgojIE5vdmVtYmVyIDIwMDE6ICBUaGF0
  IHdhcm5pbmcncyBwcmV0dHkgb2xkIG5vdyBhbmQgcHJvYmFibHkgbm90IHNvCiMgcmVsZXZhbnQs
  IGVzcGVjaWFsbHkgc2luY2UgcGVybCBub3cgdXNlcyBGaWxlOjpHbG9iIGZvciBnbG9iYmluZy4K
  IyBXZSdsbCBzdGlsbCBsb29rIGZvciB0Y3NoLCBidXQgdG9uZSBkb3duIHRoZSB3YXJuaW5ncy4K
  IyBBbmR5IERvdWdoZXJ0eSwgTm92LiA2LCAyMDAxCmlmICRjc2ggLWMgJ2VjaG8gJHZlcnNpb24n
  ID4vZGV2L251bGwgMj4mMTsgdGhlbgogICAgZWNobyAnWW91ciBjc2ggaXMgcmVhbGx5IHRjc2gu
  ICBHb29kLicKZWxzZQogICAgaWYgeHh4PWAuL1VVL2xvYyB0Y3NoIGJsdXJmbCAkcHRoYDsgJHRl
  c3QgLWYgIiR4eHgiOyB0aGVuCgllY2hvICJGb3VuZCB0Y3NoLiAgSSdsbCB1c2UgaXQgZm9yIGds
  b2JiaW5nLiIKCSMgV2UgY2FuJ3QgY2hhbmdlIENvbmZpZ3VyZSdzIHNldHRpbmcgb2YgJGNzaCwg
  ZHVlIHRvIHRoZSB3YXkKCSMgQ29uZmlndXJlIGhhbmRsZXMgJGRfcG9ydGFibGUgYW5kIGNvbW1h
  bmRzIGZvdW5kIGluICRsb2NsaXN0LgoJIyBXZSBjYW4gc2V0IHRoZSB2YWx1ZSBmb3IgQ1NIIGlu
  IGNvbmZpZy5oIGJ5IHNldHRpbmcgZnVsbF9jc2guCglmdWxsX2NzaD0keHh4CiAgICBlbGlmIFsg
  LWYgIiRjc2giIF07IHRoZW4KCWVjaG8gIkNvdWxkbid0IGZpbmQgdGNzaC4gIENzaC1iYXNlZCBn
  bG9iYmluZyBtaWdodCBiZSBicm9rZW4uIgogICAgZmkKZmkKCiMgU2hpbXBlaSBZYW1hc2hpdGEg
  PHNoaW1wZWlAc29jcmF0ZXMucGF0bmV0LmNhbHRlY2guZWR1PgojIE1lc3NhZ2UtSWQ6IDwzM0VG
  MTYzNC5CMzZCNjUwMEBwb2JveC5jb20+CiMKIyBUaGUgRFIyIG9mIE1rTGludXggKG9zbmFtZT1s
  aW51eCxhcmNobmFtZT1wcGMtbGludXgpIG1heSBuZWVkCiMgc3BlY2lhbCBmbGFncyBwYXNzZWQg
  aW4gb3JkZXIgZm9yIGR5bmFtaWMgbG9hZGluZyB0byB3b3JrLgojIGluc3RlYWQgb2YgdGhlIHJl
  Y29tbWVuZGVkOgojCiMgY2NkbGZsYWdzPSctcmR5bmFtaWMnCiMKIyBpdCBzaG91bGQgYmU6CiMg
  Y2NkbGZsYWdzPSctV2wsLUUnCiMKIyBTbyBpZiB5b3VyIERSMiAoRFIzIGNhbWUgb3V0IHN1bW1l
  ciAxOTk4LCBjb25zaWRlciB1cGdyYWRpbmcpCiMgaGFzIHByb2JsZW1zIHdpdGggZHluYW1pYyBs
  b2FkaW5nLCB1bmNvbW1lbnQgdGhlCiMgZm9sbG93aW5nIHRocmVlIGxpbmVzLCBtYWtlIGRpc3Rj
  bGVhbiwgYW5kIHJlLUNvbmZpZ3VyZToKI2Nhc2UgImB1bmFtZSAtciB8IHNlZCAncy9eWzAtOS4t
  XSovLydgYGFyY2hgIiBpbgojJ29zZm1hY2gzcHBjJykgY2NkbGZsYWdzPSctV2wsLUUnIDs7CiNl
  c2FjCgpjYXNlICJgdW5hbWUgLW1gIiBpbgpzcGFyYyopCgljYXNlICIkY2NjZGxmbGFncyIgaW4K
  CSotZnBpYyopIGNjY2RsZmxhZ3M9ImBlY2hvICRjY2NkbGZsYWdzfHNlZCAncy8tZnBpYy8tZlBJ
  Qy8nYCIgOzsKCSotZlBJQyopIDs7CgkqKQkgY2NjZGxmbGFncz0iJGNjY2RsZmxhZ3MgLWZQSUMi
  IDs7Cgllc2FjCgk7Owplc2FjCgojIFN1U0U4LjIgaGFzIC91c3IvbGliL2xpYm5kYm0qIHdoaWNo
  IGFyZSBsZCBzY3JpcHRzIHJhdGhlciB0aGFuCiMgdHJ1ZSBsaWJyYXJpZXMuIFRoZSBzY3JpcHRz
  IGNhdXNlIGJpbmRpbmcgYWdhaW5zdCBzdGF0aWMKIyB2ZXJzaW9uIG9mIC1sZ2RibSB3aGljaCBp
  cyBhIGJhZCBpZGVhLiBTbyBpZiB3ZSBoYXZlICdubScKIyBtYWtlIHN1cmUgaXQgY2FuIHJlYWQg
  dGhlIGZpbGUKIyBOSS1TIDIwMDMvMDgvMDcKaWYgWyAtciAvdXNyL2xpYi9saWJuZGJtLnNvICAt
  YSAgLXggL3Vzci9iaW4vbm0gXSA7IHRoZW4KICAgaWYgL3Vzci9iaW4vbm0gL3Vzci9saWIvbGli
  bmRibS5zbyA+L2Rldi9udWxsIDI+JjEgOyB0aGVuCiAgICBlY2hvICdZb3VyIHNoYXJlZCAtbG5k
  Ym0gc2VlbXMgdG8gYmUgYSByZWFsIGxpYnJhcnkuJwogICBlbHNlCiAgICBlY2hvICdZb3VyIHNo
  YXJlZCAtbG5kYm0gaXMgbm90IGEgcmVhbCBsaWJyYXJ5LicKICAgIHNldCBgZWNobyBYICIkbGli
  c3dhbnRlZCAifCBzZWQgLWUgJ3MvIG5kYm0gLyAvJ2AKICAgIHNoaWZ0CiAgICBsaWJzd2FudGVk
  PSIkKiIKICAgZmkKZmkKCgojIFRoaXMgc2NyaXB0IFVVL3VzZXRocmVhZHMuY2J1IHdpbGwgZ2V0
  ICdjYWxsZWQtYmFjaycgYnkgQ29uZmlndXJlCiMgYWZ0ZXIgaXQgaGFzIHByb21wdGVkIHRoZSB1
  c2VyIGZvciB3aGV0aGVyIHRvIHVzZSB0aHJlYWRzLgpjYXQgPiBVVS91c2V0aHJlYWRzLmNidSA8
  PCdFT0NCVScKaWYgZ2V0Y29uZiBHTlVfTElCUFRIUkVBRF9WRVJTSU9OIHwgZ3JlcCBOUFRMID4v
  ZGV2L251bGwgMj4vZGV2L251bGwKdGhlbgogICAgdGhyZWFkc2hhdmVwaWRzPSIiCmVsc2UKICAg
  IHRocmVhZHNoYXZlcGlkcz0iLURUSFJFQURTX0hBVkVfUElEUyIKZmkKY2FzZSAiJHVzZXRocmVh
  ZHMiIGluCiRkZWZpbmV8dHJ1ZXxbeVldKikKICAgICAgICBjY2ZsYWdzPSItRF9SRUVOVFJBTlQg
  LURfR05VX1NPVVJDRSAkdGhyZWFkc2hhdmVwaWRzICRjY2ZsYWdzIgogICAgICAgIGlmIGVjaG8g
  JGxpYnN3YW50ZWQgfCBncmVwIC12IHB0aHJlYWQgPi9kZXYvbnVsbAogICAgICAgIHRoZW4KICAg
  ICAgICAgICAgc2V0IGBlY2hvIFggIiRsaWJzd2FudGVkICJ8IHNlZCAtZSAncy8gYyAvIHB0aHJl
  YWQgYyAvJ2AKICAgICAgICAgICAgc2hpZnQKICAgICAgICAgICAgbGlic3dhbnRlZD0iJCoiCiAg
  ICAgICAgZmkKCgkjIFNvbWVob3cgYXQgbGVhc3QgaW4gRGViaWFuIDIuMiB0aGVzZSBtYW5hZ2Ug
  dG8gZXNjYXBlCgkjIHRoZSAjZGVmaW5lIGZvcmVzdCBvZiA8ZmVhdHVyZXMuaD4gYW5kIDx0aW1l
  Lmg+IHNvIHRoYXQKCSMgdGhlIGhhc3Byb3RvIG1hY3JvIG9mIENvbmZpZ3VyZSBkb2Vzbid0IHNl
  ZSB0aGVzZSBwcm90b3MsCgkjIGV2ZW4gd2l0aCB0aGUgLURfR05VX1NPVVJDRS4KCglkX2FzY3Rp
  bWVfcl9wcm90bz0iJGRlZmluZSIKCWRfY3J5cHRfcl9wcm90bz0iJGRlZmluZSIKCWRfY3RpbWVf
  cl9wcm90bz0iJGRlZmluZSIKCWRfZ210aW1lX3JfcHJvdG89IiRkZWZpbmUiCglkX2xvY2FsdGlt
  ZV9yX3Byb3RvPSIkZGVmaW5lIgoJZF9yYW5kb21fcl9wcm90bz0iJGRlZmluZSIKCgk7Owplc2Fj
  CkVPQ0JVCgpjYXQgPiBVVS91c2VsYXJnZWZpbGVzLmNidSA8PCdFT0NCVScKIyBUaGlzIHNjcmlw
  dCBVVS91c2VsYXJnZWZpbGVzLmNidSB3aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZpZ3Vy
  ZQojIGFmdGVyIGl0IGhhcyBwcm9tcHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byB1c2UgbGFy
  Z2UgZmlsZXMuCmNhc2UgIiR1c2VsYXJnZWZpbGVzIiBpbgonJ3wkZGVmaW5lfHRydWV8W3lZXSop
  CiMgS2VlcCB0aGlzIGluIHRoZSBsZWZ0IG1hcmdpbi4KY2NmbGFnc191c2VsYXJnZWZpbGVzPSIt
  RF9MQVJHRUZJTEVfU09VUkNFIC1EX0ZJTEVfT0ZGU0VUX0JJVFM9NjQiCgoJY2NmbGFncz0iJGNj
  ZmxhZ3MgJGNjZmxhZ3NfdXNlbGFyZ2VmaWxlcyIKCTs7CmVzYWMKRU9DQlUKCiMgUHVyaWZ5IGZh
  aWxzIHRvIGxpbmsgUGVybCBpZiBhICItbGMiIGlzIHBhc3NlZCBpbnRvIGl0cyBsaW5rZXIKIyBk
  dWUgdG8gZHVwbGljYXRlIHN5bWJvbHMuCmNhc2UgIiRQVVJJRlkiIGluCiRkZWZpbmV8dHJ1ZXxb
  eVldKikKICAgIHNldCBgZWNobyBYICIkbGlic3dhbnRlZCAifCBzZWQgLWUgJ3MvIGMgLyAvJ2AK
  ICAgIHNoaWZ0CiAgICBsaWJzd2FudGVkPSIkKiIKICAgIDs7CmVzYWMKCiMgSWYgd2UgYXJlIHVz
  aW5nIGcrKyB3ZSBtdXN0IHVzZSBubSBhbmQgZm9yY2Ugb3Vyc2VsdmVzIHRvIHVzZQojIHRoZSAv
  dXNyL2xpYi9saWJjLmEgKHJlc2V0dGluZyB0aGUgbGliYyBiZWxvdyB0byBhbiBlbXB0eSBzdHJp
  bmcKIyBtYWtlcyBDb25maWd1cmUgdG8gbG9vayBmb3IgdGhlIHJpZ2h0IG9uZSkgYmVjYXVzZSB0
  aGUgc3ltYm9sCiMgc2Nhbm5pbmcgdHJpY2tzIG9mIENvbmZpZ3VyZSB3aWxsIGNyYXNoIGFuZCBi
  dXJuIGhvcnJpYmx5LgpjYXNlICIkY2MiIGluCipnKysqKSB1c2VubT10cnVlCiAgICAgICBsaWJj
  PScnCiAgICAgICA7Owplc2FjCgojIElmIHVzaW5nIGcrKywgdGhlIENvbmZpZ3VyZSBzY2FuIGZv
  ciBkbG9wZW4oKSBhbmQgKGVzcGVjaWFsbHkpCiMgZGxlcnJvcigpIG1pZ2h0IGZhaWwsIGVhc2ll
  ciBqdXN0IHRvIGZvcmNpYmx5IGhpbnQgdGhlbSBpbi4KY2FzZSAiJGNjIiBpbgoqZysrKikKICBk
  X2Rsb3Blbj0nZGVmaW5lJwogIGRfZGxlcnJvcj0nZGVmaW5lJwogIDs7CmVzYWMKCiMgVW5kZXIg
  c29tZSBjaXJjdW1zdGFuY2VzIGxpYmRiIGNhbiBnZXQgYnVpbHQgaW4gc3VjaCBhIHdheSBhcyB0
  bwojIG5lZWQgcHRocmVhZCBleHBsaWNpdGx5IGxpbmtlZC4KCmxpYmRiX25lZWRzX3B0aHJlYWQ9
  Ik4iCgppZiBlY2hvICIgJGxpYnN3YW50ZWQgIiB8IGdyZXAgLXYgIiBwdGhyZWFkICIgPi9kZXYv
  bnVsbAp0aGVuCiAgIGlmIGVjaG8gIiAkbGlic3dhbnRlZCAiIHwgZ3JlcCAiIGRiICIgPi9kZXYv
  bnVsbAogICB0aGVuCiAgICAgZm9yIERCRElSIGluICRnbGlicHRoCiAgICAgZG8KICAgICAgIERC
  TElCPSIkREJESVIvbGliZGIuc28iCiAgICAgICBpZiBbIC1mICREQkxJQiBdCiAgICAgICB0aGVu
  CiAgICAgICAgIGlmIG5tIC11ICREQkxJQiB8IGdyZXAgcHRocmVhZCA+L2Rldi9udWxsCiAgICAg
  ICAgIHRoZW4KICAgICAgICAgICBpZiBsZGQgJERCTElCIHwgZ3JlcCBwdGhyZWFkID4vZGV2L251
  bGwKICAgICAgICAgICB0aGVuCiAgICAgICAgICAgICBsaWJkYl9uZWVkc19wdGhyZWFkPSJOIgog
  ICAgICAgICAgIGVsc2UKICAgICAgICAgICAgIGxpYmRiX25lZWRzX3B0aHJlYWQ9IlkiCiAgICAg
  ICAgICAgZmkKICAgICAgICAgZmkKICAgICAgIGZpCiAgICAgZG9uZQogICBmaQpmaQoKY2FzZSAi
  JGxpYmRiX25lZWRzX3B0aHJlYWQiIGluCiAgIlkiKQogICAgbGlic3dhbnRlZD0iJGxpYnN3YW50
  ZWQgcHRocmVhZCIKICAgIDs7CmVzYWMK==',
  );
  
  my %files = (
    'freebsd' => 'freebsd.sh',
    'netbsd'  => 'netbsd.sh',
    'openbsd' => 'openbsd.sh',
    'linux'   => 'linux.sh',
  );
  
  sub hint_file {
    my $os = shift;
    $os = shift if eval { $os->isa(__PACKAGE__) };
    $os = $^O unless $os;
    return unless defined $hints{ $os };
    my $content = decode_base64( $hints{ $os } );
    return $content unless wantarray;
    return ( $files{ $os }, $content );
  }
  
  qq'nudge nudge wink wink';
  
  
  __END__
  =pod
  
  =head1 NAME
  
  Devel::PatchPerl::Hints - replacement 'hints' files
  
  =head1 VERSION
  
  version 0.36
  
  =head1 SYNOPSIS
  
    use Devel::PatchPerl::Hints;
  
    if ( my $content = Devel::PatchPerl::Hints->hint_file() ) {
      chmod 0755, 'hints/netbsd.sh' or die "$!";
      open my $hints, '>', 'hints/netbsd.sh' or die "$!";
      print $hints $content;
      close $hints;
    }
  
  =head1 DESCRIPTION
  
  Sometimes there is a problem with Perls C<hints> file for a particular
  perl port. This module provides fixed C<hints> files encoded using
  C<MIME::Base64>.
  
  =head1 FUNCTION
  
  The function is exported, but has to implicitly imported into the
  requesting package.
  
    use Devel::PatchPerl::Hints qw[hint_file];
  
  It may also be called as a class method:
  
    use Devel::PatchPerl::Hints;
  
    my $content = Devel::PatchPerl::Hints->hint_file();
  
  =over
  
  =item C<hint_file>
  
  Takes an optional argument which is the OS name ( as would be returned by C<$^O> ).
  By default it will use C<$^O>.
  
  In a scalar context, Will return the decoded content of the C<hints> file suitable for writing straight to a
  file handle or undef list if there isn't an applicable C<hints> file for the given or derived
  OS.
  
  If called in a list context, will return a list, the first item will be the name of the C<hints> file that
  will need to be amended, the second item will be a string with the decoded content of the C<hints> file suitable
  for writing straight to a file handle. Otherwise an empty list will be returned.
  
  =back
  
  =head1 AUTHOR
  
  Chris Williams <chris@bingosnet.co.uk>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Chris Williams and Marcus Holland-Moritz.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
DEVEL_PATCHPERL_HINTS

$fatpacked{"File/pushd.pm"} = <<'FILE_PUSHD';
  package File::pushd;
  
  $VERSION = '1.00';
  @EXPORT  = qw( pushd tempd );
  @ISA     = qw( Exporter );
  
  use 5.004;
  use strict;
  #use warnings;
  use Exporter;
  use Carp;
  use Cwd         qw( cwd abs_path );
  use File::Path  qw( rmtree );
  use File::Temp  qw();
  use File::Spec;
  
  use overload 
      q{""} => sub { File::Spec->canonpath( $_[0]->{_pushd} ) },
      fallback => 1;
  
  #--------------------------------------------------------------------------#
  # pushd()
  #--------------------------------------------------------------------------#
  
  sub pushd {
      my ($target_dir) = @_;
      
      my $orig = cwd;
      
      my $dest;
      eval { $dest   = $target_dir ? abs_path( $target_dir ) : $orig };
      
      croak "Can't locate directory $target_dir: $@" if $@;
      
      if ($dest ne $orig) { 
          chdir $dest or croak "Can't chdir to $dest\: $!";
      }
  
      my $self = bless { 
          _pushd => $dest,
          _original => $orig
      }, __PACKAGE__;
  
      return $self;
  }
  
  #--------------------------------------------------------------------------#
  # tempd()
  #--------------------------------------------------------------------------#
  
  sub tempd {
      my $dir = pushd( File::Temp::tempdir( CLEANUP => 0 ) );
      $dir->{_tempd} = 1;
      return $dir;
  }
  
  #--------------------------------------------------------------------------#
  # preserve()
  #--------------------------------------------------------------------------#
  
  sub preserve {
      my $self = shift;
      return 1 if ! $self->{"_tempd"};
      if ( @_ == 0 ) {
          return $self->{_preserve} = 1;
      }
      else {
          return $self->{_preserve} = $_[0] ? 1 : 0;
      }
  }
      
  #--------------------------------------------------------------------------#
  # DESTROY()
  # Revert to original directory as object is destroyed and cleanup
  # if necessary
  #--------------------------------------------------------------------------#
  
  sub DESTROY {
      my ($self) = @_;
      my $orig = $self->{_original};
      chdir $orig if $orig; # should always be so, but just in case...
      if ( $self->{_tempd} && 
          !$self->{_preserve} ) {
          eval { rmtree( $self->{_pushd} ) };
          carp $@ if $@;
      }
  }
  
  1; #this line is important and will help the module return a true value
  __END__
  
  =begin wikidoc
  
  = NAME
  
  File::pushd - change directory temporarily for a limited scope
  
  = VERSION
  
  This documentation describes version %%VERSION%%.
  
  = SYNOPSIS
  
   use File::pushd;
  
   chdir $ENV{HOME};
   
   # change directory again for a limited scope
   {
       my $dir = pushd( '/tmp' );
       # working directory changed to /tmp
   }
   # working directory has reverted to $ENV{HOME}
  
   # tempd() is equivalent to pushd( File::Temp::tempdir )
   {
       my $dir = tempd();
   }
  
   # object stringifies naturally as an absolute path
   {
      my $dir = pushd( '/tmp' );
      my $filename = File::Spec->catfile( $dir, "somefile.txt" );
      # gives /tmp/somefile.txt
   }
      
  = DESCRIPTION
  
  File::pushd does a temporary {chdir} that is easily and automatically
  reverted, similar to {pushd} in some Unix command shells.  It works by
  creating an object that caches the original working directory.  When the object
  is destroyed, the destructor calls {chdir} to revert to the original working
  directory.  By storing the object in a lexical variable with a limited scope,
  this happens automatically at the end of the scope.
  
  This is very handy when working with temporary directories for tasks like
  testing; a function is provided to streamline getting a temporary
  directory from [File::Temp].
  
  For convenience, the object stringifies as the canonical form of the absolute
  pathname of the directory entered.
  
  = USAGE
  
   use File::pushd;
  
  Using File::pushd automatically imports the {pushd} and {tempd} functions.
  
  == pushd
  
   {
       my $dir = pushd( $target_directory );
   }
  
  Caches the current working directory, calls {chdir} to change to the target
  directory, and returns a File::pushd object.  When the object is
  destroyed, the working directory reverts to the original directory.
  
  The provided target directory can be a relative or absolute path. If
  called with no arguments, it uses the current directory as its target and
  returns to the current directory when the object is destroyed.
  
  == tempd
  
   {
       my $dir = tempd();
   }
  
  This function is like {pushd} but automatically creates and calls {chdir} to
  a temporary directory created by [File::Temp]. Unlike normal [File::Temp]
  cleanup which happens at the end of the program, this temporary directory is
  removed when the object is destroyed. (But also see {preserve}.)  A warning
  will be issued if the directory cannot be removed.
  
  == preserve 
  
   {
       my $dir = tempd();
       $dir->preserve;      # mark to preserve at end of scope
       $dir->preserve(0);   # mark to delete at end of scope
   }
  
  Controls whether a temporary directory will be cleaned up when the object is
  destroyed.  With no arguments, {preserve} sets the directory to be preserved.
  With an argument, the directory will be preserved if the argument is true, or
  marked for cleanup if the argument is false.  Only {tempd} objects may be
  marked for cleanup.  (Target directories to {pushd} are always preserved.)
  {preserve} returns true if the directory will be preserved, and false
  otherwise.
  
  = SEE ALSO
  
  * [File::chdir]
  
  = BUGS
  
  Please report any bugs or feature using the CPAN Request Tracker.  
  Bugs can be submitted through the web interface at 
  [http://rt.cpan.org/Dist/Display.html?Queue=File-pushd]
  
  When submitting a bug or request, please include a test-file or a patch to an
  existing test-file that illustrates the bug or desired feature.
  
  = AUTHOR
  
  David A. Golden (DAGOLDEN)
  
  = COPYRIGHT AND LICENSE
  
  Copyright (c) 2005, 2006, 2007 by David A. Golden
  
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at 
  [http://www.apache.org/licenses/LICENSE-2.0]
  
  Files produced as output though the use of this software, including
  generated copies of boilerplate templates provided with this software,
  shall not be considered Derivative Works, but shall be considered the
  original work of the Licensor.
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  
  =end wikidoc
  
FILE_PUSHD

$fatpacked{"Locale/Maketext/Extract.pm"} = <<'LOCALE_MAKETEXT_EXTRACT';
  package Locale::Maketext::Extract;
  $Locale::Maketext::Extract::VERSION = '0.38';
  
  use strict;
  use Locale::Maketext::Lexicon();
  
  =head1 NAME
  
  Locale::Maketext::Extract - Extract translatable strings from source
  
  =head1 SYNOPSIS
  
      my $Ext = Locale::Maketext::Extract->new;
      $Ext->read_po('messages.po');
      $Ext->extract_file($_) for <*.pl>;
  
      # Set $entries_are_in_gettext_format if the .pl files above use
      # loc('%1') instead of loc('[_1]')
      $Ext->compile($entries_are_in_gettext_format);
  
      $Ext->write_po('messages.po');
  
      -----------------------------------
  
      ### Specifying parser plugins ###
  
      my $Ext = Locale::Maketext::Extract->new(
  
          # Specify which parser plugins to use
          plugins => {
  
              # Use Perl parser, process files with extension .pl .pm .cgi
              perl => [],
  
              # Use YAML parser, process all files
              yaml => ['*'],
  
              # Use TT2 parser, process files with extension .tt2 .tt .html
              # or which match the regex
              tt2  => [
                  'tt2',
                  'tt',
                  'html',
                  qr/\.tt2?\./
              ],
  
              # Use My::Module as a parser for all files
              'My::Module' => ['*'],
  
          },
  
          # Warn if a parser can't process a file
          warnings => 1,
  
          # List processed files
          verbose => 1,
  
      );
  
  
  
  =head1 DESCRIPTION
  
  This module can extract translatable strings from files, and write
  them back to PO files.  It can also parse existing PO files and merge
  their contents with newly extracted strings.
  
  A command-line utility, L<xgettext.pl>, is installed with this module
  as well.
  
  The format parsers are loaded as plugins, so it is possible to define
  your own parsers.
  
  Following formats of input files are supported:
  
  =over 4
  
  =item Perl source files  (plugin: perl)
  
  Valid localization function names are: C<translate>, C<maketext>,
  C<gettext>, C<loc>, C<x>, C<_> and C<__>.
  
  For a slightly more accurate, but much slower Perl parser, you can  use the PPI
  plugin. This does not have a short name (like C<perl>), but must be specified
  in full.
  
  =item HTML::Mason  (plugin: mason)
  
  Strings inside C<E<lt>&|/lE<gt>I<...>E<lt>/&E<gt>> and
  C<E<lt>&|/locE<gt>I<...>E<lt>/&E<gt>> are extracted.
  
  =item Template Toolkit (plugin: tt2)
  
  Valid forms are:
  
    [% | l(arg1,argn) %]string[% END %]
    [% 'string' | l(arg1,argn) %]
    [% l('string',arg1,argn) %]
  
    FILTER and | are interchangeable
    l and loc are interchangeable
    args are optional
  
  =item Text::Template (plugin: text)
  
  Sentences between C<STARTxxx> and C<ENDxxx> are extracted individually.
  
  =item YAML (plugin: yaml)
  
  Valid forms are _"string" or _'string', eg:
  
      title: _"My title"
      desc:  _'My "quoted" string'
  
  Quotes do not have to be escaped, so you could also do:
  
      desc:  _"My "quoted" string"
  
  =item HTML::FormFu (plugin: formfu)
  
  HTML::FormFu uses a config-file to generate forms, with built in
  support for localizing errors, labels etc.
  
  We extract the text after C<_loc: >:
      content_loc: this is the string
      message_loc: ['Max string length: [_1]', 10]
  
  =item Generic Template (plugin: generic)
  
  Strings inside {{...}} are extracted.
  
  =back
  
  =head1 METHODS
  
  =head2 Constructor
  
      new()
  
      new(
          plugins   => {...},
          warnings  => 1 | 0,
          verbose   => 0 | 1 | 2 | 3,
      )
  
  See L</"Plugins">, L</"Warnings"> and L</"Verbose"> for details
  
  =head2 Plugins
  
      $ext->plugins({...});
  
  Locale::Maketext::Extract uses plugins (see below for the list)
  to parse different formats.
  
  Each plugin can also specify which file types it can parse.
  
      # use only the YAML plugin
      # only parse files with the default extension list defined in the plugin
      # ie .yaml .yml .conf
  
      $ext->plugins({
          yaml => [],
      })
  
  
      # use only the Perl plugin
      # parse all file types
  
      $ext->plugins({
          perl => '*'
      })
  
      $ext->plugins({
          tt2  => [
              'tt',              # matches base filename against /\.tt$/
              qr/\.tt2?\./,      # matches base filename against regex
              \&my_filter,       # codref called
          ]
      })
  
      sub my_filter {
          my ($base_filename,$path_to_file) = @_;
  
          return 1 | 0;
      }
  
      # Specify your own parser
      # only parse files with the default extension list defined in the plugin
  
      $ext->plugins({
          'My::Extract::Parser'  => []
      })
  
  
  By default, if no plugins are specified, then it uses all of the builtin
  plugins, and overrides the file types specified in each plugin
   - instead, each plugin is tried for every file.
  
  =head3 Available plugins
  
  =over 4
  
  =item C<perl>    : L<Locale::Maketext::Extract::Plugin::Perl>
  
  For a slightly more accurate but much slower Perl parser, you can use
  the PPI plugin. This does not have a short name, but must be specified in
  full, ie: L<Locale::Maketext::Extract::Plugin::PPI>
  
  =item C<tt2>     : L<Locale::Maketext::Extract::Plugin::TT2>
  
  =item C<yaml>    : L<Locale::Maketext::Extract::Plugin::YAML>
  
  =item C<formfu>  : L<Locale::Maketext::Extract::Plugin::FormFu>
  
  =item C<mason>   : L<Locale::Maketext::Extract::Plugin::Mason>
  
  =item C<text>    : L<Locale::Maketext::Extract::Plugin::TextTemplate>
  
  =item C<generic> : L<Locale::Maketext::Extract::Plugin::Generic>
  
  =back
  
  Also, see L<Locale::Maketext::Extract::Plugin::Base> for details of how to
  write your own plugin.
  
  =head2 Warnings
  
  Because the YAML and TT2 plugins use proper parsers, rather than just regexes,
  if a source file is not valid and it is unable to parse the file, then the
  parser will throw an error and abort parsing.
  
  The next enabled plugin will be tried.
  
  By default, you will not see these errors.  If you would like to see them,
  then enable warnings via new(). All parse errors will be printed to STDERR.
  
  =head2 Verbose
  
  If you would like to see which files have been processed, which plugins were
  used, and which strings were extracted, then enable C<verbose>. If no
  acceptable plugin was found, or no strings were extracted, then the file
  is not listed:
  
        $ext = Locale::Extract->new( verbose => 1 | 2 | 3);
  
     OR
        xgettext.pl ... -v           # files reported
        xgettext.pl ... -v -v        # files and plugins reported
        xgettext.pl ... -v -v -v     # files, plugins and strings reported
  
  =cut
  
  our %Known_Plugins = (
                      perl => 'Locale::Maketext::Extract::Plugin::Perl',
                      yaml => 'Locale::Maketext::Extract::Plugin::YAML',
                      tt2  => 'Locale::Maketext::Extract::Plugin::TT2',
                      text => 'Locale::Maketext::Extract::Plugin::TextTemplate',
                      mason   => 'Locale::Maketext::Extract::Plugin::Mason',
                      generic => 'Locale::Maketext::Extract::Plugin::Generic',
                      formfu  => 'Locale::Maketext::Extract::Plugin::FormFu',
  );
  
  sub new {
      my $class   = shift;
      my %params  = @_;
      my $plugins = delete $params{plugins}
          || { map { $_ => '*' } keys %Known_Plugins };
  
      Locale::Maketext::Lexicon::set_option( 'keep_fuzzy' => 1 );
      my $self = bless( {  header           => '',
                           entries          => {},
                           compiled_entries => {},
                           lexicon          => {},
                           warnings         => 0,
                           verbose          => 0,
                           wrap             => 0,
                           %params,
                        },
                        $class
      );
      $self->{verbose} ||= 0;
      die "No plugins defined in new()"
          unless $plugins;
      $self->plugins($plugins);
      return $self;
  }
  
  =head2 Accessors
  
      header, set_header
      lexicon, set_lexicon, msgstr, set_msgstr
      entries, set_entries, entry, add_entry, del_entry
      compiled_entries, set_compiled_entries, compiled_entry,
      add_compiled_entry, del_compiled_entry
      clear
  
  =cut
  
  sub header { $_[0]{header} || _default_header() }
  sub set_header { $_[0]{header} = $_[1] }
  
  sub lexicon { $_[0]{lexicon} }
  sub set_lexicon { $_[0]{lexicon} = $_[1] || {}; delete $_[0]{lexicon}{''}; }
  
  sub msgstr { $_[0]{lexicon}{ $_[1] } }
  sub set_msgstr { $_[0]{lexicon}{ $_[1] } = $_[2] }
  
  sub entries { $_[0]{entries} }
  sub set_entries { $_[0]{entries} = $_[1] || {} }
  
  sub compiled_entries { $_[0]{compiled_entries} }
  sub set_compiled_entries { $_[0]{compiled_entries} = $_[1] || {} }
  
  sub entry { @{ $_[0]->entries->{ $_[1] } || [] } }
  sub add_entry { push @{ $_[0]->entries->{ $_[1] } }, $_[2] }
  sub del_entry { delete $_[0]->entries->{ $_[1] } }
  
  sub compiled_entry { @{ $_[0]->compiled_entries->{ $_[1] } || [] } }
  sub add_compiled_entry { push @{ $_[0]->compiled_entries->{ $_[1] } }, $_[2] }
  sub del_compiled_entry { delete $_[0]->compiled_entries->{ $_[1] } }
  
  sub plugins {
      my $self = shift;
      if (@_) {
          my @plugins;
          my %params = %{ shift @_ };
  
          foreach my $name ( keys %params ) {
              my $plugin_class = $Known_Plugins{$name} || $name;
              my $filename = $plugin_class . '.pm';
              $filename =~ s/::/\//g;
              local $@;
              eval {
                  require $filename && 1;
                  1;
              } or next;
              push @plugins, $plugin_class->new( $params{$name} );
          }
          $self->{plugins} = \@plugins;
      }
      return $self->{plugins} || [];
  }
  
  sub clear {
      $_[0]->set_header;
      $_[0]->set_lexicon;
      $_[0]->set_comments;
      $_[0]->set_fuzzy;
      $_[0]->set_entries;
      $_[0]->set_compiled_entries;
  }
  
  =head2 PO File manipulation
  
  =head3 method read_po ($file)
  
  =cut
  
  sub read_po {
      my ( $self, $file ) = @_;
      print STDERR "READING PO FILE : $file\n"
          if $self->{verbose};
  
      my $header = '';
  
      local ( *LEXICON, $_ );
      open LEXICON, $file or die $!;
      while (<LEXICON>) {
          ( 1 .. /^$/ ) or last;
          $header .= $_;
      }
      1 while chomp $header;
  
      $self->set_header("$header\n");
  
      require Locale::Maketext::Lexicon::Gettext;
      my $lexicon  = {};
      my $comments = {};
      my $fuzzy    = {};
      $self->set_compiled_entries( {} );
  
      if ( defined($_) ) {
          ( $lexicon, $comments, $fuzzy )
              = Locale::Maketext::Lexicon::Gettext->parse( $_, <LEXICON> );
      }
  
      # Internally the lexicon is in gettext format already.
      $self->set_lexicon( { map _maketext_to_gettext($_), %$lexicon } );
      $self->set_comments($comments);
      $self->set_fuzzy($fuzzy);
  
      close LEXICON;
  }
  
  sub msg_comment {
      my $self    = shift;
      my $msgid   = shift;
      my $comment = $self->{comments}->{$msgid};
      return $comment;
  }
  
  sub msg_fuzzy {
      return $_[0]->{fuzzy}{$_[1]} ? ', fuzzy' : '';
  }
  
  sub set_comments {
      $_[0]->{comments} = $_[1];
  }
  
  sub set_fuzzy {
      $_[0]->{fuzzy} = $_[1];
  }
  
  =head3 method write_po ($file, $add_format_marker?)
  
  =cut
  
  sub write_po {
      my ( $self, $file, $add_format_marker ) = @_;
      print STDERR "WRITING PO FILE : $file\n"
          if $self->{verbose};
  
      local *LEXICON;
      open LEXICON, ">$file" or die "Can't write to $file$!\n";
  
      print LEXICON $self->header;
  
      foreach my $msgid ( $self->msgids ) {
          $self->normalize_space($msgid);
          print LEXICON "\n";
          if ( my $comment = $self->msg_comment($msgid) ) {
              my @lines = split "\n", $comment;
              print LEXICON map {"# $_\n"} @lines;
          }
          print LEXICON $self->msg_variables($msgid);
          print LEXICON $self->msg_positions($msgid);
          my $flags = $self->msg_fuzzy($msgid);
          $flags.= $self->msg_format($msgid) if $add_format_marker;
          print LEXICON "#$flags\n" if $flags;
          print LEXICON $self->msg_out($msgid);
      }
  
      print STDERR "DONE\n\n"
          if $self->{verbose};
  
  }
  
  =head2 Extraction
  
      extract
      extract_file
  
  =cut
  
  sub extract {
      my $self    = shift;
      my $file    = shift;
      my $content = shift;
  
      local $@;
  
      my ( @messages, $total, $error_found );
      $total = 0;
      my $verbose = $self->{verbose};
      foreach my $plugin ( @{ $self->plugins } ) {
          if ( $plugin->known_file_type($file) ) {
              pos($content) = 0;
              my $success = eval { $plugin->extract($content); 1; };
              if ($success) {
                  my $entries = $plugin->entries;
                  if ( $verbose > 1 && @$entries ) {
                      push @messages,
                            "     - "
                          . ref($plugin)
                          . ' - Strings extracted : '
                          . ( scalar @$entries );
                  }
                  for my $entry (@$entries) {
                      my ( $string, $line, $vars ) = @$entry;
                      $self->add_entry( $string => [ $file, $line, $vars ] );
                      if ( $verbose > 2 ) {
                          $vars = '' if !defined $vars;
  
                          # pad string
                          $string =~ s/\n/\n               /g;
                          push @messages,
                              sprintf( qq[       - %-8s "%s" (%s)],
                                       $line . ':',
                                       $string, $vars
                              ),
                              ;
                      }
                  }
                  $total += @$entries;
              }
              else {
                  $error_found++;
                  if ( $self->{warnings} ) {
                      push @messages,
                            "Error parsing '$file' with plugin "
                          . ( ref $plugin )
                          . ": \n $@\n";
                  }
              }
              $plugin->clear;
          }
      }
  
      print STDERR " * $file\n   - Total strings extracted : $total"
          . ( $error_found ? ' [ERROR ] ' : '' ) . "\n"
          if $verbose
              && ( $total || $error_found );
      print STDERR join( "\n", @messages ) . "\n"
          if @messages;
  
  }
  
  sub extract_file {
      my ( $self, $file ) = @_;
  
      local ( $/, *FH );
      open FH, $file or die "Error reading from file '$file' : $!";
      my $content = scalar <FH>;
  
      $self->extract( $file => $content );
      close FH;
  }
  
  =head2 Compilation
  
  =head3 compile($entries_are_in_gettext_style?)
  
  Merges the C<entries> into C<compiled_entries>.
  
  If C<$entries_are_in_gettext_style> is true, the previously extracted entries
  are assumed to be in the B<Gettext> style (e.g. C<%1>).
  
  Otherwise they are assumed to be in B<Maketext> style (e.g. C<[_1]>) and are
  converted into B<Gettext> style before merging into C<compiled_entries>.
  
  The C<entries> are I<not> cleared after each compilation; use
  C<->set_entries()> to clear them if you need to extract from sources with
  varying styles.
  
  =cut
  
  sub compile {
      my ( $self, $entries_are_in_gettext_style ) = @_;
      my $entries = $self->entries;
      my $lexicon = $self->lexicon;
      my $comp    = $self->compiled_entries;
  
      while ( my ( $k, $v ) = each %$entries ) {
          my $compiled_key = ( ($entries_are_in_gettext_style)
                               ? $k
                               : _maketext_to_gettext($k)
          );
          $comp->{$compiled_key}    = $v;
          $lexicon->{$compiled_key} = ''
              unless exists $lexicon->{$compiled_key};
      }
  
      return %$lexicon;
  }
  
  =head3 normalize_space
  
  =cut
  
  my %Escapes = map { ( "\\$_" => eval("qq(\\$_)") ) } qw(t r f b a e);
  
  sub normalize_space {
      my ( $self, $msgid ) = @_;
      my $nospace = $msgid;
      $nospace =~ s/ +$//;
  
      return
          unless ( !$self->has_msgid($msgid) and $self->has_msgid($nospace) );
  
      $self->set_msgstr( $msgid => $self->msgstr($nospace)
                         . ( ' ' x ( length($msgid) - length($nospace) ) ) );
  }
  
  =head2 Lexicon accessors
  
      msgids, has_msgid,
      msgstr, set_msgstr
      msg_positions, msg_variables, msg_format, msg_out
  
  =cut
  
  sub msgids    { sort keys %{ $_[0]{lexicon} } }
  sub has_msgid {
      my $msg_str = $_[0]->msgstr( $_[1] );
      return defined $msg_str ? length $msg_str : 0;
  }
  
  sub msg_positions {
      my ( $self, $msgid ) = @_;
      my %files = ( map { ( " $_->[0]:$_->[1]" => 1 ) }
                    $self->compiled_entry($msgid) );
      return $self->{wrap}
          ? join( "\n", ( map { '#:' . $_ } sort( keys %files ) ), '' )
          : join( '', '#:', sort( keys %files ), "\n" );
  }
  
  sub msg_variables {
      my ( $self, $msgid ) = @_;
      my $out = '';
  
      my %seen;
      foreach my $entry ( grep { $_->[2] } $self->compiled_entry($msgid) ) {
          my ( $file, $line, $var ) = @$entry;
          $var =~ s/^\s*,\s*//;
          $var =~ s/\s*$//;
          $out .= "#. ($var)\n" unless !length($var) or $seen{$var}++;
      }
  
      return $out;
  }
  
  sub msg_format {
      my ( $self, $msgid ) = @_;
      return ", perl-maketext-format"
          if $msgid =~ /%(?:[1-9]\d*|\w+\([^\)]*\))/;
      return '';
  }
  
  sub msg_out {
      my ( $self, $msgid ) = @_;
      my $msgstr = $self->msgstr($msgid);
  
      return "msgid " . _format($msgid) . "msgstr " . _format($msgstr);
  }
  
  =head2 Internal utilities
  
      _default_header
      _maketext_to_gettext
      _escape
      _format
  
  =cut
  
  sub _default_header {
      return << '.';
  # SOME DESCRIPTIVE TITLE.
  # Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
  # This file is distributed under the same license as the PACKAGE package.
  # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
  #
  #, fuzzy
  msgid ""
  msgstr ""
  "Project-Id-Version: PACKAGE VERSION\n"
  "POT-Creation-Date: YEAR-MO-DA HO:MI+ZONE\n"
  "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
  "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
  "Language-Team: LANGUAGE <LL@li.org>\n"
  "MIME-Version: 1.0\n"
  "Content-Type: text/plain; charset=CHARSET\n"
  "Content-Transfer-Encoding: 8bit\n"
  .
  }
  
  sub _maketext_to_gettext {
      my $text = shift;
      return '' unless defined $text;
  
      $text =~ s{((?<!~)(?:~~)*)\[_([1-9]\d*|\*)\]}
                {$1%$2}g;
      $text =~ s{((?<!~)(?:~~)*)\[([A-Za-z#*]\w*),([^\]]+)\]}
                {"$1%$2(" . _escape($3) . ')'}eg;
  
      $text =~ s/~([\~\[\]])/$1/g;
      return $text;
  }
  
  sub _escape {
      my $text = shift;
      $text =~ s/\b_([1-9]\d*)/%$1/g;
      return $text;
  }
  
  sub _format {
      my $str = shift;
  
      $str =~ s/(?=[\\"])/\\/g;
  
      while ( my ( $char, $esc ) = each %Escapes ) {
          $str =~ s/$esc/$char/g;
      }
  
      return "\"$str\"\n" unless $str =~ /\n/;
      my $multi_line = ( $str =~ /\n(?!\z)/ );
      $str =~ s/\n/\\n"\n"/g;
      if ( $str =~ /\n"$/ ) {
          chop $str;
      }
      else {
          $str .= "\"\n";
      }
      return $multi_line ? qq(""\n"$str) : qq("$str);
  }
  
  1;
  
  =head1 ACKNOWLEDGMENTS
  
  Thanks to Jesse Vincent for contributing to an early version of this
  module.
  
  Also to Alain Barbet, who effectively re-wrote the source parser with a
  flex-like algorithm.
  
  =head1 SEE ALSO
  
  L<xgettext.pl>, L<Locale::Maketext>, L<Locale::Maketext::Lexicon>
  
  =head1 AUTHORS
  
  Audrey Tang E<lt>cpan@audreyt.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2003-2008 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
LOCALE_MAKETEXT_EXTRACT

$fatpacked{"Locale/Maketext/Extract/Plugin/Base.pm"} = <<'LOCALE_MAKETEXT_EXTRACT_PLUGIN_BASE';
  package Locale::Maketext::Extract::Plugin::Base;
  
  use strict;
  
  use File::Basename qw(fileparse);
  
  =head1 NAME
  
  Locale::Maketext::Extract::Plugin::Base - Base module for format parser plugins
  
  =head1 SYNOPSIS
  
      package My::Parser::Plugin;
      use base qw(Locale::Maketext::Extract::Plugin::Base);
  
      sub file_types {
          return [qw( ext ext2 )]
      }
  
      sub extract {
          my $self = shift;
          my $filename = shift;
          local $_ = shift;
  
          my $line = 1;
  
          while (my $found = $self->routine_to_extract_strings) {
              $self->add_entry($str,[$filename,$line,$vars])
          }
  
          return;
      }
  
  =head1 DESCRIPTION
  
  All format parser plugins in Locale::Maketext::Extract inherit from
  Locale::Maketext::Extract::Plugin::Base.
  
  If you want to write your own custom parser plugin, you will need to inherit
  from this module, and provide C<file_types()> and C<extract()> methods,
  as shown above.
  
  =head1 METHODS
  
  =over 4
  
  =item new()
  
      $plugin = My::Parser->new(
          @file_types         # Optionally specify a list of recognised file types
      )
  
  =cut
  
  sub new {
      my $class = shift;
      my $self = bless {
          entries => [],
      }, $class;
  
      $self->_compile_file_types(@_);
      return $self;
  }
  
  =item add_entry()
  
      $plugin->add_entry($str,$line,$vars)
  
  =cut
  
  sub add_entry {
      my $self = shift;
      push @{$self->{entries}},[@_];
  }
  
  =item C<entries()>
  
      $entries = $plugin->entries;
  
  =cut
  
  #===================================
  sub entries {
  #===================================
      my $self = shift;
      return $self->{entries};
  }
  
  =item C<clear()>
  
      $plugin->clear
  
  Clears all stored entries.
  
  =cut
  
  #===================================
  sub clear {
  #===================================
      my $self = shift;
      $self->{entries}=[];
  }
  
  =item file_types()
  
      @default_file_types = $plugin->file_types
  
  Returns a list of recognised file types that your module knows how to parse.
  
  Each file type can be one of:
  
  =over 4
  
  =item * A plain string
  
     'pl'  => base filename is matched against qr/\.pl$/
     '*'   => all files are accepted
  
  =item * A regex
  
     qr/\.tt2?\./ => base filename is matched against this regex
  
  =item * A codref
  
      sub {}  => this codref is called as $coderef->($base_filename,$path_to_file)
                 It should return true or false
  
  =back
  
  =cut
  
  sub file_types {
      die "Please override sub file_types() to return "
          . "a list of recognised file extensions, or regexes";
  }
  
  =item extract()
  
      $plugin->extract($filecontents);
  
  extract() is the method that will be called to process the contents of the
  current file.
  
  When it finds a string that should be extracted, it should call
  
     $self->add_entry($string,$line,$vars])
  
  where C<$vars> refers to any arguments that are being passed to the localise
  function. For instance:
  
     l("You found [quant,_1,file,files]",files_found)
  
       string: "You found [quant,_1,file,files]"
       vars  : (files_found)
  
  IMPORTANT: a single plugin instance is used for all files, so if you plan
  on storing state information in the C<$plugin> object, this should be cleared
  out at the beginning of C<extract()>
  
  =cut
  
  sub extract {
      die "Please override sub extract()";
  }
  
  sub _compile_file_types {
      my $self = shift;
      my @file_types
          = ref $_[0] eq 'ARRAY'
              ? @{ shift @_ }
              : @_;
      @file_types = $self->file_types
          unless @file_types;
  
      my @checks;
      if ( grep { $_ eq '*' } @file_types ) {
          $self->{file_checks} = [ sub {1} ];
          return;
      }
      foreach my $type (@file_types) {
          if ( ref $type eq 'CODE' ) {
              push @checks, $type;
              next;
          }
          else {
              my $regex
                  = ref $type
                  ? $type
                  : qr/^.*\.\Q$type\E$/;
              push @checks, sub { $_[0] =~ m/$regex/ };
          }
      }
      $self->{file_checks} = \@checks;
  }
  
  =item known_file_type()
  
      if ($plugin->known_file_type($filename_with_path)) {
          ....
      }
  
  Determines whether the current file should be handled by this parser, based
  either on the list of file_types specified when this object was created,
  or the default file_types specified in the module.
  
  =cut
  
  sub known_file_type {
      my $self = shift;
      my ( $name, $path ) = fileparse( shift @_ );
      foreach my $check ( @{ $self->{file_checks} } ) {
          return 1 if $check->( $name, $path );
      }
      return 0;
  }
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<xgettext.pl>
  
  for extracting translatable strings from common template
  systems and perl source files.
  
  =item L<Locale::Maketext::Lexicon>
  
  =item L<Locale::Maketext::Extract::Plugin::Perl>
  
  =item L<Locale::Maketext::Extract::Plugin::PPI>
  
  =item L<Locale::Maketext::Extract::Plugin::TT2>
  
  =item L<Locale::Maketext::Extract::Plugin::YAML>
  
  =item L<Locale::Maketext::Extract::Plugin::FormFu>
  
  =item L<Locale::Maketext::Extract::Plugin::Mason>
  
  =item L<Locale::Maketext::Extract::Plugin::TextTemplate>
  
  =item L<Locale::Maketext::Extract::Plugin::Generic>
  
  =back
  
  =head1 AUTHORS
  
  Clinton Gormley [DRTECH] E<lt>clinton@traveljury.comE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2002-2008 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
  
  1;
LOCALE_MAKETEXT_EXTRACT_PLUGIN_BASE

$fatpacked{"Locale/Maketext/Extract/Plugin/FormFu.pm"} = <<'LOCALE_MAKETEXT_EXTRACT_PLUGIN_FORMFU';
  package Locale::Maketext::Extract::Plugin::FormFu;
  
  use strict;
  use base qw(Locale::Maketext::Extract::Plugin::Base);
  
  =head1 NAME
  
  Locale::Maketext::Extract::Plugin::FormFu - FormFu format parser
  
  =head1 SYNOPSIS
  
      $plugin = Locale::Maketext::Extract::Plugin::FormFu->new(
          $lexicon            # A Locale::Maketext::Extract object
          @file_types         # Optionally specify a list of recognised file types
      )
  
      $plugin->extract($filename,$filecontents);
  
  =head1 DESCRIPTION
  
  HTML::FormFu uses a config-file to generate forms, with built in support
  for localizing errors, labels etc.
  
  =head1 SHORT PLUGIN NAME
  
      formfu
  
  =head1 VALID FORMATS
  
  We extract the text after any key which ends in C<_loc>:
  
      content_loc: this is the string
      message_loc: ['Max length [_1]', 10]
  
  =head1 KNOWN FILE TYPES
  
  =over 4
  
  =item .yaml
  
  =item .yml
  
  =item .conf
  
  =back
  
  =head1 REQUIRES
  
  L<YAML>
  
  =head1 NOTES
  
  The docs for the YAML module describes it as alpha code. It is not as tolerant
  of errors as L<YAML::Syck>. However, because it is pure Perl, it is easy
  to hook into.
  
  I have seen it enter endless loops, so if xgettext.pl hangs, try running it
  again with C<--verbose --verbose> (twice) enabled, so that you can see if
  the fault lies with YAML.  If it does, either correct the YAML source file,
  or use the file_types to exclude that file.
  
  =cut
  
  sub file_types {
      return qw( yaml yml conf );
  }
  
  sub extract {
      my $self = shift;
      my $data = shift;
  
      my $y = Locale::Maketext::Extract::Plugin::FormFu::Extractor->new();
      $y->load($data);
  
      foreach my $entry ( @{ $y->found } ) {
          $self->add_entry(@$entry);
      }
  
  }
  
  package Locale::Maketext::Extract::Plugin::FormFu::Extractor;
  
  use base qw(YAML::Loader);
  
  #===================================
  sub new {
  #===================================
      my $class = shift;
      my $self  = $class->SUPER::new(@_);
      $self->{found} = [];
      return $self;
  }
  
  #===================================
  sub _check_key {
  #===================================
      my $self = shift;
      my ( $key, $value, $line ) = @_;
      my ( $str, $vars );
      if ( ref $value ) {
          return if ref $value ne 'ARRAY';
          $str = shift @$value;
          $vars = join( ', ', @$value );
      }
      else {
          $str = $value;
      }
      return
          unless $key
              && $key =~ /_loc$/
              && defined $str;
      push @{ $self->{found} }, [ $str, $line, $vars ];
  }
  
  #===================================
  sub _parse_mapping {
  #===================================
      my $self     = shift;
      my ($anchor) = @_;
      my $mapping  = {};
      $self->anchor2node->{$anchor} = $mapping;
      my $key;
      while ( not $self->done
          and $self->indent == $self->offset->[ $self->level ] )
      {
  
          # If structured key:
          if ( $self->{content} =~ s/^\?\s*// ) {
              $self->preface( $self->content );
              $self->_parse_next_line(YAML::Loader::COLLECTION);
              $key = $self->_parse_node();
              $key = "$key";
          }
  
          # If "default" key (equals sign)
          elsif ( $self->{content} =~ s/^\=\s*// ) {
              $key = YAML::Loader::VALUE;
          }
  
          # If "comment" key (slash slash)
          elsif ( $self->{content} =~ s/^\=\s*// ) {
              $key = YAML::Loader::COMMENT;
          }
  
          # Regular scalar key:
          else {
              $self->inline( $self->content );
              $key = $self->_parse_inline();
              $key = "$key";
              $self->content( $self->inline );
              $self->inline('');
          }
  
          unless ( $self->{content} =~ s/^:\s*// ) {
              $self->die('YAML_LOAD_ERR_BAD_MAP_ELEMENT');
          }
          $self->preface( $self->content );
          my $line = $self->line;
          $self->_parse_next_line(YAML::Loader::COLLECTION);
          my $value = $self->_parse_node();
          if ( exists $mapping->{$key} ) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $mapping->{$key} = $value;
              $self->_check_key( $key, $value, $line );
          }
      }
      return $mapping;
  }
  
  #===================================
  sub _parse_inline_mapping {
  #===================================
      my $self       = shift;
      my ($anchor)   = @_;
      my $node       = {};
      my $start_line = $self->{_start_line};
  
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_MAP')
          unless $self->{inline} =~ s/^\{\s*//;
      while ( not $self->{inline} =~ s/^\s*\}// ) {
          my $key = $self->_parse_inline();
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
              unless $self->{inline} =~ s/^\: \s*//;
          my $value = $self->_parse_inline();
          if ( exists $node->{$key} ) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $node->{$key} = $value;
              $self->_check_key( $key, $value, $start_line );
          }
          next if $self->inline =~ /^\s*\}/;
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
              unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  #===================================
  sub _parse_next_line {
  #===================================
      my $self = shift;
      $self->{_start_line} = $self->line;
      $self->SUPER::_parse_next_line(@_);
  }
  
  #===================================
  sub found {
  #===================================
      my $self = shift;
      return $self->{found};
  }
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<xgettext.pl>
  
  for extracting translatable strings from common template
  systems and perl source files.
  
  =item L<YAML>
  
  =item L<HTML::FormFu>
  
  =item L<Locale::Maketext::Lexicon>
  
  =item L<Locale::Maketext::Extract::Plugin::Base>
  
  =item L<Locale::Maketext::Extract::Plugin::Perl>
  
  =item L<Locale::Maketext::Extract::Plugin::TT2>
  
  =item L<Locale::Maketext::Extract::Plugin::YAML>
  
  =item L<Locale::Maketext::Extract::Plugin::Mason>
  
  =item L<Locale::Maketext::Extract::Plugin::TextTemplate>
  
  =item L<Locale::Maketext::Extract::Plugin::Generic>
  
  =back
  
  =head1 AUTHORS
  
  Clinton Gormley E<lt>clint@traveljury.comE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2002-2008 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
  
  1;
LOCALE_MAKETEXT_EXTRACT_PLUGIN_FORMFU

$fatpacked{"Locale/Maketext/Extract/Plugin/Generic.pm"} = <<'LOCALE_MAKETEXT_EXTRACT_PLUGIN_GENERIC';
  package Locale::Maketext::Extract::Plugin::Generic;
  
  use strict;
  use base qw(Locale::Maketext::Extract::Plugin::Base);
  
  =head1 NAME
  
  Locale::Maketext::Extract::Plugin::Generic - Generic template parser
  
  =head1 SYNOPSIS
  
      $plugin = Locale::Maketext::Extract::Plugin::Generic->new(
          $lexicon            # A Locale::Maketext::Extract object
          @file_types         # Optionally specify a list of recognised file types
      )
  
      $plugin->extract($filename,$filecontents);
  
  =head1 DESCRIPTION
  
  Extracts strings to localise from generic templates.
  
  =head1 SHORT PLUGIN NAME
  
      generic
  
  =head1 VALID FORMATS
  
  Strings inside {{...}} are extracted.
  
  =head1 KNOWN FILE TYPES
  
  =over 4
  
  =item All file types
  
  =back
  
  =cut
  
  
  sub file_types {
      return qw( * );
  }
  
  sub extract {
      my $self = shift;
      local $_ = shift;
  
      my $line = 1;
  
      # Generic Template:
      $line = 1; pos($_) = 0;
      while (m/\G(.*?(?<!\{)\{\{(?!\{)(.*?)\}\})/sg) {
          my ($vars, $str) = ('', $2);
          $line += ( () = ($1 =~ /\n/g) ); # cryptocontext!
          $self->add_entry($str, $line, $vars );
      }
  
      my $quoted = '(\')([^\\\']*(?:\\.[^\\\']*)*)(\')|(\")([^\\\"]*(?:\\.[^\\\"]*)*)(\")';
  
      # Comment-based mark: "..." # loc
      $line = 1; pos($_) = 0;
      while (m/\G(.*?($quoted)[\}\)\],;]*\s*\#\s*loc\s*$)/smog) {
          my $str = substr($2, 1, -1);
          $line += ( () = ( $1 =~ /\n/g ) );    # cryptocontext!
          $str  =~ s/\\(["'])/$1/g;
          $self->add_entry($str, $line, '' );
      }
  
      # Comment-based pair mark: "..." => "..." # loc_pair
      $line = 1; pos($_) = 0;
      while (m/\G(.*?(\w+)\s*=>\s*($quoted)[\}\)\],;]*\s*\#\s*loc_pair\s*$)/smg) {
          my $key = $2;
          my $val = substr($3, 1, -1);
          $line += ( () = ( $1 =~ /\n/g ) );    # cryptocontext!
          $key  =~ s/\\(["'])/$1/g;
          $val  =~ s/\\(["'])/$1/g;
          $self->add_entry($val,  $line, '' );
      }
  }
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<xgettext.pl>
  
  for extracting translatable strings from common template
  systems and perl source files.
  
  =item L<Locale::Maketext::Lexicon>
  
  =item L<Locale::Maketext::Extract::Plugin::Base>
  
  =item L<Locale::Maketext::Extract::Plugin::FormFu>
  
  =item L<Locale::Maketext::Extract::Plugin::Perl>
  
  =item L<Locale::Maketext::Extract::Plugin::TT2>
  
  =item L<Locale::Maketext::Extract::Plugin::YAML>
  
  =item L<Locale::Maketext::Extract::Plugin::Mason>
  
  =item L<Locale::Maketext::Extract::Plugin::TextTemplate>
  
  =back
  
  =head1 AUTHORS
  
  Audrey Tang E<lt>cpan@audreyt.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2002-2008 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
  
  
  1;
LOCALE_MAKETEXT_EXTRACT_PLUGIN_GENERIC

$fatpacked{"Locale/Maketext/Extract/Plugin/Mason.pm"} = <<'LOCALE_MAKETEXT_EXTRACT_PLUGIN_MASON';
  package Locale::Maketext::Extract::Plugin::Mason;
  
  use strict;
  use base qw(Locale::Maketext::Extract::Plugin::Base);
  
  =head1 NAME
  
  Locale::Maketext::Extract::Plugin::Mason - Mason format parser
  
  =head1 SYNOPSIS
  
      $plugin = Locale::Maketext::Extract::Plugin::Mason->new(
          $lexicon            # A Locale::Maketext::Extract object
          @file_types         # Optionally specify a list of recognised file types
      )
  
      $plugin->extract($filename,$filecontents);
  
  =head1 DESCRIPTION
  
  Extracts strings to localise from Mason files.
  
  =head1 SHORT PLUGIN NAME
  
      mason
  
  =head1 VALID FORMATS
  
  Strings inside <&|/l>...</&> and <&|/loc>...</&> are extracted.
  
  =head1 KNOWN FILE TYPES
  
  =over 4
  
  =item All file types
  
  =back
  
  =cut
  
  sub file_types {
      return qw( * );
  }
  
  
  sub extract {
      my $self = shift;
      local $_ = shift;
  
      my $line = 1;
  
      # HTML::Mason
  
      while (m!\G(.*?<&\|/l(?:oc)?(.*?)&>(.*?)</&>)!sg) {
          my ($vars, $str) = ($2, $3);
          $line += ( () = ($1 =~ /\n/g) ); # cryptocontext!
          $self->add_entry($str,  $line, $vars );
      }
  
  }
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<xgettext.pl>
  
  for extracting translatable strings from common template
  systems and perl source files.
  
  =item L<Locale::Maketext::Lexicon>
  
  =item L<Locale::Maketext::Extract::Plugin::Base>
  
  =item L<Locale::Maketext::Extract::Plugin::FormFu>
  
  =item L<Locale::Maketext::Extract::Plugin::Perl>
  
  =item L<Locale::Maketext::Extract::Plugin::TT2>
  
  =item L<Locale::Maketext::Extract::Plugin::YAML>
  
  =item L<Locale::Maketext::Extract::Plugin::TextTemplate>
  
  =item L<Locale::Maketext::Extract::Plugin::Generic>
  
  =back
  
  =head1 AUTHORS
  
  Audrey Tang E<lt>cpan@audreyt.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2002-2008 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
  
  
  1;
LOCALE_MAKETEXT_EXTRACT_PLUGIN_MASON

$fatpacked{"Locale/Maketext/Extract/Plugin/PPI.pm"} = <<'LOCALE_MAKETEXT_EXTRACT_PLUGIN_PPI';
  package Locale::Maketext::Extract::Plugin::PPI;
  
  use strict;
  use base qw(Locale::Maketext::Extract::Plugin::Base);
  use PPI();
  
  =head1 NAME
  
  Locale::Maketext::Extract::Plugin::PPI - Perl format parser
  
  =head1 SYNOPSIS
  
      $plugin = Locale::Maketext::Extract::Plugin::PPI->new(
          $lexicon            # A Locale::Maketext::Extract object
          @file_types         # Optionally specify a list of recognised file types
      )
  
      $plugin->extract($filename,$filecontents);
  
  =head1 DESCRIPTION
  
  Does exactly the same thing as the L<Locale::Maketext::Extract::Plugin::Perl>
  parser, but more accurately, and more slowly. Considerably more slowly! For this
  reason it isn't a built-in plugin.
  
  
  =head1 SHORT PLUGIN NAME
  
      none - the module must be specified in full
  
  =head1 VALID FORMATS
  
  Valid localization function names are:
  
  =over 4
  
  =item translate
  
  =item maketext
  
  =item gettext
  
  =item loc
  
  =item x
  
  =item _
  
  =item __
  
  =back
  
  =head1 KNOWN FILE TYPES
  
  =over 4
  
  =item .pm
  
  =item .pl
  
  =item .cgi
  
  =back
  
  =cut
  
  sub file_types {
      return qw( pm pl cgi );
  }
  
  my %subnames = map { $_ => 1 } qw (translate maketext gettext loc x __);
  
  #===================================
  sub extract {
  #===================================
      my $self = shift;
      my $text = shift;
  
      my $doc = PPI::Document->new( \$text, index_locations => 1 );
  
      foreach my $statement ( @{ $doc->find('PPI::Statement') } ) {
          my @children = $statement->schildren;
  
          while ( my $child = shift @children ) {
              next
                  unless @children
                      && (    $child->isa('PPI::Token::Word')
                           && $subnames{ $child->content }
                           || $child->isa('PPI::Token::Magic')
                           && $child->content eq '_' );
  
              my $list = shift @children;
              next
                  unless $list->isa('PPI::Structure::List')
                      && $list->schildren;
  
              $self->_check_arg_list($list);
          }
      }
  }
  
  #===================================
  sub _check_arg_list {
  #===================================
      my $self = shift;
      my $list = shift;
      my @args = ( $list->schildren )[0]->schildren;
  
      my $final_string = '';
      my ( $line, $mode );
  
      while ( my $string_el = shift @args ) {
          return
              unless $string_el->isa('PPI::Token::Quote')
                  || $string_el->isa('PPI::Token::HereDoc');
          $line ||= $string_el->location->[0];
          my $string;
          if ( $string_el->isa('PPI::Token::HereDoc') ) {
              $string = join( '', $string_el->heredoc );
              $mode
                  = $string_el->{_mode} eq 'interpolate'
                  ? 'double'
                  : 'literal';
          }
          else {
              $string = $string_el->string;
              $mode
                  = $string_el->isa('PPI::Token::Quote::Literal') ? 'literal'
                  : (    $string_el->isa('PPI::Token::Quote::Double')
                      || $string_el->isa('PPI::Token::Quote::Interpolate') )
                  ? 'double'
                  : 'single';
          }
  
          if ( $mode eq 'double' ) {
              return
                  if !!( $string =~ /(?<!\\)(?:\\\\)*[\$\@]/ );
              $string = eval qq("$string");
          }
          elsif ( $mode eq 'single' ) {
              $string =~ s/\\'/'/g;
          }
  
          #    $string =~ s/(?<!\\)\\//g;
          $string =~ s/\\\\/\\/g;
  
          #        unless $mode eq 'literal';
  
          $final_string .= $string;
  
          my $next_op = shift @args;
          last
              unless $next_op
                  && $next_op->isa('PPI::Token::Operator')
                  && $next_op->content eq '.';
      }
      return unless $final_string;
  
      my $vars = join( '', map { $_->content } @args );
      $self->add_entry( $final_string, $line, $vars );
  }
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<xgettext.pl>
  
  for extracting translatable strings from common template
  systems and perl source files.
  
  =item L<Locale::Maketext::Lexicon>
  
  =item L<Locale::Maketext::Extract::Plugin::Base>
  
  =item L<Locale::Maketext::Extract::Plugin::Perl>
  
  =item L<Locale::Maketext::Extract::Plugin::FormFu>
  
  =item L<Locale::Maketext::Extract::Plugin::Perl>
  
  =item L<Locale::Maketext::Extract::Plugin::TT2>
  
  =item L<Locale::Maketext::Extract::Plugin::YAML>
  
  =item L<Locale::Maketext::Extract::Plugin::TextTemplate>
  
  =item L<Locale::Maketext::Extract::Plugin::Generic>
  
  =back
  
  =head1 AUTHORS
  
  Audrey Tang E<lt>cpan@audreyt.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2002-2008 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
  
  1;
LOCALE_MAKETEXT_EXTRACT_PLUGIN_PPI

$fatpacked{"Locale/Maketext/Extract/Plugin/Perl.pm"} = <<'LOCALE_MAKETEXT_EXTRACT_PLUGIN_PERL';
  package Locale::Maketext::Extract::Plugin::Perl;
  
  use strict;
  
  use base qw(Locale::Maketext::Extract::Plugin::Base);
  
  =head1 NAME
  
  Locale::Maketext::Extract::Plugin::Perl - Perl format parser
  
  =head1 SYNOPSIS
  
      $plugin = Locale::Maketext::Extract::Plugin::Perl->new(
          $lexicon            # A Locale::Maketext::Extract object
          @file_types         # Optionally specify a list of recognised file types
      )
  
      $plugin->extract($filename,$filecontents);
  
  =head1 DESCRIPTION
  
  Extracts strings to localise (including HEREDOCS and
  concatenated strings) from Perl code.
  
  This Perl parser is very fast and very good, but not perfect - it does make
  mistakes. The PPI parser (L<Locale::Maketext::Extract::Plugin::PPI>) is more
  accurate, but a lot slower, and so is not enabled by default.
  
  =head1 SHORT PLUGIN NAME
  
      perl
  
  =head1 VALID FORMATS
  
  Valid localization function names are:
  
  =over 4
  
  =item translate
  
  =item maketext
  
  =item gettext
  
  =item loc
  
  =item x
  
  =item _
  
  =item __
  
  =back
  
  =head1 KNOWN FILE TYPES
  
  =over 4
  
  =item .pm
  
  =item .pl
  
  =item .cgi
  
  =back
  
  =cut
  
  use constant NUL  => 0;
  use constant BEG  => 1;
  use constant PAR  => 2;
  use constant HERE => 10;
  use constant QUO1 => 3;
  use constant QUO2 => 4;
  use constant QUO3 => 5;
  use constant QUO4 => 6;
  use constant QUO5 => 7;
  use constant QUO6 => 8;
  use constant QUO7 => 9;
  
  sub file_types {
      return qw( pm pl cgi );
  }
  
  sub extract {
      my $self = shift;
      local $_ = shift;
  
      local $SIG{__WARN__} = sub { die @_ };
  
      # Perl code:
      my ( $state, $line_offset, $str, $str_part, $vars, $quo, $heredoc )
          = ( 0, 0 );
      my $orig = 1 + ( () = ( ( my $__ = $_ ) =~ /\n/g ) );
  
  PARSER: {
          $_ = substr( $_, pos($_) ) if ( pos($_) );
          my $line = $orig - ( () = ( ( my $__ = $_ ) =~ /\n/g ) );
  
          # various ways to spell the localization function
          $state == NUL
              && m/\b(translate|maketext|gettext|__?|loc(?:ali[sz]e)?|x)/gc
              && do { $state = BEG; redo };
          $state == BEG && m/^([\s\t\n]*)/gc && redo;
  
          # begin ()
          $state == BEG
              && m/^([\S\(])\s*/gc
              && do { $state = ( ( $1 eq '(' ) ? PAR : NUL ); redo };
  
          # concat
          $state == PAR
              && defined($str)
              && m/^(\s*\.\s*)/gc
              && do { $line_offset += ( () = ( ( my $__ = $1 ) =~ /\n/g ) ); redo };
  
          # str_part
          $state == PAR && defined($str_part) && do {
              if ( ( $quo == QUO1 ) || ( $quo == QUO5 ) ) {
                  $str_part =~ s/\\([\\'])/$1/g
                      if ($str_part);    # normalize q strings
              }
              elsif ( $quo != QUO6 ) {
                  $str_part =~ s/(\\(?:[0x]..|c?.))/"qq($1)"/eeg
                      if ($str_part);    # normalize qq / qx strings
              }
              $str .= $str_part;
              undef $str_part;
              undef $quo;
              redo;
          };
  
          # begin or end of string
          $state == PAR && m/^(\')/gc && do { $state = $quo = QUO1; redo };
          $state == QUO1 && m/^([^'\\]+)/gc   && do { $str_part .= $1; redo };
          $state == QUO1 && m/^((?:\\.)+)/gcs && do { $str_part .= $1; redo };
          $state == QUO1 && m/^\'/gc && do { $state = PAR; redo };
  
          $state == PAR && m/^\"/gc && do { $state = $quo = QUO2; redo };
          $state == QUO2 && m/^([^"\\]+)/gc   && do { $str_part .= $1; redo };
          $state == QUO2 && m/^((?:\\.)+)/gcs && do { $str_part .= $1; redo };
          $state == QUO2 && m/^\"/gc && do { $state = PAR; redo };
  
          $state == PAR && m/^\`/gc && do { $state = $quo = QUO3; redo };
          $state == QUO3 && m/^([^\`]*)/gc && do { $str_part .= $1; redo };
          $state == QUO3 && m/^\`/gc && do { $state = PAR; redo };
  
          $state == PAR && m/^qq\{/gc && do { $state = $quo = QUO4; redo };
          $state == QUO4 && m/^([^\}]*)/gc && do { $str_part .= $1; redo };
          $state == QUO4 && m/^\}/gc && do { $state = PAR; redo };
  
          $state == PAR && m/^q\{/gc && do { $state = $quo = QUO5; redo };
          $state == QUO5 && m/^([^\}]*)/gc && do { $str_part .= $1; redo };
          $state == QUO5 && m/^\}/gc && do { $state = PAR; redo };
  
          # find heredoc terminator, then get the
          #heredoc and go back to current position
          $state == PAR
              && m/^<<\s*\'/gc
              && do { $state = $quo = QUO6; $heredoc = ''; redo };
          $state == QUO6 && m/^([^'\\\n]+)/gc && do { $heredoc .= $1; redo };
          $state == QUO6 && m/^((?:\\.)+)/gc  && do { $heredoc .= $1; redo };
          $state == QUO6
              && m/^\'/gc
              && do { $state = HERE; $heredoc =~ s/\\\'/\'/g; redo };
  
          $state == PAR
              && m/^<<\s*\"/gc
              && do { $state = $quo = QUO7; $heredoc = ''; redo };
          $state == QUO7 && m/^([^"\\\n]+)/gc && do { $heredoc .= $1; redo };
          $state == QUO7 && m/^((?:\\.)+)/gc  && do { $heredoc .= $1; redo };
          $state == QUO7
              && m/^\"/gc
              && do { $state = HERE; $heredoc =~ s/\\\"/\"/g; redo };
  
          $state == PAR
              && m/^<<(\w*)/gc
              && do { $state = HERE; $quo = QUO7; $heredoc = $1; redo };
  
          # jump ahaid and get the heredoc, then s/// also
          # resets the pos and we are back at the current pos
          $state == HERE
              && m/^.*\r?\n/gc
              && s/\G(.*?\r?\n)$heredoc(\r?\n)//s
              && do { $state = PAR; $str_part .= $1; $line_offset++; redo };
  
          # end ()
          #
  
          $state == PAR && m/^\s*[\)]/gc && do {
              $state = NUL;
              $vars =~ s/[\n\r]//g if ($vars);
              $self->add_entry( $str,
                                $line - ( () = $str =~ /\n/g ) - $line_offset,
                                $vars )
                  if $str;
              undef $str;
              undef $vars;
              undef $heredoc;
              $line_offset = 0;
              redo;
          };
          # a line of vars
          $state == PAR && m/^([^\)]*)/gc && do { $vars .= "$1\n"; redo };
      }
  }
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<xgettext.pl>
  
  for extracting translatable strings from common template
  systems and perl source files.
  
  =item L<Locale::Maketext::Lexicon>
  
  =item L<Locale::Maketext::Extract::Plugin::Base>
  
  =item L<Locale::Maketext::Extract::Plugin::PPI>
  
  =item L<Locale::Maketext::Extract::Plugin::FormFu>
  
  =item L<Locale::Maketext::Extract::Plugin::TT2>
  
  =item L<Locale::Maketext::Extract::Plugin::YAML>
  
  =item L<Locale::Maketext::Extract::Plugin::Mason>
  
  =item L<Locale::Maketext::Extract::Plugin::TextTemplate>
  
  =item L<Locale::Maketext::Extract::Plugin::Generic>
  
  =back
  
  =head1 AUTHORS
  
  Audrey Tang E<lt>cpan@audreyt.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2002-2008 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
  
  1;
LOCALE_MAKETEXT_EXTRACT_PLUGIN_PERL

$fatpacked{"Locale/Maketext/Extract/Plugin/TT2.pm"} = <<'LOCALE_MAKETEXT_EXTRACT_PLUGIN_TT2';
  package Locale::Maketext::Extract::Plugin::TT2;
  
  use strict;
  use base qw(Locale::Maketext::Extract::Plugin::Base);
  use Template::Constants qw( :debug );
  use Template::Parser;
  
  =head1 NAME
  
  Locale::Maketext::Extract::Plugin::TT2 - Template Toolkit format parser
  
  =head1 SYNOPSIS
  
      $plugin = Locale::Maketext::Extract::Plugin::TT2->new(
          $lexicon            # A Locale::Maketext::Extract object
          @file_types         # Optionally specify a list of recognised file types
      )
  
      $plugin->extract($filename,$filecontents);
  
  =head1 DESCRIPTION
  
  Extracts strings to localise from Template Toolkit templates.
  
  =head1 SHORT PLUGIN NAME
  
      tt2
  
  =head1 VALID FORMATS
  
  Valid formats are:
  
  =over 4
  
  =item [% |l(args) %]string[% END %]
  
  =item [% 'string' | l(args) %]
  
  =item [% l('string',args) %]
  
  =back
  
  l and loc are interchangeable.
  
  | and FILTER are interchangeable.
  
  =head1 KNOWN FILE TYPES
  
  =over 4
  
  =item .tt
  
  =item .tt2
  
  =item .html
  
  =item .tt.*
  
  =item .tt2.*
  
  =back
  
  =head1 REQUIRES
  
  L<Template>
  
  =head1 NOTES
  
  =over 4
  
  =item *
  
  B<BEWARE> Using the C<loc> form can give false positives if you use the Perl parser
  plugin on TT files.  If you want to use the C<loc> form, then you should
  specify the file types that you want to the Perl plugin to parse, or enable
  the default file types, eg:
  
     xgetext.pl -P perl ....        # default file types
     xgettext.pl -P perl=pl,pm  ... # specified file types
  
  =item *
  
  The string-to-be-localised must be a string, not a variable. We try not
  to extract calls to your localise function which contain variables eg:
  
      l('string',arg)  # extracted
      l(var,arg)       # not extracted
  
  This doesn't work for block filters, so don't do that. Eg:
  
      [%  FILTER l %]
         string [% var %]      # BAD!
      [% END %]
  
  =item *
  
  Getting the right line number is difficult in TT. Often it'll be a range
  of lines, or it may be thrown out by the use of PRE_CHOMP or POST_CHOMP.  It will
  always be within a few lines of the correct location.
  
  =item *
  
  If you have PRE/POST_CHOMP enabled by default in your templates, then you should
  extract the strings using the same values.  In order to set them, you can
  use the following wrapper script:
  
     #!/usr/bin/perl
  
     use Locale::Maketext::Extract::Run qw(xgettext);
     use Locale::Maketext::Extract::Plugin::TT2();
  
     %Locale::Maketext::Extract::Plugin::TT2::PARSER_OPTIONS = (
          PRE_CHOMP  => 1, # or 2
          POST_CHOMP => 1, # or 2
  
          # Also START/END_TAG, ANYCASE, INTERPOLATE, V1DOLLAR, EVAL_PERL
     );
  
     xgettext(@ARGV);
  
  =back
  
  
  =cut
  
  # import strip_quotes
  *strip_quotes
      = \&Locale::Maketext::Extract::Plugin::TT2::Directive::strip_quotes;
  
  our %PARSER_OPTIONS;
  
  #===================================
  sub file_types {
  #===================================
      return ( qw( tt tt2 html ), qr/\.tt2?\./ );
  }
  
  my %Escapes = map { ( "\\$_" => eval("qq(\\$_)") ) } qw(t n r f b a e);
  
  #===================================
  sub extract {
  #===================================
      my $self = shift;
      my $data = shift;
  
      $Template::Directive::PRETTY = 1;
      my $parser =
          Locale::Maketext::Extract::Plugin::TT2::Parser->new(
                 %PARSER_OPTIONS,
                 FACTORY => 'Locale::Maketext::Extract::Plugin::TT2::Directive',
                 FILE_INFO => 0,
          );
      _init_overrides($parser);
  
      $parser->{extracted} = [];
  
      $Locale::Maketext::Extract::Plugin::TT2::Directive::PARSER
          = $parser;    # hack
      $parser->parse($data)
          || die $parser->error;
  
      foreach my $entry ( @{ $parser->{extracted} } ) {
          $entry->[2] =~ s/^\((.*)\)$/$1/s;    # Remove () from vars
          $_ =~ s/\\'/'/gs                     # Unescape \'
              for @{$entry}[ 0, 2 ];
          $entry->[2] =~ s/\\(?!")/\\\\/gs;    # Escape all \ not followed by "
                                               # Escape argument lists correctly
          while ( my ( $char, $esc ) = each %Escapes ) {
              $entry->[2] =~ s/$esc/$char/g;
          }
          $entry->[1] =~ s/\D+.*$//;
          $self->add_entry(@$entry);
      }
  }
  
  #===================================
  sub _init_overrides {
  #===================================
      my $parser = shift;
  
      # Override the concatenation sub to return _ instead of .
      my $states = $parser->{STATES};
      foreach my $state ( @{$states} ) {
          if ( my $CAT_no = $state->{ACTIONS}{CAT} ) {
              my $CAT_rule_no
                  = $states->[ $states->[$CAT_no]{GOTOS}{expr} ]->{DEFAULT};
  
              # override the TT::Grammar sub which cats two args
              $parser->{RULES}[ -$CAT_rule_no ][2] = sub {
                  my $first  = ( $_[1] );
                  my $second = ( $_[3] );
                  if ( strip_quotes($first) && strip_quotes($second) ) {
  
                      # both are literal
                      return "'${first}${second}'";
                  }
                  else {
  
                      # at least one is an ident
                      return "$_[1] _ $_[3]";
                  }
              };
              last;
          }
      }
  }
  
  #===================================
  #===================================
  package Locale::Maketext::Extract::Plugin::TT2::Parser;
  #===================================
  #===================================
  
  use base 'Template::Parser';
  
  # disabled location() because it was adding unneccessary text
  # to filter blocks
  #===================================
  sub location {''}
  #===================================
  
  # Custom TT parser for Locale::Maketext::Lexicon
  #
  # Written by Andy Wardley http://wardley.org/
  #
  # 18 September 2008
  #
  
  #-----------------------------------------------------------------------
  # custom directive generator to capture filters, variables and
  # massage a few other elements to make life easy.
  #-----------------------------------------------------------------------
  
  #===================================
  #===================================
  package Locale::Maketext::Extract::Plugin::TT2::Directive;
  #===================================
  #===================================
  
  use base 'Template::Directive';
  
  our $PARSER;
  
  #===================================
  sub textblock {
  #===================================
      my ( $class, $text ) = @_;
      $text =~ s/([\\'])/\\$1/g;
      return "'$text'";
  }
  
  #===================================
  sub ident {
  #===================================
      my ( $class, $ident ) = @_;
      return "NULL" unless @$ident;
      if ( scalar @$ident <= 2 && !$ident->[1] ) {
          my $var = $ident->[0];
          $var =~ s/^'(.+)'$/$1/;
          return $var;
      }
      else {
          my @source = @$ident;
          my @dotted;
          my $first = 1;
          my $first_literal;
          while (@source) {
              my ( $name, $args ) = splice( @source, 0, 2 );
              if ($first) {
                  strip_quotes($name);
                  my $first_arg = $args && @$args ? $args->[0] : '';
                  $first_literal = strip_quotes($first_arg);
                  $first--;
              }
              elsif ( !strip_quotes($name) && $name =~ /\D/ ) {
                  $name = '$' . $name;
              }
              $name .= join_args($args);
              push( @dotted, $name );
          }
          if ( $first_literal
               && ( $ident->[0] eq "'l'" or $ident->[0] eq "'loc'" ) )
          {
              my $string = shift @{ $ident->[1] };
              strip_quotes($string);
              $string =~ s/\\\\/\\/g;
              my $args = join_args( $ident->[1] );
              push @{ $PARSER->{extracted} },
                  [ $string, ${ $PARSER->{LINE} }, $args ];
          }
          return join( '.', @dotted );
      }
  }
  
  #===================================
  sub text {
  #===================================
      my ( $class, $text ) = @_;
      $text =~ s/\\/\\\\/g;
      return "'$text'";
  }
  
  #===================================
  sub quoted {
  #===================================
      my ( $class, $items ) = @_;
      return '' unless @$items;
      return ( $items->[0] ) if scalar @$items == 1;
      return '(' . join( ' _ ', @$items ) . ')';
  }
  
  #===================================
  sub args {
  #===================================
      my ( $class, $args ) = @_;
      my $hash = shift @$args;
      push( @$args, '{ ' . join( ', ', @$hash ) . ' }' )    # named params
          if @$hash;
      return $args;
  }
  
  #===================================
  sub get {
  #===================================
      my ( $class, $expr ) = @_;
      return $expr;
  }
  
  #===================================
  sub filter {
  #===================================
      my ( $class, $lnameargs, $block ) = @_;
      my ( $name,  $args,      $alias ) = @$lnameargs;
      $name = $name->[0];
      return ''
          unless $name eq "'l'"
              or $name eq "'loc'";
      if ( strip_quotes($block) ) {
          $block =~ s/\\\\/\\/g;
          $args = join_args( $class->args($args) );
  
          # NOTE: line number is at end of block, and can be a range
          my ($end) = ( ${ $PARSER->{LINE} } =~ /^(\d+)/ );
          my $start = $end;
  
          # rewind line count for newlines
          $start -= $block =~ tr/\n//;
          my $line = $start == $end ? $start : "$start-$end";
          push @{ $PARSER->{extracted} }, [ $block, $line, $args ];
  
      }
      return '';
  }
  
  # strips outer single quotes from a string (modifies original string)
  # returns true if stripped, or false
  #===================================
  sub strip_quotes {
  #===================================
      return scalar $_[0] =~ s/^'(.*)'$/$1/s;
  }
  
  #===================================
  sub join_args {
  #===================================
      my $args = shift;
      return '' unless $args && @$args;
      my @new_args = (@$args);
      for (@new_args) {
          s/\\\\/\\/g;
          if ( strip_quotes($_) ) {
              s/"/\\"/g;
              $_ = qq{"$_"};
          }
      }
      return '(' . join( ', ', @new_args ) . ')';
  }
  
  =head1 ACKNOWLEDGEMENTS
  
  Thanks to Andy Wardley for writing the Template::Directive subclass which
  made this possible.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<xgettext.pl>
  
  for extracting translatable strings from common template
  systems and perl source files.
  
  =item L<Locale::Maketext::Lexicon>
  
  =item L<Locale::Maketext::Extract::Plugin::Base>
  
  =item L<Locale::Maketext::Extract::Plugin::FormFu>
  
  =item L<Locale::Maketext::Extract::Plugin::Perl>
  
  =item L<Locale::Maketext::Extract::Plugin::YAML>
  
  =item L<Locale::Maketext::Extract::Plugin::Mason>
  
  =item L<Locale::Maketext::Extract::Plugin::TextTemplate>
  
  =item L<Locale::Maketext::Extract::Plugin::Generic>
  
  =item L<Template::Toolkit>
  
  =back
  
  =head1 AUTHORS
  
  Clinton Gormley E<lt>clint@traveljury.comE<gt>
  
  Andy Wardley http://wardley.org
  
  =head1 COPYRIGHT
  
  Copyright 2002-2008 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
  
  1;
LOCALE_MAKETEXT_EXTRACT_PLUGIN_TT2

$fatpacked{"Locale/Maketext/Extract/Plugin/TextTemplate.pm"} = <<'LOCALE_MAKETEXT_EXTRACT_PLUGIN_TEXTTEMPLATE';
  package Locale::Maketext::Extract::Plugin::TextTemplate;
  
  use strict;
  use base qw(Locale::Maketext::Extract::Plugin::Base);
  use vars qw($VERSION);
  
  $VERSION = '0.31';
  
  =head1 NAME
  
  Locale::Maketext::Extract::Plugin::TextTemplate - Text::Template format parser
  
  =head1 SYNOPSIS
  
      $plugin = Locale::Maketext::Extract::Plugin::TextTemplate->new(
          $lexicon            # A Locale::Maketext::Extract object
          @file_types         # Optionally specify a list of recognised file types
      )
  
      $plugin->extract($filename,$filecontents);
  
  =head1 DESCRIPTION
  
  Extracts strings to localise from Text::Template files
  
  =head1 SHORT PLUGIN NAME
  
      text
  
  =head1 VALID FORMATS
  
  Sentences between STARTxxx and ENDxxx are extracted individually.
  
  =head1 KNOWN FILE TYPES
  
  =over 4
  
  =item All file types
  
  =back
  
  =cut
  
  sub file_types {
      return qw( * );
  }
  
  
  sub extract {
      my $self = shift;
      local $_ = shift;
  
      my $line = 1; pos($_) = 0;
  
      # Text::Template
      if ($_=~/^STARTTEXT$/m and $_=~ /^ENDTEXT$/m) {
          require HTML::Parser;
          require Lingua::EN::Sentence;
  
          {
              package Locale::Maketext::Extract::Plugin::TextTemplate::Parser;
              our @ISA = 'HTML::Parser';
              *{'text'} = sub {
                  my ($self, $str, $is_cdata) = @_;
                  my $sentences = Lingua::EN::Sentence::get_sentences($str) or return;
                  $str =~ s/\n/ /g; $str =~ s/^\s+//; $str =~ s/\s+$//;
                  $self->add_entry($str , $line);
              };
          }
  
          my $p = Locale::Maketext::Extract::Plugin::TextTemplate::Parser->new;
          while (m/\G((.*?)^(?:START|END)[A-Z]+$)/smg) {
              my ($str) = ($2);
              $line += ( () = ($1 =~ /\n/g) ); # cryptocontext!
              $p->parse($str); $p->eof;
          }
          $_ = '';
      }
  
  }
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<xgettext.pl>
  
  for extracting translatable strings from common template
  systems and perl source files.
  
  =item L<Locale::Maketext::Lexicon>
  
  =item L<Locale::Maketext::Extract::Plugin::Base>
  
  =item L<Locale::Maketext::Extract::Plugin::FormFu>
  
  =item L<Locale::Maketext::Extract::Plugin::Perl>
  
  =item L<Locale::Maketext::Extract::Plugin::TT2>
  
  =item L<Locale::Maketext::Extract::Plugin::YAML>
  
  =item L<Locale::Maketext::Extract::Plugin::Mason>
  
  =item L<Locale::Maketext::Extract::Plugin::Generic>
  
  =back
  
  =head1 AUTHORS
  
  Audrey Tang E<lt>cpan@audreyt.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2002-2008 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
  
  
  1;
LOCALE_MAKETEXT_EXTRACT_PLUGIN_TEXTTEMPLATE

$fatpacked{"Locale/Maketext/Extract/Plugin/YAML.pm"} = <<'LOCALE_MAKETEXT_EXTRACT_PLUGIN_YAML';
  package Locale::Maketext::Extract::Plugin::YAML;
  
  use strict;
  use base qw(Locale::Maketext::Extract::Plugin::Base);
  
  =head1 NAME
  
  Locale::Maketext::Extract::Plugin::YAML - YAML format parser
  
  =head1 SYNOPSIS
  
      $plugin = Locale::Maketext::Extract::Plugin::YAML->new(
          $lexicon            # A Locale::Maketext::Extract object
          @file_types         # Optionally specify a list of recognised file types
      )
  
      $plugin->extract($filename,$filecontents);
  
  =head1 DESCRIPTION
  
  Extracts strings to localise from YAML files.
  
  =head1 SHORT PLUGIN NAME
  
      yaml
  
  =head1 VALID FORMATS
  
  Valid formats are:
  
  =over 4
  
  =item *
  
      key: _"string"
  
  =item *
  
      key: _'string'
  
  =item *
  
      key: _'string with embedded 'quotes''
  
  =item *
  
      key: |-
           _'my folded
           string
           to translate'
  
  Note, the left hand side of the folded string must line up with the C<_>,
  otherwise YAML adds spaces at the beginning of each line.
  
  =item *
  
      key: |-
           _'my block
           string
           to translate
           '
  Note, you must use the trailing C<-> so that YAMl doesn't add a carriage
  return after your final quote.
  
  =back
  
  =head1 KNOWN FILE TYPES
  
  =over 4
  
  =item .yaml
  
  =item .yml
  
  =item .conf
  
  =back
  
  =head1 REQUIRES
  
  L<YAML>
  
  =head1 NOTES
  
  The docs for the YAML module describes it as alpha code. It is not as tolerant
  of errors as L<YAML::Syck>. However, because it is pure Perl, it is easy
  to hook into.
  
  I have seen it enter endless loops, so if xgettext.pl hangs, try running it
  again with C<--verbose --verbose> (twice) enabled, so that you can see if
  the fault lies with YAML.  If it does, either correct the YAML source file,
  or use the file_types to exclude that file.
  
  =cut
  
  
  sub file_types {
      return qw( yaml yml conf );
  }
  
  sub extract {
      my $self = shift;
      my $data = shift;
  
      my $y = Locale::Maketext::Extract::Plugin::YAML::Extractor->new();
      $y->load($data);
  
      foreach my $entry (@{$y->found}) {
          $self->add_entry(@$entry)
      }
  
  }
  
  
  package Locale::Maketext::Extract::Plugin::YAML::Extractor;
  
  use base qw(YAML::Loader);
  
  #===================================
  sub new {
  #===================================
      my $class = shift;
      my $self  = $class->SUPER::new(@_);
      $self->{found} = [];
      return $self;
  }
  
  #===================================
  sub check_scalar {
  #===================================
      my $self = shift;
      my $node = $_[0];
      if ( defined $node && !ref $node && $node =~ /^__?(["'])(.+)\1$/s ) {
          my $string = $2;
          my $line   = $_[1];
          push @{ $self->{found} }, [ $string, $line ];
      }
      return $node;
  }
  
  sub _parse_node {
      my $self = shift;
      my $line = $self->{_start_line}||=length($self->preface) ? $self->line - 1 : $self->line;
      my $node = $self->SUPER::_parse_node(@_);
      $self->{start_line} = 0;
      return $self->check_scalar($node,$line);
  }
  
  sub _parse_inline_seq {
      my $self = shift;
      my $line = $self->{_start_line}||=$self->line;
      my $node = $self->SUPER::_parse_inline_seq(@_);
      foreach (@$node) {
          $self->check_scalar( $_, $line );
      }
      $self->{start_line} = 0;
      return $node;
  }
  
  sub _parse_inline_mapping {
      my $self = shift;
      my $line = $self->{_start_line}||=$self->line;
      my $node = $self->SUPER::_parse_inline_mapping(@_);
      foreach ( values %$node ) {
          $self->check_scalar( $_, $line );
      }
      $self->{start_line} = 0;
      return $node;
  }
  
  #===================================
  sub _parse_next_line {
  #===================================
      my $self = shift;
      $self->{_start_line}  = $self->line
          if $_[0] == YAML::Loader::COLLECTION;
      $self->SUPER::_parse_next_line(@_);
  }
  
  sub found {
      my $self = shift;
      return $self->{found};
  }
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<xgettext.pl>
  
  for extracting translatable strings from common template
  systems and perl source files.
  
  =item L<YAML>
  
  =item L<Locale::Maketext::Lexicon>
  
  =item L<Locale::Maketext::Extract::Plugin::Base>
  
  =item L<Locale::Maketext::Extract::Plugin::FormFu>
  
  =item L<Locale::Maketext::Extract::Plugin::Perl>
  
  =item L<Locale::Maketext::Extract::Plugin::TT2>
  
  =item L<Locale::Maketext::Extract::Plugin::Mason>
  
  =item L<Locale::Maketext::Extract::Plugin::TextTemplate>
  
  =item L<Locale::Maketext::Extract::Plugin::Generic>
  
  =back
  
  =head1 AUTHORS
  
  Clinton Gormley E<lt>clint@traveljury.comE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2002-2008 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
  
  
  1;
LOCALE_MAKETEXT_EXTRACT_PLUGIN_YAML

$fatpacked{"Locale/Maketext/Extract/Run.pm"} = <<'LOCALE_MAKETEXT_EXTRACT_RUN';
  package Locale::Maketext::Extract::Run;
  $Locale::Maketext::Lexicon::Extract::Run::VERSION = '0.35';
  
  use strict;
  use vars qw( @ISA @EXPORT_OK );
  use File::Spec::Functions qw(catfile);
  
  =head1 NAME
  
  Locale::Maketext::Extract::Run - Module interface to xgettext.pl
  
  =head1 SYNOPSIS
  
      use Locale::Maketext::Extract::Run 'xgettext';
      xgettext(@ARGV);
  
  =cut
  
  use Cwd;
  use Config ();
  use File::Find;
  use Getopt::Long;
  use Locale::Maketext::Extract;
  use Exporter;
  
  use constant HAS_SYMLINK => ( $Config::Config{d_symlink} ? 1 : 0 );
  
  @ISA       = 'Exporter';
  @EXPORT_OK = 'xgettext';
  
  sub xgettext { __PACKAGE__->run(@_) }
  
  sub run {
      my $self = shift;
      local @ARGV = @_;
  
      my %opts;
      Getopt::Long::Configure("no_ignore_case");
      Getopt::Long::GetOptions( \%opts,
                                'f|files-from:s@',
                                'D|directory:s@',
                                'u|use-gettext-style|unescaped',
                                'g|gnu-gettext',
                                'o|output:s@',
                                'd|default-domain:s',
                                'p|output-dir:s@',
                                'P|plugin:s@',
                                'W|wrap!',
                                'w|warnings!',
                                'v|verbose+',
                                'h|help',
      ) or help();
  
      help() if $opts{h};
  
      my %extract_options = %{ $self->_parse_extract_options( \%opts ) };
  
      my @po = @{ $opts{o} || [ ( $opts{d} || 'messages' ) . '.po' ] };
  
      foreach my $file ( @{ $opts{f} || [] } ) {
          open FILE, $file or die "Cannot open $file: $!";
          while (<FILE>) {
              chomp;
              push @ARGV, $_ if -r and !-d;
          }
      }
  
      foreach my $dir ( @{ $opts{D} || [] } ) {
          File::Find::find( {
                 wanted => sub {
                     if (-d) {
                         $File::Find::prune
                             = /^(\.svn|blib|autogen|var|m4|local|CVS|\.git)$/;
                         return;
                     }
                     # Only extract from non-binary, normal files
                     return unless (-f or -s) and -T;
                     return
                         if (/\.po$|\.bak$|~|,D|,B$/i)
                         || (/^[\.#]/);
                     push @ARGV, $File::Find::name;
                 },
                 follow => HAS_SYMLINK,
              },
              $dir
          );
      }
  
      @ARGV = ('-') unless @ARGV;
      s!^\.[/\\]!! for @ARGV;
  
      my $cwd = getcwd();
  
      my $Ext = Locale::Maketext::Extract->new(%extract_options);
      foreach my $dir ( @{ $opts{p} || ['.'] } ) {
          $Ext->extract_file($_) for grep !/\.po$/i, @ARGV;
          foreach my $po (@po) {
              $Ext->read_po($po) if -r $po and -s _;
              $Ext->compile( $opts{u} ) or next;
              $Ext->write_po( catfile( $dir, $po ), $opts{g} );
          }
      }
  }
  
  sub _parse_extract_options {
      my $self = shift;
      my $opts = shift;
  
      # If a list of plugins is specified, then we use those modules
      # plus their default list of file extensionse
      # and warnings enabled by default
  
      my %extract_options
          = ( verbose => $opts->{v}, wrap => $opts->{W} || 0 );
  
      if ( my $plugin_args = $opts->{P} ) {
  
          # file extension with potentially multiple dots eg .tt.html
          my %plugins;
  
          foreach my $param (@$plugin_args) {
              my ( $plugin, $args )
                  = ( $param =~ /^([a-z_]\w+(?:::\w+)*)(?:=(.+))?$/i );
              die "Couldn't understand plugin option '$param'"
                  unless $plugin;
              my @extensions;
              if ($args) {
                  foreach my $arg ( split /,/, $args ) {
                      if ( $arg eq '*' ) {
                          @extensions = ('*');
                          last;
                      }
                      my ($extension) = ( $arg =~ /^\.?(\w+(?:\.\w+)*)$/ );
                      die "Couldn't understand '$arg' in plugin '$param'"
                          unless defined $extension;
                      push @extensions, $extension;
                  }
              }
  
              $plugins{$plugin} = \@extensions;
          }
          $extract_options{plugins} = \%plugins;
          $extract_options{warnings} = exists $opts->{w} ? $opts->{w} : 1;
      }
  
      # otherwise we default to the original xgettext.pl modules
      # with warnings disabled by default
      else {
          $extract_options{warnings} = $opts->{w};
      }
      return \%extract_options;
  
  }
  
  sub help {
      local $SIG{__WARN__} = sub { };
      { exec "perldoc $0"; }
      { exec "pod2text $0"; }
  }
  
  1;
  
  =head1 COPYRIGHT
  
  Copyright 2003-2008 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
LOCALE_MAKETEXT_EXTRACT_RUN

$fatpacked{"Locale/Maketext/Lexicon.pm"} = <<'LOCALE_MAKETEXT_LEXICON';
  package Locale::Maketext::Lexicon;
  $Locale::Maketext::Lexicon::VERSION = '0.86';
  
  use 5.004;
  use strict;
  
  =head1 NAME
  
  Locale::Maketext::Lexicon - Use other catalog formats in Maketext
  
  =head1 VERSION
  
  This document describes version 0.80 of Locale::Maketext::Lexicon,
  released December 29, 2008.
  
  =head1 SYNOPSIS
  
  As part of a localization class, automatically glob for available
  lexicons:
  
      package Hello::I18N;
      use base 'Locale::Maketext';
      use Locale::Maketext::Lexicon {
          '*' => [Gettext => '/usr/local/share/locale/*/LC_MESSAGES/hello.mo'],
          ### Uncomment to fallback when a key is missing from lexicons
          # _auto   => 1,
          ### Uncomment to decode lexicon entries into Unicode strings
          # _decode => 1,
          ### Uncomment to load and parse everything right away
          # _preload => 1,
          ### Uncomment to use %1 / %quant(%1) instead of [_1] / [quant, _1]
          # _style  => 'gettext',
      };
  
  Explicitly specify languages, during compile- or run-time:
  
      package Hello::I18N;
      use base 'Locale::Maketext';
      use Locale::Maketext::Lexicon {
          de => [Gettext => 'hello_de.po'],
          fr => [
              Gettext => 'hello_fr.po',
              Gettext => 'local/hello/fr.po',
          ],
      };
      # ... incrementally add new lexicons
      Locale::Maketext::Lexicon->import({
          de => [Gettext => 'local/hello/de.po'],
      })
  
  Alternatively, as part of a localization subclass:
  
      package Hello::I18N::de;
      use base 'Hello::I18N';
      use Locale::Maketext::Lexicon (Gettext => \*DATA);
      __DATA__
      # Some sample data
      msgid ""
      msgstr ""
      "Project-Id-Version: Hello 1.3.22.1\n"
      "MIME-Version: 1.0\n"
      "Content-Type: text/plain; charset=iso8859-1\n"
      "Content-Transfer-Encoding: 8bit\n"
  
      #: Hello.pm:10
      msgid "Hello, World!"
      msgstr "Hallo, Welt!"
  
      #: Hello.pm:11
      msgid "You have %quant(%1,piece) of mail."
      msgstr "Sie haben %quant(%1,Poststueck,Poststuecken)."
  
  =head1 DESCRIPTION
  
  This module provides lexicon-handling modules to read from other
  localization formats, such as I<Gettext>, I<Msgcat>, and so on.
  
  If you are unfamiliar with the concept of lexicon modules, please
  consult L<Locale::Maketext> and the C<webl10n> HTML files in the C<docs/>
  directory of this module.
  
  A command-line utility L<xgettext.pl> is also installed with this
  module, for extracting translatable strings from source files.
  
  =head2 The C<import> function
  
  The C<import()> function accepts two forms of arguments:
  
  =over 4
  
  =item (I<format> => I<source> ... )
  
  This form takes any number of argument pairs (usually one);
  I<source> may be a file name, a filehandle, or an array reference.
  
  For each such pair, it pass the contents specified by the second
  argument to B<Locale::Maketext::Lexicon::I<format>>->parse as a
  plain list, and export its return value as the C<%Lexicon> hash
  in the calling package.
  
  In the case that there are multiple such pairs, the lexicon
  defined by latter ones overrides earlier ones.
  
  =item { I<language> => [ I<format>, I<source> ... ] ... }
  
  This form accepts a hash reference.  It will export a C<%Lexicon>
  into the subclasses specified by each I<language>, using the process
  described above.  It is designed to alleviate the need to set up a
  separate subclass for each localized language, and just use the catalog
  files.
  
  This module will convert the I<language> arguments into lowercase,
  and replace all C<-> with C<_>, so C<zh_TW> and C<zh-tw> will both
  map to the C<zh_tw> subclass.
  
  If I<language> begins with C<_>, it is taken as an option that
  controls how lexicons are parsed.  See L</Options> for a list
  of available options.
  
  The C<*> is a special I<language>; it must be used in conjunction
  with a filename that also contains C<*>; all matched files with
  a valid language code in the place of C<*> will be automatically
  prepared as a lexicon subclass.  If there is multiple C<*> in
  the filename, the last one is used as the language name.
  
  =back
  
  =head2 Options
  
  =over 4
  
  =item C<_auto>
  
  If set to a true value, missing lookups on lexicons are handled
  silently, as if an C<Auto> lexicon has been appended on all
  language lexicons.
  
  =item C<_decode>
  
  If set to a true value, source entries will be converted into
  utf8-strings (available in Perl 5.6.1 or later).  This feature
  needs the B<Encode> or B<Encode::compat> module.
  
  Currently, only the C<Gettext> backend supports this option.
  
  =item C<_encoding>
  
  This option only has effect when C<_decode> is set to true.
  It specifies an encoding to store lexicon entries, instead of
  utf8-strings.
  
  If C<_encoding> is set to C<locale>, the encoding from the
  current locale setting is used.
  
  =item C<_preload>
  
  By default parsing is delayed until first use of the lexicon,
  set this option to true value to parse it asap. Increment
  adding lexicons forces parsing.
  
  =back
  
  =head2 Subclassing format handlers
  
  If you wish to override how sources specified in different data types
  are handled, please use a subclass that overrides C<lexicon_get_I<TYPE>>.
  
  XXX: not documented well enough yet.  Patches welcome.
  
  =head1 NOTES
  
  When you attempt to localize an entry missing in the lexicon, Maketext
  will throw an exception by default.  To inhibit this behaviour, override
  the C<_AUTO> key in your language subclasses, for example:
  
      $Hello::I18N::en::Lexicon{_AUTO} = 1; # autocreate missing keys
  
  If you want to implement a new C<Lexicon::*> backend module, please note
  that C<parse()> takes an array containing the B<source strings> from the
  specified filehandle or filename, which are I<not> C<chomp>ed.  Although
  if the source is an array reference, its elements will probably not contain
  any newline characters anyway.
  
  The C<parse()> function should return a hash reference, which will be
  assigned to the I<typeglob> (C<*Lexicon>) of the language module.  All
  it amounts to is that if the returned reference points to a tied hash,
  the C<%Lexicon> will be aliased to the same tied hash if it was not
  initialized previously.
  
  =cut
  
  our %Opts;
  sub option { shift if ref( $_[0] ); $Opts{ lc $_[0] } }
  sub set_option { shift if ref( $_[0] ); $Opts{ lc $_[0] } = $_[1] }
  
  sub encoding {
      my $encoding = option( @_, 'encoding' ) or return;
      return $encoding unless lc($encoding) eq 'locale';
  
      local $^W;    # no warnings 'uninitialized', really.
      my ( $country_language, $locale_encoding );
  
      local $@;
      eval {
          require I18N::Langinfo;
          $locale_encoding
              = I18N::Langinfo::langinfo( I18N::Langinfo::CODESET() );
          }
          or eval {
          require Win32::Console;
          $locale_encoding = 'cp' . Win32::Console::OutputCP();
          };
      if ( !$locale_encoding ) {
          foreach my $key (qw( LANGUAGE LC_ALL LC_MESSAGES LANG )) {
              $ENV{$key} =~ /^([^.]+)\.([^.:]+)/ or next;
              ( $country_language, $locale_encoding ) = ( $1, $2 );
              last;
          }
      }
      if (   defined $locale_encoding
          && lc($locale_encoding) eq 'euc'
          && defined $country_language )
      {
          if ( $country_language =~ /^ja_JP|japan(?:ese)?$/i ) {
              $locale_encoding = 'euc-jp';
          }
          elsif ( $country_language =~ /^ko_KR|korean?$/i ) {
              $locale_encoding = 'euc-kr';
          }
          elsif ( $country_language =~ /^zh_CN|chin(?:a|ese)?$/i ) {
              $locale_encoding = 'euc-cn';
          }
          elsif ( $country_language =~ /^zh_TW|taiwan(?:ese)?$/i ) {
              $locale_encoding = 'euc-tw';
          }
      }
  
      return $locale_encoding;
  }
  
  sub import {
      my $class = shift;
      return unless @_;
  
      my %entries;
      if ( UNIVERSAL::isa( $_[0], 'HASH' ) ) {
  
          # a hashref with $lang as keys, [$format, $src ...] as values
          %entries = %{ $_[0] };
      }
      elsif ( @_ % 2 == 0 ) {
          %entries = ( '' => [ splice @_, 0, 2 ], @_ );
      }
  
      # expand the wildcard entry
      if ( my $wild_entry = delete $entries{'*'} ) {
          while ( my ( $format, $src ) = splice( @$wild_entry, 0, 2 ) ) {
              next if ref($src); # XXX: implement globbing for the 'Tie' backend
  
              my $pattern = quotemeta($src);
              $pattern =~ s/\\\*(?=[^*]+$)/\([-\\w]+\)/g or next;
              $pattern =~ s/\\\*/.*?/g;
              $pattern =~ s/\\\?/./g;
              $pattern =~ s/\\\[/[/g;
              $pattern =~ s/\\\]/]/g;
              $pattern =~ s[\\\{(.*?)\\\\}][
                  '(?:'.join('|', split(/,/, $1)).')'
              ]eg;
  
              require File::Glob;
              foreach my $file ( File::Glob::bsd_glob($src) ) {
                  $file =~ /$pattern/ or next;
                  push @{ $entries{$1} }, ( $format => $file ) if $1;
              }
              delete $entries{$1}
                  unless !defined($1)
                      or exists $entries{$1} and @{ $entries{$1} };
          }
      }
  
      %Opts = ();
      foreach my $key ( grep /^_/, keys %entries ) {
          set_option( lc( substr( $key, 1 ) ) => delete( $entries{$key} ) );
      }
      my $OptsRef = {%Opts};
  
      while ( my ( $lang, $entry ) = each %entries ) {
          my $export = caller;
  
          if ( length $lang ) {
  
              # normalize language tag to Maketext's subclass convention
              $lang = lc($lang);
              $lang =~ s/-/_/g;
              $export .= "::$lang";
          }
  
          my @pairs = @{ $entry || [] } or die "no format specified";
  
          while ( my ( $format, $src ) = splice( @pairs, 0, 2 ) ) {
              if ( defined($src) and !ref($src) and $src =~ /\*/ ) {
                  unshift( @pairs, $format => $_ )
                      for File::Glob::bsd_glob($src);
                  next;
              }
  
              my @content
                  = eval { $class->lexicon_get( $src, scalar caller(1), $lang ); };
              next if $@ and $@ =~ /^next\b/;
              die $@ if $@;
  
              no strict 'refs';
              eval "use $class\::$format; 1" or die $@;
  
              if ( %{"$export\::Lexicon"} ) {
                  my $lexicon = \%{"$export\::Lexicon"};
                  if ( my $obj = tied %$lexicon ) {
  
                      # if it's our tied hash then force loading
                      # otherwise late load will rewrite
                      $obj->_force if $obj->isa(__PACKAGE__);
                  }
  
                  # clear the memoized cache for old entries:
                  Locale::Maketext->clear_isa_scan;
  
                  my $new = "$class\::$format"->parse(@content);
  
                  # avoid hash rebuild, on big sets
                  @{$lexicon}{ keys %$new } = values %$new;
              }
              else {
                  local $^W if $] >= 5.009;    # no warnings 'once', really.
                  tie %{"$export\::Lexicon"}, __PACKAGE__,
                      {
                      Opts    => $OptsRef,
                      Export  => "$export\::Lexicon",
                      Class   => "$class\::$format",
                      Content => \@content,
                      };
                  tied( %{"$export\::Lexicon"} )->_force
                      if $OptsRef->{'preload'};
              }
  
              length $lang or next;
  
              # Avoid re-entry
              my $caller = caller();
              next if $export->isa($caller);
  
              push( @{"$export\::ISA"}, scalar caller );
  
              if ( my $style = option('style') ) {
                  my $cref
                      = $class->can( lc("_style_$style") )
                      ->( $class, $export->can('maketext') )
                      or die "Unknown style: $style";
  
                  # Avoid redefinition warnings
                  local $SIG{__WARN__} = sub {1};
                  *{"$export\::maketext"} = $cref;
              }
          }
      }
  }
  
  sub _style_gettext {
      my ( $self, $orig ) = @_;
  
      require Locale::Maketext::Lexicon::Gettext;
  
      sub {
          my $lh  = shift;
          my $str = shift;
          return $orig->(
              $lh,
              Locale::Maketext::Lexicon::Gettext::_gettext_to_maketext($str), @_
          );
          }
  }
  
  sub TIEHASH {
      my ( $class, $args ) = @_;
      return bless( $args, $class );
  
  }
  
  {
      no strict 'refs';
  
      sub _force {
          my $args = shift;
          unless ( $args->{'Done'} ) {
              $args->{'Done'} = 1;
              local *Opts = $args->{Opts};
              *{ $args->{Export} }
                  = $args->{Class}->parse( @{ $args->{Content} } );
              $args->{'Export'}{'_AUTO'} = 1
                  if option('auto');
          }
          return $args->{'Export'};
      }
      sub FETCH   { _force( $_[0] )->{ $_[1] } }
      sub EXISTS  { _force( $_[0] )->{ $_[1] } }
      sub DELETE  { delete _force( $_[0] )->{ $_[1] } }
      sub SCALAR  { scalar %{ _force( $_[0] ) } }
      sub STORE   { _force( $_[0] )->{ $_[1] } = $_[2] }
      sub CLEAR   { %{ _force( $_[0] )->{ $_[1] } } = () }
      sub NEXTKEY { each %{ _force( $_[0] ) } }
  
      sub FIRSTKEY {
          my $hash = _force( $_[0] );
          my $a    = scalar keys %$hash;
          each %$hash;
      }
  }
  
  sub lexicon_get {
      my ( $class, $src, $caller, $lang ) = @_;
      return unless defined $src;
  
      foreach my $type ( qw(ARRAY HASH SCALAR GLOB), ref($src) ) {
          next unless UNIVERSAL::isa( $src, $type );
  
          my $method = 'lexicon_get_' . lc($type);
          die "cannot handle source $type for $src: no $method defined"
              unless $class->can($method);
  
          return $class->$method( $src, $caller, $lang );
      }
  
      # default handler
      return $class->lexicon_get_( $src, $caller, $lang );
  }
  
  # for scalarrefs and arrayrefs we just dereference the $src
  sub lexicon_get_scalar { ${ $_[1] } }
  sub lexicon_get_array  { @{ $_[1] } }
  
  sub lexicon_get_hash {
      my ( $class, $src, $caller, $lang ) = @_;
      return map { $_ => $src->{$_} } sort keys %$src;
  }
  
  sub lexicon_get_glob {
      my ( $class, $src, $caller, $lang ) = @_;
  
      no strict 'refs';
      local $^W if $] >= 5.009;    # no warnings 'once', really.
  
      # be extra magical and check for DATA section
      if ( eof($src) and $src eq \*{"$caller\::DATA"}
          or $src eq \*{"main\::DATA"} )
      {
  
          # okay, the *DATA isn't initiated yet. let's read.
          #
          require FileHandle;
          my $fh = FileHandle->new;
          my $package = ( ( $src eq \*{"main\::DATA"} ) ? 'main' : $caller );
  
          if ( $package eq 'main' and -e $0 ) {
              $fh->open($0) or die "Can't open $0: $!";
          }
          else {
              my $level = 1;
              while ( my ( $pkg, $filename ) = caller( $level++ ) ) {
                  next unless $pkg eq $package;
                  next unless -e $filename;
                  next;
  
                  $fh->open($filename) or die "Can't open $filename: $!";
                  last;
              }
          }
  
          while (<$fh>) {
  
              # okay, this isn't foolproof, but good enough
              last if /^__DATA__$/;
          }
  
          return <$fh>;
      }
  
      # fh containing the lines
      my $pos   = tell($src);
      my @lines = <$src>;
      seek( $src, $pos, 0 );
      return @lines;
  }
  
  # assume filename - search path, open and return its contents
  sub lexicon_get_ {
      my ( $class, $src, $caller, $lang ) = @_;
      $src = $class->lexicon_find( $src, $caller, $lang );
      defined $src or die 'next';
  
      require FileHandle;
      my $fh = FileHandle->new;
      $fh->open($src) or die "Cannot read $src (called by $caller): $!";
      binmode($fh);
      return <$fh>;
  }
  
  sub lexicon_find {
      my ( $class, $src, $caller, $lang ) = @_;
      return $src if -e $src;
  
      require File::Spec;
  
      my @path = split '::', $caller;
      push @path, $lang if length $lang;
  
      while (@path) {
          foreach (@INC) {
              my $file = File::Spec->catfile( $_, @path, $src );
              return $file if -e $file;
          }
          pop @path;
      }
  
      return undef;
  }
  
  1;
  
  =head1 ACKNOWLEDGMENTS
  
  Thanks to Jesse Vincent for suggesting this module to be written.
  
  Thanks also to Sean M. Burke for coming up with B<Locale::Maketext>
  in the first place, and encouraging me to experiment with alternative
  Lexicon syntaxes.
  
  Thanks also to Yi Ma Mao for providing the MO file parsing subroutine,
  as well as inspiring me to implement file globbing and transcoding
  support.
  
  See the F<AUTHORS> file in the distribution for a list of people who
  have sent helpful patches, ideas or comments.
  
  =head1 SEE ALSO
  
  L<xgettext.pl> for extracting translatable strings from common template
  systems and perl source files.
  
  L<Locale::Maketext>, L<Locale::Maketext::Lexicon::Auto>,
  L<Locale::Maketext::Lexicon::Gettext>, L<Locale::Maketext::Lexicon::Msgcat>,
  L<Locale::Maketext::Lexicon::Tie>
  
  =head1 AUTHORS
  
  Audrey Tang E<lt>cpan@audreyt.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2002-2008 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
LOCALE_MAKETEXT_LEXICON

$fatpacked{"Locale/Maketext/Lexicon/Auto.pm"} = <<'LOCALE_MAKETEXT_LEXICON_AUTO';
  package Locale::Maketext::Lexicon::Auto;
  $Locale::Maketext::Lexicon::Auto::VERSION = '0.10';
  
  use strict;
  
  =head1 NAME
  
  Locale::Maketext::Lexicon::Auto - Auto fallback lexicon for Maketext
  
  =head1 SYNOPSIS
  
      package Hello::I18N;
      use base 'Locale::Maketext';
      use Locale::Maketext::Lexicon {
          en => ['Auto'],
          # ... other languages
      };
  
  =head1 DESCRIPTION
  
  This module builds a simple Lexicon hash that contains nothing but
  C<( '_AUTO' =E<gt> 1)>, which tells C<Locale::Maketext> that no
  localizing is needed -- just use the lookup key as the returned string.
  
  It is especially useful if you're starting to prototype a program, and
  do not want to deal with the localization files yet.
  
  =head1 CAVEATS
  
  If the key to C<-E<gt>maketext> begins with a C<_>, C<Locale::Maketext>
  will still throw an exception.  See L<Locale::Maketext/CONTROLLING LOOKUP
  FAILURE> for how to prevent it.
  
  =cut
  
  sub parse {
      +{ _AUTO => 1 };
  }
  
  1;
  
  =head1 SEE ALSO
  
  L<Locale::Maketext>, L<Locale::Maketext::Lexicon>
  
  =head1 AUTHORS
  
  Audrey Tang E<lt>cpan@audreyt.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2002, 2003, 2004, 2007 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
LOCALE_MAKETEXT_LEXICON_AUTO

$fatpacked{"Locale/Maketext/Lexicon/Gettext.pm"} = <<'LOCALE_MAKETEXT_LEXICON_GETTEXT';
  package Locale::Maketext::Lexicon::Gettext;
  $Locale::Maketext::Lexicon::Gettext::VERSION = '0.17';
  
  use strict;
  
  =head1 NAME
  
  Locale::Maketext::Lexicon::Gettext - PO and MO file parser for Maketext
  
  =head1 SYNOPSIS
  
  Called via B<Locale::Maketext::Lexicon>:
  
      package Hello::I18N;
      use base 'Locale::Maketext';
      use Locale::Maketext::Lexicon {
          de => [Gettext => 'hello/de.mo'],
      };
  
  Directly calling C<parse()>:
  
      use Locale::Maketext::Lexicon::Gettext;
      my %Lexicon = %{ Locale::Maketext::Lexicon::Gettext->parse(<DATA>) };
      __DATA__
      #: Hello.pm:10
      msgid "Hello, World!"
      msgstr "Hallo, Welt!"
  
      #: Hello.pm:11
      msgid "You have %quant(%1,piece) of mail."
      msgstr "Sie haben %quant(%1,Poststueck,Poststuecken)."
  
  =head1 DESCRIPTION
  
  This module implements a perl-based C<Gettext> parser for
  B<Locale::Maketext>. It transforms all C<%1>, C<%2>, <%*>... sequences
  to C<[_1]>, C<[_2]>, C<[_*]>, and so on.  It accepts either plain PO
  file, or a MO file which will be handled with a pure-perl parser
  adapted from Imacat's C<Locale::Maketext::Gettext>.
  
  Since version 0.03, this module also looks for C<%I<function>(I<args...>)>
  in the lexicon strings, and transform it to C<[I<function>,I<args...>]>.
  Any C<%1>, C<%2>... sequences inside the I<args> will have their percent
  signs (C<%>) replaced by underscores (C<_>).
  
  The name of I<function> above should begin with a letter or underscore,
  followed by any number of alphanumeric characters and/or underscores.
  As an exception, the function name may also consist of a single asterisk
  (C<*>) or pound sign (C<#>), which are C<Locale::Maketext>'s shorthands
  for C<quant> and C<numf>, respectively.
  
  As an additional feature, this module also parses MIME-header style
  metadata specified in the null msgstr (C<"">), and add them to the
  C<%Lexicon> with a C<__> prefix.  For example, the example above will
  set C<__Content-Type> to C<text/plain; charset=iso8859-1>, without
  the newline or the colon.
  
  Any normal entry that duplicates a metadata entry takes precedence.
  Hence, a C<msgid "__Content-Type"> line occurs anywhere should override
  the above value.
  
  =head1 OPTIONS
  
  =head2 use_fuzzy
  
  When parsing PO files, fuzzy entries (entries marked with C<#, fuzzy>)
  are silently ignored.  If you wish to use fuzzy entries, specify a true
  value to the C<_use_fuzzy> option:
  
      use Locale::Maketext::Lexicon {
          de => [Gettext => 'hello/de.mo'],
          _use_fuzzy => 1,
      };
  
  =head2 allow_empty
  
  When parsing PO files, empty entries (entries with C<msgstr "">) are
  silently ignored.  If you wish to allow empty entries, specify a true
  value to the C<_allow_empty> option:
  
      use Locale::Maketext::Lexicon {
          de => [Gettext => 'hello/de.mo'],
          _allow_empty => 1,
      };
  
  =cut
  
  my ( $InputEncoding, $OutputEncoding, $DoEncoding );
  
  sub input_encoding  {$InputEncoding}
  sub output_encoding {$OutputEncoding}
  
  sub parse {
      my $self = shift;
      my ( %var, $key, @ret );
      my @metadata;
      my @comments;
      my @fuzzy;
  
      $InputEncoding = $OutputEncoding = $DoEncoding = undef;
  
      use Carp;
      Carp::cluck "Undefined source called\n" unless defined $_[0];
  
      # Check for magic string of MO files
      return parse_mo( join( '', @_ ) )
          if ( $_[0] =~ /^\x95\x04\x12\xde/ or $_[0] =~ /^\xde\x12\x04\x95/ );
  
      local $^W;    # no 'uninitialized' warnings, please.
  
      require Locale::Maketext::Lexicon;
      my $KeepFuzzy = Locale::Maketext::Lexicon::option('keep_fuzzy');
      my $UseFuzzy  = $KeepFuzzy
          || Locale::Maketext::Lexicon::option('use_fuzzy');
      my $AllowEmpty = Locale::Maketext::Lexicon::option('allow_empty');
      my $process    = sub {
          if ( length( $var{msgstr} ) and ( $UseFuzzy or !$var{fuzzy} ) ) {
              push @ret, ( map transform($_), @var{ 'msgid', 'msgstr' } );
          }
          elsif ($AllowEmpty) {
              push @ret, ( transform( $var{msgid} ), '' );
          }
          if ( $var{msgid} eq '' ) {
              push @metadata, parse_metadata( $var{msgstr} );
          }
          else {
              push @comments, $var{msgid}, $var{msgcomment};
          }
          if ( $KeepFuzzy && $var{fuzzy} ) {
              push @fuzzy, $var{msgid}, 1;
          }
          %var = ();
      };
  
      # Parse PO files
      foreach (@_) {
          s/[\015\012]*\z//;                  # fix CRLF issues
  
          /^(msgid|msgstr) +"(.*)" *$/
              ? do {                          # leading strings
              $var{$1} = $2;
              $key = $1;
              }
              :
  
              /^"(.*)" *$/
              ? do {                          # continued strings
              $var{$key} .= $1;
              }
              :
  
              /^# (.*)$/
              ? do {                          # user comments
              $var{msgcomment} .= $1 . "\n";
              }
              :
  
              /^#, +(.*) *$/
              ? do {                          # control variables
              $var{$_} = 1 for split( /,\s+/, $1 );
              }
              :
  
              /^ *$/ && %var
              ? do {                          # interpolate string escapes
              $process->($_);
              }
              : ();
  
      }
  
      # do not silently skip last entry
      $process->() if keys %var != 0;
  
      push @ret, map { transform($_) } @var{ 'msgid', 'msgstr' }
          if length $var{msgstr};
      push @metadata, parse_metadata( $var{msgstr} )
          if $var{msgid} eq '';
  
      return wantarray
          ? ( { @metadata, @ret }, {@comments}, {@fuzzy} )
          : ( { @metadata, @ret } );
  
  }
  
  sub parse_metadata {
      return map {
                (/^([^\x00-\x1f\x80-\xff :=]+):\s*(.*)$/)
              ? ( $1 eq 'Content-Type' )
                  ? do {
                      my $enc = $2;
                      if ( $enc =~ /\bcharset=\s*([-\w]+)/i ) {
                          $InputEncoding = $1 || '';
                          $OutputEncoding
                              = Locale::Maketext::Lexicon::encoding()
                              || '';
                          $InputEncoding = 'utf8'
                              if $InputEncoding =~ /^utf-?8$/i;
                          $OutputEncoding = 'utf8'
                              if $OutputEncoding =~ /^utf-?8$/i;
                          if ( Locale::Maketext::Lexicon::option('decode')
                               and (   !$OutputEncoding
                                     or $InputEncoding ne $OutputEncoding )
                              )
                          {
                              require Encode::compat if $] < 5.007001;
                              require Encode;
                              $DoEncoding = 1;
                          }
                      }
                      ( "__Content-Type", $enc );
                  }
                  : ( "__$1", $2 )
              : ();
      } split( /\r*\n+\r*/, transform(pop) );
  }
  
  sub transform {
      my $str = shift;
  
      if ( $DoEncoding and $InputEncoding ) {
          $str
              = ( $InputEncoding eq 'utf8' )
              ? Encode::decode_utf8($str)
              : Encode::decode( $InputEncoding, $str );
      }
  
      $str =~ s/\\([0x]..|c?.)/qq{"\\$1"}/eeg;
  
      if ( $DoEncoding and $OutputEncoding ) {
          $str
              = ( $OutputEncoding eq 'utf8' )
              ? Encode::encode_utf8($str)
              : Encode::encode( $OutputEncoding, $str );
      }
  
      return _gettext_to_maketext($str);
  }
  
  sub _gettext_to_maketext {
      my $str = shift;
      $str =~ s{([\~\[\]])}{~$1}g;
      $str =~ s{
          ([%\\]%)                        # 1 - escaped sequence
      |
          %   (?:
                  ([A-Za-z#*]\w*)         # 2 - function call
                      \(([^\)]*)\)        # 3 - arguments
              |
                  ([1-9]\d*|\*)           # 4 - variable
              )
      }{
          $1 ? $1
             : $2 ? "\[$2,"._unescape($3)."]"
                  : "[_$4]"
      }egx;
      $str;
  }
  
  sub _unescape {
      join( ',',
            map { /\A(\s*)%([1-9]\d*|\*)(\s*)\z/ ? "$1_$2$3" : $_ }
                split( /,/, $_[0] ) );
  }
  
  # This subroutine was derived from Locale::Maketext::Gettext::readmo()
  # under the Perl License; the original author is Yi Ma Mao (IMACAT).
  sub parse_mo {
      my $content = shift;
      my $tmpl = ( substr( $content, 0, 4 ) eq "\xde\x12\x04\x95" ) ? 'V' : 'N';
  
      # Check the MO format revision number
      # There is only one revision now: revision 0.
      return if unpack( $tmpl, substr( $content, 4, 4 ) ) > 0;
  
      my ( $num, $offo, $offt );
  
      # Number of strings
      $num = unpack $tmpl, substr( $content, 8, 4 );
  
      # Offset to the beginning of the original strings
      $offo = unpack $tmpl, substr( $content, 12, 4 );
  
      # Offset to the beginning of the translated strings
      $offt = unpack $tmpl, substr( $content, 16, 4 );
  
      my ( @metadata, @ret );
      for ( 0 .. $num - 1 ) {
          my ( $len, $off, $stro, $strt );
  
          # The first word is the length of the string
          $len = unpack $tmpl, substr( $content, $offo + $_ * 8, 4 );
  
          # The second word is the offset of the string
          $off = unpack $tmpl, substr( $content, $offo + $_ * 8 + 4, 4 );
  
          # Original string
          $stro = substr( $content, $off, $len );
  
          # The first word is the length of the string
          $len = unpack $tmpl, substr( $content, $offt + $_ * 8, 4 );
  
          # The second word is the offset of the string
          $off = unpack $tmpl, substr( $content, $offt + $_ * 8 + 4, 4 );
  
          # Translated string
          $strt = substr( $content, $off, $len );
  
          # Hash it
          push @metadata, parse_metadata($strt) if $stro eq '';
          push @ret, ( map transform($_), $stro, $strt ) if length $strt;
      }
  
      return { @metadata, @ret };
  }
  
  1;
  
  =head1 SEE ALSO
  
  L<Locale::Maketext>, L<Locale::Maketext::Lexicon>
  
  =head1 AUTHORS
  
  Audrey Tang E<lt>cpan@audreyt.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2002, 2003, 2004, 2007 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
LOCALE_MAKETEXT_LEXICON_GETTEXT

$fatpacked{"Locale/Maketext/Lexicon/Msgcat.pm"} = <<'LOCALE_MAKETEXT_LEXICON_MSGCAT';
  package Locale::Maketext::Lexicon::Msgcat;
  $Locale::Maketext::Lexicon::Msgcat::VERSION = '0.03';
  
  use strict;
  
  =head1 NAME
  
  Locale::Maketext::Lexicon::Msgcat - Msgcat catalog parser Maketext
  
  =head1 SYNOPSIS
  
      package Hello::I18N;
      use base 'Locale::Maketext';
      use Locale::Maketext::Lexicon {
          en => ['Msgcat', 'en_US/hello.pl.m'],
      };
  
      package main;
      my $lh = Hello::I18N->get_handle('en');
      print $lh->maketext(1,2);   # set 1, msg 2
      print $lh->maketext("1,2"); # same thing
  
  =head1 DESCRIPTION
  
  This module parses one or more Msgcat catalogs in plain text format,
  and returns a Lexicon hash, which may be looked up either with a
  two-argument form (C<$set_id, $msg_id>) or as a single string
  (C<"$set_id,$msg_id">).
  
  =head1 NOTES
  
  All special characters (C<[>, C<]> and C<~>) in catalogs will be
  escaped so they lose their magic meanings.  That means C<-E<gt>maketext>
  calls to this lexicon will I<not> take any additional arguments.
  
  =cut
  
  sub parse {
      my $set = 0;
      my $msg = undef;
      my ($qr, $qq, $qc) = (qr//, '', '');
      my @out;
  
      # Set up the msgcat handler
      {
          no strict 'refs';
          no warnings 'once';
          *{Locale::Maketext::msgcat} = \&_msgcat;
      }
  
      # Parse *.m files; Locale::Msgcat objects and *.cat are not yet supported.
      foreach (@_) {
          s/[\015\012]*\z//;    # fix CRLF issues
  
          /^\$set (\d+)/
            ? do {              # set_id
              $set = int($1);
              push @out, $1, "[msgcat,$1,_1]";
            }
            :
  
            /^\$quote (.)/
            ? do {              # quote character
              $qc = $1;
              $qq = quotemeta($1);
              $qr = qr/$qq?/;
            }
            :
  
            /^(\d+) ($qr)(.*?)\2(\\?)$/
            ? do {              # msg_id and msg_str
              local $^W;
              push @out, "$set," . int($1);
              if ($4) {
                  $msg = $3;
              }
              else {
                  push @out, unescape($qq, $qc, $3);
                  undef $msg;
              }
            }
            :
  
            (defined $msg and /^($qr)(.*?)\1(\\?)$/)
            ? do {    # continued string
              local $^W;
              if ($3) {
                  $msg .= $2;
              }
              else {
                  push @out, unescape($qq, $qc, $msg . $2);
                  undef $msg;
              }
            }
            : ();
      }
  
      push @out, '' if defined $msg;
  
      return {@out};
  }
  
  sub _msgcat {
      my ($self, $set_id, $msg_id, @args) = @_;
      return $self->maketext(int($set_id) . ',' . int($msg_id), @args);
  }
  
  sub unescape {
      my ($qq, $qc, $str) = @_;
      $str =~ s/(\\([ntvbrf\\$qq]))/($2 eq $qc) ? $qc : eval qq("$1")/e;
      $str =~ s/([\~\[\]])/~$1/g;
      return $str;
  }
  
  1;
  
  =head1 SEE ALSO
  
  L<Locale::Maketext>, L<Locale::Maketext::Lexicon>
  
  =head1 AUTHORS
  
  Audrey Tang E<lt>cpan@audreyt.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2002, 2003, 2004, 2007 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
LOCALE_MAKETEXT_LEXICON_MSGCAT

$fatpacked{"Locale/Maketext/Lexicon/Tie.pm"} = <<'LOCALE_MAKETEXT_LEXICON_TIE';
  package Locale::Maketext::Lexicon::Tie;
  $Locale::Maketext::Lexicon::Tie::VERSION = '0.05';
  
  use strict;
  use Symbol ();
  
  =head1 NAME
  
  Locale::Maketext::Lexicon::Tie - Use tied hashes as lexicons for Maketext
  
  =head1 SYNOPSIS
  
      package Hello::I18N;
      use base 'Locale::Maketext';
      use Locale::Maketext::Lexicon {
          en => [ Tie => [ DB_File => 'en.db' ] ],
      };
  
  =head1 DESCRIPTION
  
  This module lets you easily C<tie> the C<%Lexicon> hash to a database
  or other data sources.  It takes an array reference of arguments, and
  passes them directly to C<tie()>.
  
  Entries will then be fetched whenever it is used; this module does not
  cache them.
  
  =cut
  
  sub parse {
      my $self = shift;
      my $mod  = shift;
      my $sym  = Symbol::gensym();
  
      # Load the target module into memory
      {
          no strict 'refs';
          eval "use $mod; 1" or die $@ unless %{"$mod\::"};
      }
  
      # Perform the actual tie
      tie %{*$sym}, $mod, @_;
  
      # Returns the GLOB reference, so %Lexicon will be tied too
      return $sym;
  }
  
  1;
  
  =head1 SEE ALSO
  
  L<Locale::Maketext>, L<Locale::Maketext::Lexicon>
  
  =head1 AUTHORS
  
  Audrey Tang E<lt>cpan@audreyt.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2002, 2003, 2004, 2007 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
LOCALE_MAKETEXT_LEXICON_TIE

$fatpacked{"darwin-2level/Cwd.pm"} = <<'DARWIN-2LEVEL_CWD';
  package Cwd;
  
  =head1 NAME
  
  Cwd - get pathname of current working directory
  
  =head1 SYNOPSIS
  
      use Cwd;
      my $dir = getcwd;
  
      use Cwd 'abs_path';
      my $abs_path = abs_path($file);
  
  =head1 DESCRIPTION
  
  This module provides functions for determining the pathname of the
  current working directory.  It is recommended that getcwd (or another
  *cwd() function) be used in I<all> code to ensure portability.
  
  By default, it exports the functions cwd(), getcwd(), fastcwd(), and
  fastgetcwd() (and, on Win32, getdcwd()) into the caller's namespace.  
  
  
  =head2 getcwd and friends
  
  Each of these functions are called without arguments and return the
  absolute path of the current working directory.
  
  =over 4
  
  =item getcwd
  
      my $cwd = getcwd();
  
  Returns the current working directory.
  
  Exposes the POSIX function getcwd(3) or re-implements it if it's not
  available.
  
  =item cwd
  
      my $cwd = cwd();
  
  The cwd() is the most natural form for the current architecture. For
  most systems it is identical to `pwd` (but without the trailing line
  terminator).
  
  =item fastcwd
  
      my $cwd = fastcwd();
  
  A more dangerous version of getcwd(), but potentially faster.
  
  It might conceivably chdir() you out of a directory that it can't
  chdir() you back into.  If fastcwd encounters a problem it will return
  undef but will probably leave you in a different directory.  For a
  measure of extra security, if everything appears to have worked, the
  fastcwd() function will check that it leaves you in the same directory
  that it started in. If it has changed it will C<die> with the message
  "Unstable directory path, current directory changed
  unexpectedly". That should never happen.
  
  =item fastgetcwd
  
    my $cwd = fastgetcwd();
  
  The fastgetcwd() function is provided as a synonym for cwd().
  
  =item getdcwd
  
      my $cwd = getdcwd();
      my $cwd = getdcwd('C:');
  
  The getdcwd() function is also provided on Win32 to get the current working
  directory on the specified drive, since Windows maintains a separate current
  working directory for each drive.  If no drive is specified then the current
  drive is assumed.
  
  This function simply calls the Microsoft C library _getdcwd() function.
  
  =back
  
  
  =head2 abs_path and friends
  
  These functions are exported only on request.  They each take a single
  argument and return the absolute pathname for it.  If no argument is
  given they'll use the current working directory.
  
  =over 4
  
  =item abs_path
  
    my $abs_path = abs_path($file);
  
  Uses the same algorithm as getcwd().  Symbolic links and relative-path
  components ("." and "..") are resolved to return the canonical
  pathname, just like realpath(3).
  
  =item realpath
  
    my $abs_path = realpath($file);
  
  A synonym for abs_path().
  
  =item fast_abs_path
  
    my $abs_path = fast_abs_path($file);
  
  A more dangerous, but potentially faster version of abs_path.
  
  =back
  
  =head2 $ENV{PWD}
  
  If you ask to override your chdir() built-in function, 
  
    use Cwd qw(chdir);
  
  then your PWD environment variable will be kept up to date.  Note that
  it will only be kept up to date if all packages which use chdir import
  it from Cwd.
  
  
  =head1 NOTES
  
  =over 4
  
  =item *
  
  Since the path seperators are different on some operating systems ('/'
  on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec
  modules wherever portability is a concern.
  
  =item *
  
  Actually, on Mac OS, the C<getcwd()>, C<fastgetcwd()> and C<fastcwd()>
  functions  are all aliases for the C<cwd()> function, which, on Mac OS,
  calls `pwd`. Likewise, the C<abs_path()> function is an alias for
  C<fast_abs_path()>.
  
  =back
  
  =head1 AUTHOR
  
  Originally by the perl5-porters.
  
  Maintained by Ken Williams <KWILLIAMS@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Portions of the C code in this library are copyright (c) 1994 by the
  Regents of the University of California.  All rights reserved.  The
  license on this code is compatible with the licensing of the rest of
  the distribution - please see the source code in F<Cwd.xs> for the
  details.
  
  =head1 SEE ALSO
  
  L<File::chdir>
  
  =cut
  
  use strict;
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
  
  $VERSION = '3.33';
  my $xs_version = $VERSION;
  $VERSION = eval $VERSION;
  
  @ISA = qw/ Exporter /;
  @EXPORT = qw(cwd getcwd fastcwd fastgetcwd);
  push @EXPORT, qw(getdcwd) if $^O eq 'MSWin32';
  @EXPORT_OK = qw(chdir abs_path fast_abs_path realpath fast_realpath);
  
  # sys_cwd may keep the builtin command
  
  # All the functionality of this module may provided by builtins,
  # there is no sense to process the rest of the file.
  # The best choice may be to have this in BEGIN, but how to return from BEGIN?
  
  if ($^O eq 'os2') {
      local $^W = 0;
  
      *cwd                = defined &sys_cwd ? \&sys_cwd : \&_os2_cwd;
      *getcwd             = \&cwd;
      *fastgetcwd         = \&cwd;
      *fastcwd            = \&cwd;
  
      *fast_abs_path      = \&sys_abspath if defined &sys_abspath;
      *abs_path           = \&fast_abs_path;
      *realpath           = \&fast_abs_path;
      *fast_realpath      = \&fast_abs_path;
  
      return 1;
  }
  
  # Need to look up the feature settings on VMS.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_vms_feature;
  BEGIN {
      if ($^O eq 'VMS') {
          if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
              $use_vms_feature = 1;
          }
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _vms_unix_rpt {
      my $unix_rpt;
      if ($use_vms_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  # Need to look up the EFS character set mode.  This may become a dynamic
  # mode in the future.
  sub _vms_efs {
      my $efs;
      if ($use_vms_feature) {
          $efs = VMS::Feature::current("efs_charset");
      } else {
          my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
          $efs = $env_efs =~ /^[ET1]/i; 
      }
      return $efs;
  }
  
  
  # If loading the XS stuff doesn't work, we can fall back to pure perl
  eval {
    if ( $] >= 5.006 ) {
      require XSLoader;
      XSLoader::load( __PACKAGE__, $xs_version);
    } else {
      require DynaLoader;
      push @ISA, 'DynaLoader';
      __PACKAGE__->bootstrap( $xs_version );
    }
  };
  
  # Must be after the DynaLoader stuff:
  $VERSION = eval $VERSION;
  
  # Big nasty table of function aliases
  my %METHOD_MAP =
    (
     VMS =>
     {
      cwd			=> '_vms_cwd',
      getcwd		=> '_vms_cwd',
      fastcwd		=> '_vms_cwd',
      fastgetcwd		=> '_vms_cwd',
      abs_path		=> '_vms_abs_path',
      fast_abs_path	=> '_vms_abs_path',
     },
  
     MSWin32 =>
     {
      # We assume that &_NT_cwd is defined as an XSUB or in the core.
      cwd			=> '_NT_cwd',
      getcwd		=> '_NT_cwd',
      fastcwd		=> '_NT_cwd',
      fastgetcwd		=> '_NT_cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     dos => 
     {
      cwd			=> '_dos_cwd',
      getcwd		=> '_dos_cwd',
      fastgetcwd		=> '_dos_cwd',
      fastcwd		=> '_dos_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     # QNX4.  QNX6 has a $os of 'nto'.
     qnx =>
     {
      cwd			=> '_qnx_cwd',
      getcwd		=> '_qnx_cwd',
      fastgetcwd		=> '_qnx_cwd',
      fastcwd		=> '_qnx_cwd',
      abs_path		=> '_qnx_abs_path',
      fast_abs_path	=> '_qnx_abs_path',
     },
  
     cygwin =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     epoc =>
     {
      cwd			=> '_epoc_cwd',
      getcwd	        => '_epoc_cwd',
      fastgetcwd		=> '_epoc_cwd',
      fastcwd		=> '_epoc_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     MacOS =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
     },
    );
  
  $METHOD_MAP{NT} = $METHOD_MAP{MSWin32};
  
  
  # Find the pwd command in the expected locations.  We assume these
  # are safe.  This prevents _backtick_pwd() consulting $ENV{PATH}
  # so everything works under taint mode.
  my $pwd_cmd;
  foreach my $try ('/bin/pwd',
  		 '/usr/bin/pwd',
  		 '/QOpenSys/bin/pwd', # OS/400 PASE.
  		) {
  
      if( -x $try ) {
          $pwd_cmd = $try;
          last;
      }
  }
  my $found_pwd_cmd = defined($pwd_cmd);
  unless ($pwd_cmd) {
      # Isn't this wrong?  _backtick_pwd() will fail if somenone has
      # pwd in their path but it is not /bin/pwd or /usr/bin/pwd?
      # See [perl #16774]. --jhi
      $pwd_cmd = 'pwd';
  }
  
  # Lazy-load Carp
  sub _carp  { require Carp; Carp::carp(@_)  }
  sub _croak { require Carp; Carp::croak(@_) }
  
  # The 'natural and safe form' for UNIX (pwd may be setuid root)
  sub _backtick_pwd {
      # Localize %ENV entries in a way that won't create new hash keys
      my @localize = grep exists $ENV{$_}, qw(PATH IFS CDPATH ENV BASH_ENV);
      local @ENV{@localize};
      
      my $cwd = `$pwd_cmd`;
      # Belt-and-suspenders in case someone said "undef $/".
      local $/ = "\n";
      # `pwd` may fail e.g. if the disk is full
      chomp($cwd) if defined $cwd;
      $cwd;
  }
  
  # Since some ports may predefine cwd internally (e.g., NT)
  # we take care not to override an existing definition for cwd().
  
  unless ($METHOD_MAP{$^O}{cwd} or defined &cwd) {
      # The pwd command is not available in some chroot(2)'ed environments
      my $sep = $Config::Config{path_sep} || ':';
      my $os = $^O;  # Protect $^O from tainting
  
  
      # Try again to find a pwd, this time searching the whole PATH.
      if (defined $ENV{PATH} and $os ne 'MSWin32') {  # no pwd on Windows
  	my @candidates = split($sep, $ENV{PATH});
  	while (!$found_pwd_cmd and @candidates) {
  	    my $candidate = shift @candidates;
  	    $found_pwd_cmd = 1 if -x "$candidate/pwd";
  	}
      }
  
      # MacOS has some special magic to make `pwd` work.
      if( $os eq 'MacOS' || $found_pwd_cmd )
      {
  	*cwd = \&_backtick_pwd;
      }
      else {
  	*cwd = \&getcwd;
      }
  }
  
  if ($^O eq 'cygwin') {
    # We need to make sure cwd() is called with no args, because it's
    # got an arg-less prototype and will die if args are present.
    local $^W = 0;
    my $orig_cwd = \&cwd;
    *cwd = sub { &$orig_cwd() }
  }
  
  
  # set a reasonable (and very safe) default for fastgetcwd, in case it
  # isn't redefined later (20001212 rspier)
  *fastgetcwd = \&cwd;
  
  # A non-XS version of getcwd() - also used to bootstrap the perl build
  # process, when miniperl is running and no XS loading happens.
  sub _perl_getcwd
  {
      abs_path('.');
  }
  
  # By John Bazik
  #
  # Usage: $cwd = &fastcwd;
  #
  # This is a faster version of getcwd.  It's also more dangerous because
  # you might chdir out of a directory that you can't chdir back into.
      
  sub fastcwd_ {
      my($odev, $oino, $cdev, $cino, $tdev, $tino);
      my(@path, $path);
      local(*DIR);
  
      my($orig_cdev, $orig_cino) = stat('.');
      ($cdev, $cino) = ($orig_cdev, $orig_cino);
      for (;;) {
  	my $direntry;
  	($odev, $oino) = ($cdev, $cino);
  	CORE::chdir('..') || return undef;
  	($cdev, $cino) = stat('.');
  	last if $odev == $cdev && $oino == $cino;
  	opendir(DIR, '.') || return undef;
  	for (;;) {
  	    $direntry = readdir(DIR);
  	    last unless defined $direntry;
  	    next if $direntry eq '.';
  	    next if $direntry eq '..';
  
  	    ($tdev, $tino) = lstat($direntry);
  	    last unless $tdev != $odev || $tino != $oino;
  	}
  	closedir(DIR);
  	return undef unless defined $direntry; # should never happen
  	unshift(@path, $direntry);
      }
      $path = '/' . join('/', @path);
      if ($^O eq 'apollo') { $path = "/".$path; }
      # At this point $path may be tainted (if tainting) and chdir would fail.
      # Untaint it then check that we landed where we started.
      $path =~ /^(.*)\z/s		# untaint
  	&& CORE::chdir($1) or return undef;
      ($cdev, $cino) = stat('.');
      die "Unstable directory path, current directory changed unexpectedly"
  	if $cdev != $orig_cdev || $cino != $orig_cino;
      $path;
  }
  if (not defined &fastcwd) { *fastcwd = \&fastcwd_ }
  
  
  # Keeps track of current working directory in PWD environment var
  # Usage:
  #	use Cwd 'chdir';
  #	chdir $newdir;
  
  my $chdir_init = 0;
  
  sub chdir_init {
      if ($ENV{'PWD'} and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32') {
  	my($dd,$di) = stat('.');
  	my($pd,$pi) = stat($ENV{'PWD'});
  	if (!defined $dd or !defined $pd or $di != $pi or $dd != $pd) {
  	    $ENV{'PWD'} = cwd();
  	}
      }
      else {
  	my $wd = cwd();
  	$wd = Win32::GetFullPathName($wd) if $^O eq 'MSWin32';
  	$ENV{'PWD'} = $wd;
      }
      # Strip an automounter prefix (where /tmp_mnt/foo/bar == /foo/bar)
      if ($^O ne 'MSWin32' and $ENV{'PWD'} =~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s) {
  	my($pd,$pi) = stat($2);
  	my($dd,$di) = stat($1);
  	if (defined $pd and defined $dd and $di == $pi and $dd == $pd) {
  	    $ENV{'PWD'}="$2$3";
  	}
      }
      $chdir_init = 1;
  }
  
  sub chdir {
      my $newdir = @_ ? shift : '';	# allow for no arg (chdir to HOME dir)
      $newdir =~ s|///*|/|g unless $^O eq 'MSWin32';
      chdir_init() unless $chdir_init;
      my $newpwd;
      if ($^O eq 'MSWin32') {
  	# get the full path name *before* the chdir()
  	$newpwd = Win32::GetFullPathName($newdir);
      }
  
      return 0 unless CORE::chdir $newdir;
  
      if ($^O eq 'VMS') {
  	return $ENV{'PWD'} = $ENV{'DEFAULT'}
      }
      elsif ($^O eq 'MacOS') {
  	return $ENV{'PWD'} = cwd();
      }
      elsif ($^O eq 'MSWin32') {
  	$ENV{'PWD'} = $newpwd;
  	return 1;
      }
  
      if (ref $newdir eq 'GLOB') { # in case a file/dir handle is passed in
  	$ENV{'PWD'} = cwd();
      } elsif ($newdir =~ m#^/#s) {
  	$ENV{'PWD'} = $newdir;
      } else {
  	my @curdir = split(m#/#,$ENV{'PWD'});
  	@curdir = ('') unless @curdir;
  	my $component;
  	foreach $component (split(m#/#, $newdir)) {
  	    next if $component eq '.';
  	    pop(@curdir),next if $component eq '..';
  	    push(@curdir,$component);
  	}
  	$ENV{'PWD'} = join('/',@curdir) || '/';
      }
      1;
  }
  
  
  sub _perl_abs_path
  {
      my $start = @_ ? shift : '.';
      my($dotdots, $cwd, @pst, @cst, $dir, @tst);
  
      unless (@cst = stat( $start ))
      {
  	_carp("stat($start): $!");
  	return '';
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
          # NOTE that this routine assumes that '/' is the only directory separator.
  	
          my ($dir, $file) = $start =~ m{^(.*)/(.+)$}
  	    or return cwd() . '/' . $start;
  	
  	# Can't use "-l _" here, because the previous stat was a stat(), not an lstat().
  	if (-l $start) {
  	    my $link_target = readlink($start);
  	    die "Can't resolve link $start: $!" unless defined $link_target;
  	    
  	    require File::Spec;
              $link_target = $dir . '/' . $link_target
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return abs_path($link_target);
  	}
  	
  	return $dir ? abs_path($dir) . "/$file" : "/$file";
      }
  
      $cwd = '';
      $dotdots = $start;
      do
      {
  	$dotdots .= '/..';
  	@pst = @cst;
  	local *PARENT;
  	unless (opendir(PARENT, $dotdots))
  	{
  	    # probably a permissions issue.  Try the native command.
  	    return File::Spec->rel2abs( $start, _backtick_pwd() );
  	}
  	unless (@cst = stat($dotdots))
  	{
  	    _carp("stat($dotdots): $!");
  	    closedir(PARENT);
  	    return '';
  	}
  	if ($pst[0] == $cst[0] && $pst[1] == $cst[1])
  	{
  	    $dir = undef;
  	}
  	else
  	{
  	    do
  	    {
  		unless (defined ($dir = readdir(PARENT)))
  	        {
  		    _carp("readdir($dotdots): $!");
  		    closedir(PARENT);
  		    return '';
  		}
  		$tst[0] = $pst[0]+1 unless (@tst = lstat("$dotdots/$dir"))
  	    }
  	    while ($dir eq '.' || $dir eq '..' || $tst[0] != $pst[0] ||
  		   $tst[1] != $pst[1]);
  	}
  	$cwd = (defined $dir ? "$dir" : "" ) . "/$cwd" ;
  	closedir(PARENT);
      } while (defined $dir);
      chop($cwd) unless $cwd eq '/'; # drop the trailing /
      $cwd;
  }
  
  
  my $Curdir;
  sub fast_abs_path {
      local $ENV{PWD} = $ENV{PWD} || ''; # Guard against clobberage
      my $cwd = getcwd();
      require File::Spec;
      my $path = @_ ? shift : ($Curdir ||= File::Spec->curdir);
  
      # Detaint else we'll explode in taint mode.  This is safe because
      # we're not doing anything dangerous with it.
      ($path) = $path =~ /(.*)/;
      ($cwd)  = $cwd  =~ /(.*)/;
  
      unless (-e $path) {
   	_croak("$path: No such file or directory");
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
  	
  	my ($vol, $dir, $file) = File::Spec->splitpath($path);
  	return File::Spec->catfile($cwd, $path) unless length $dir;
  
  	if (-l $path) {
  	    my $link_target = readlink($path);
  	    die "Can't resolve link $path: $!" unless defined $link_target;
  	    
  	    $link_target = File::Spec->catpath($vol, $dir, $link_target)
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return fast_abs_path($link_target);
  	}
  	
  	return $dir eq File::Spec->rootdir
  	  ? File::Spec->catpath($vol, $dir, $file)
  	  : fast_abs_path(File::Spec->catpath($vol, $dir, '')) . '/' . $file;
      }
  
      if (!CORE::chdir($path)) {
   	_croak("Cannot chdir to $path: $!");
      }
      my $realpath = getcwd();
      if (! ((-d $cwd) && (CORE::chdir($cwd)))) {
   	_croak("Cannot chdir back to $cwd: $!");
      }
      $realpath;
  }
  
  # added function alias to follow principle of least surprise
  # based on previous aliasing.  --tchrist 27-Jan-00
  *fast_realpath = \&fast_abs_path;
  
  
  # --- PORTING SECTION ---
  
  # VMS: $ENV{'DEFAULT'} points to default directory at all times
  # 06-Mar-1996  Charles Bailey  bailey@newman.upenn.edu
  # Note: Use of Cwd::chdir() causes the logical name PWD to be defined
  #   in the process logical name table as the default device and directory
  #   seen by Perl. This may not be the same as the default device
  #   and directory seen by DCL after Perl exits, since the effects
  #   the CRTL chdir() function persist only until Perl exits.
  
  sub _vms_cwd {
      return $ENV{'DEFAULT'};
  }
  
  sub _vms_abs_path {
      return $ENV{'DEFAULT'} unless @_;
      my $path = shift;
  
      my $efs = _vms_efs;
      my $unix_rpt = _vms_unix_rpt;
  
      if (defined &VMS::Filespec::vmsrealpath) {
          my $path_unix = 0;
          my $path_vms = 0;
  
          $path_unix = 1 if ($path =~ m#(?<=\^)/#);
          $path_unix = 1 if ($path =~ /^\.\.?$/);
          $path_vms = 1 if ($path =~ m#[\[<\]]#);
          $path_vms = 1 if ($path =~ /^--?$/);
  
          my $unix_mode = $path_unix;
          if ($efs) {
              # In case of a tie, the Unix report mode decides.
              if ($path_vms == $path_unix) {
                  $unix_mode = $unix_rpt;
              } else {
                  $unix_mode = 0 if $path_vms;
              }
          }
  
          if ($unix_mode) {
              # Unix format
              return VMS::Filespec::unixrealpath($path);
          }
  
  	# VMS format
  
  	my $new_path = VMS::Filespec::vmsrealpath($path);
  
  	# Perl expects directories to be in directory format
  	$new_path = VMS::Filespec::pathify($new_path) if -d $path;
  	return $new_path;
      }
  
      # Fallback to older algorithm if correct ones are not
      # available.
  
      if (-l $path) {
          my $link_target = readlink($path);
          die "Can't resolve link $path: $!" unless defined $link_target;
  
          return _vms_abs_path($link_target);
      }
  
      # may need to turn foo.dir into [.foo]
      my $pathified = VMS::Filespec::pathify($path);
      $path = $pathified if defined $pathified;
  	
      return VMS::Filespec::rmsexpand($path);
  }
  
  sub _os2_cwd {
      $ENV{'PWD'} = `cmd /c cd`;
      chomp $ENV{'PWD'};
      $ENV{'PWD'} =~ s:\\:/:g ;
      return $ENV{'PWD'};
  }
  
  sub _win32_cwd {
      if (eval 'defined &DynaLoader::boot_DynaLoader') {
  	$ENV{'PWD'} = Win32::GetCwd();
      }
      else { # miniperl
  	chomp($ENV{'PWD'} = `cd`);
      }
      $ENV{'PWD'} =~ s:\\:/:g ;
      return $ENV{'PWD'};
  }
  
  *_NT_cwd = defined &Win32::GetCwd ? \&_win32_cwd : \&_os2_cwd;
  
  sub _dos_cwd {
      if (!defined &Dos::GetCwd) {
          $ENV{'PWD'} = `command /c cd`;
          chomp $ENV{'PWD'};
          $ENV{'PWD'} =~ s:\\:/:g ;
      } else {
          $ENV{'PWD'} = Dos::GetCwd();
      }
      return $ENV{'PWD'};
  }
  
  sub _qnx_cwd {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      $ENV{'PWD'} = `/usr/bin/fullpath -t`;
      chomp $ENV{'PWD'};
      return $ENV{'PWD'};
  }
  
  sub _qnx_abs_path {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $path = @_ ? shift : '.';
      local *REALPATH;
  
      defined( open(REALPATH, '-|') || exec '/usr/bin/fullpath', '-t', $path ) or
        die "Can't open /usr/bin/fullpath: $!";
      my $realpath = <REALPATH>;
      close REALPATH;
      chomp $realpath;
      return $realpath;
  }
  
  sub _epoc_cwd {
      $ENV{'PWD'} = EPOC::getcwd();
      return $ENV{'PWD'};
  }
  
  
  # Now that all the base-level functions are set up, alias the
  # user-level functions to the right places
  
  if (exists $METHOD_MAP{$^O}) {
    my $map = $METHOD_MAP{$^O};
    foreach my $name (keys %$map) {
      local $^W = 0;  # assignments trigger 'subroutine redefined' warning
      no strict 'refs';
      *{$name} = \&{$map->{$name}};
    }
  }
  
  # In case the XS version doesn't load.
  *abs_path = \&_perl_abs_path unless defined &abs_path;
  *getcwd = \&_perl_getcwd unless defined &getcwd;
  
  # added function alias for those of us more
  # used to the libc function.  --tchrist 27-Jan-00
  *realpath = \&abs_path;
  
  1;
DARWIN-2LEVEL_CWD

$fatpacked{"darwin-2level/Data/Dumper.pm"} = <<'DARWIN-2LEVEL_DATA_DUMPER';
  #
  # Data/Dumper.pm
  #
  # convert perl data structures into perl syntax suitable for both printing
  # and eval
  #
  # Documentation at the __END__
  #
  
  package Data::Dumper;
  
  $VERSION = '2.128'; # Don't forget to set version and release date in POD!
  
  #$| = 1;
  
  use 5.006_001;
  require Exporter;
  require overload;
  
  use Carp;
  
  BEGIN {
      @ISA = qw(Exporter);
      @EXPORT = qw(Dumper);
      @EXPORT_OK = qw(DumperX);
  
      # if run under miniperl, or otherwise lacking dynamic loading,
      # XSLoader should be attempted to load, or the pure perl flag
      # toggled on load failure.
      eval {
  	require XSLoader;
      };
      $Useperl = 1 if $@;
  }
  
  XSLoader::load( 'Data::Dumper' ) unless $Useperl;
  
  # module vars and their defaults
  $Indent     = 2         unless defined $Indent;
  $Purity     = 0         unless defined $Purity;
  $Pad        = ""        unless defined $Pad;
  $Varname    = "VAR"     unless defined $Varname;
  $Useqq      = 0         unless defined $Useqq;
  $Terse      = 0         unless defined $Terse;
  $Freezer    = ""        unless defined $Freezer;
  $Toaster    = ""        unless defined $Toaster;
  $Deepcopy   = 0         unless defined $Deepcopy;
  $Quotekeys  = 1         unless defined $Quotekeys;
  $Bless      = "bless"   unless defined $Bless;
  #$Expdepth   = 0         unless defined $Expdepth;
  $Maxdepth   = 0         unless defined $Maxdepth;
  $Pair       = ' => '    unless defined $Pair;
  $Useperl    = 0         unless defined $Useperl;
  $Sortkeys   = 0         unless defined $Sortkeys;
  $Deparse    = 0         unless defined $Deparse;
  
  #
  # expects an arrayref of values to be dumped.
  # can optionally pass an arrayref of names for the values.
  # names must have leading $ sign stripped. begin the name with *
  # to cause output of arrays and hashes rather than refs.
  #
  sub new {
    my($c, $v, $n) = @_;
  
    croak "Usage:  PACKAGE->new(ARRAYREF, [ARRAYREF])" 
      unless (defined($v) && (ref($v) eq 'ARRAY'));
    $n = [] unless (defined($n) && (ref($n) eq 'ARRAY'));
  
    my($s) = { 
               level      => 0,           # current recursive depth
  	     indent     => $Indent,     # various styles of indenting
  	     pad	=> $Pad,        # all lines prefixed by this string
  	     xpad       => "",          # padding-per-level
  	     apad       => "",          # added padding for hash keys n such
  	     sep        => "",          # list separator
  	     pair	=> $Pair,	# hash key/value separator: defaults to ' => '
  	     seen       => {},          # local (nested) refs (id => [name, val])
  	     todump     => $v,          # values to dump []
  	     names      => $n,          # optional names for values []
  	     varname    => $Varname,    # prefix to use for tagging nameless ones
               purity     => $Purity,     # degree to which output is evalable
               useqq 	=> $Useqq,      # use "" for strings (backslashitis ensues)
               terse 	=> $Terse,      # avoid name output (where feasible)
               freezer	=> $Freezer,    # name of Freezer method for objects
               toaster	=> $Toaster,    # name of method to revive objects
               deepcopy	=> $Deepcopy,   # dont cross-ref, except to stop recursion
               quotekeys	=> $Quotekeys,  # quote hash keys
               'bless'	=> $Bless,	# keyword to use for "bless"
  #	     expdepth   => $Expdepth,   # cutoff depth for explicit dumping
  	     maxdepth	=> $Maxdepth,   # depth beyond which we give up
  	     useperl    => $Useperl,    # use the pure Perl implementation
  	     sortkeys   => $Sortkeys,   # flag or filter for sorting hash keys
  	     deparse	=> $Deparse,	# use B::Deparse for coderefs
  	   };
  
    if ($Indent > 0) {
      $s->{xpad} = "  ";
      $s->{sep} = "\n";
    }
    return bless($s, $c);
  }
  
  if ($] >= 5.008) {
    # Packed numeric addresses take less memory. Plus pack is faster than sprintf
    *init_refaddr_format = sub {};
  
    *format_refaddr  = sub {
      require Scalar::Util;
      pack "J", Scalar::Util::refaddr(shift);
    };
  } else {
    *init_refaddr_format = sub {
      require Config;
      my $f = $Config::Config{uvxformat};
      $f =~ tr/"//d;
      our $refaddr_format = "0x%" . $f;
    };
  
    *format_refaddr = sub {
      require Scalar::Util;
      sprintf our $refaddr_format, Scalar::Util::refaddr(shift);
    }
  }
  
  #
  # add-to or query the table of already seen references
  #
  sub Seen {
    my($s, $g) = @_;
    if (defined($g) && (ref($g) eq 'HASH'))  {
      init_refaddr_format();
      my($k, $v, $id);
      while (($k, $v) = each %$g) {
        if (defined $v and ref $v) {
  	$id = format_refaddr($v);
  	if ($k =~ /^[*](.*)$/) {
  	  $k = (ref $v eq 'ARRAY') ? ( "\\\@" . $1 ) :
  	       (ref $v eq 'HASH')  ? ( "\\\%" . $1 ) :
  	       (ref $v eq 'CODE')  ? ( "\\\&" . $1 ) :
  				     (   "\$" . $1 ) ;
  	}
  	elsif ($k !~ /^\$/) {
  	  $k = "\$" . $k;
  	}
  	$s->{seen}{$id} = [$k, $v];
        }
        else {
  	carp "Only refs supported, ignoring non-ref item \$$k";
        }
      }
      return $s;
    }
    else {
      return map { @$_ } values %{$s->{seen}};
    }
  }
  
  #
  # set or query the values to be dumped
  #
  sub Values {
    my($s, $v) = @_;
    if (defined($v) && (ref($v) eq 'ARRAY'))  {
      $s->{todump} = [@$v];        # make a copy
      return $s;
    }
    else {
      return @{$s->{todump}};
    }
  }
  
  #
  # set or query the names of the values to be dumped
  #
  sub Names {
    my($s, $n) = @_;
    if (defined($n) && (ref($n) eq 'ARRAY'))  {
      $s->{names} = [@$n];         # make a copy
      return $s;
    }
    else {
      return @{$s->{names}};
    }
  }
  
  sub DESTROY {}
  
  sub Dump {
      return &Dumpxs
  	unless $Data::Dumper::Useperl || (ref($_[0]) && $_[0]->{useperl}) ||
  	       $Data::Dumper::Useqq   || (ref($_[0]) && $_[0]->{useqq}) ||
  	       $Data::Dumper::Deparse || (ref($_[0]) && $_[0]->{deparse});
      return &Dumpperl;
  }
  
  #
  # dump the refs in the current dumper object.
  # expects same args as new() if called via package name.
  #
  sub Dumpperl {
    my($s) = shift;
    my(@out, $val, $name);
    my($i) = 0;
    local(@post);
    init_refaddr_format();
  
    $s = $s->new(@_) unless ref $s;
  
    for $val (@{$s->{todump}}) {
      my $out = "";
      @post = ();
      $name = $s->{names}[$i++];
      if (defined $name) {
        if ($name =~ /^[*](.*)$/) {
  	if (defined $val) {
  	  $name = (ref $val eq 'ARRAY') ? ( "\@" . $1 ) :
  		  (ref $val eq 'HASH')  ? ( "\%" . $1 ) :
  		  (ref $val eq 'CODE')  ? ( "\*" . $1 ) :
  					  ( "\$" . $1 ) ;
  	}
  	else {
  	  $name = "\$" . $1;
  	}
        }
        elsif ($name !~ /^\$/) {
  	$name = "\$" . $name;
        }
      }
      else {
        $name = "\$" . $s->{varname} . $i;
      }
  
      my $valstr;
      {
        local($s->{apad}) = $s->{apad};
        $s->{apad} .= ' ' x (length($name) + 3) if $s->{indent} >= 2 and !$s->{terse};
        $valstr = $s->_dump($val, $name);
      }
  
      $valstr = "$name = " . $valstr . ';' if @post or !$s->{terse};
      $out .= $s->{pad} . $valstr . $s->{sep};
      $out .= $s->{pad} . join(';' . $s->{sep} . $s->{pad}, @post) 
        . ';' . $s->{sep} if @post;
  
      push @out, $out;
    }
    return wantarray ? @out : join('', @out);
  }
  
  # wrap string in single quotes (escaping if needed)
  sub _quote {
      my $val = shift;
      $val =~ s/([\\\'])/\\$1/g;
      return  "'" . $val .  "'";
  }
  
  #
  # twist, toil and turn;
  # and recurse, of course.
  # sometimes sordidly;
  # and curse if no recourse.
  #
  sub _dump {
    my($s, $val, $name) = @_;
    my($sname);
    my($out, $realpack, $realtype, $type, $ipad, $id, $blesspad);
  
    $type = ref $val;
    $out = "";
  
    if ($type) {
  
      # Call the freezer method if it's specified and the object has the
      # method.  Trap errors and warn() instead of die()ing, like the XS
      # implementation.
      my $freezer = $s->{freezer};
      if ($freezer and UNIVERSAL::can($val, $freezer)) {
        eval { $val->$freezer() };
        warn "WARNING(Freezer method call failed): $@" if $@;
      }
  
      require Scalar::Util;
      $realpack = Scalar::Util::blessed($val);
      $realtype = $realpack ? Scalar::Util::reftype($val) : ref $val;
      $id = format_refaddr($val);
  
      # if it has a name, we need to either look it up, or keep a tab
      # on it so we know when we hit it later
      if (defined($name) and length($name)) {
        # keep a tab on it so that we dont fall into recursive pit
        if (exists $s->{seen}{$id}) {
  #	if ($s->{expdepth} < $s->{level}) {
  	  if ($s->{purity} and $s->{level} > 0) {
  	    $out = ($realtype eq 'HASH')  ? '{}' :
  	      ($realtype eq 'ARRAY') ? '[]' :
  		'do{my $o}' ;
  	    push @post, $name . " = " . $s->{seen}{$id}[0];
  	  }
  	  else {
  	    $out = $s->{seen}{$id}[0];
  	    if ($name =~ /^([\@\%])/) {
  	      my $start = $1;
  	      if ($out =~ /^\\$start/) {
  		$out = substr($out, 1);
  	      }
  	      else {
  		$out = $start . '{' . $out . '}';
  	      }
  	    }
            }
  	  return $out;
  #        }
        }
        else {
          # store our name
          $s->{seen}{$id} = [ (($name =~ /^[@%]/)     ? ('\\' . $name ) :
  			     ($realtype eq 'CODE' and
  			      $name =~ /^[*](.*)$/) ? ('\\&' . $1 )   :
  			     $name          ),
  			    $val ];
        }
      }
      my $no_bless = 0; 
      my $is_regex = 0;
      if ( $realpack and ($] >= 5.009005 ? re::is_regexp($val) : $realpack eq 'Regexp') ) {
          $is_regex = 1;
          $no_bless = $realpack eq 'Regexp';
      }
  
      # If purity is not set and maxdepth is set, then check depth: 
      # if we have reached maximum depth, return the string
      # representation of the thing we are currently examining
      # at this depth (i.e., 'Foo=ARRAY(0xdeadbeef)'). 
      if (!$s->{purity}
  	and $s->{maxdepth} > 0
  	and $s->{level} >= $s->{maxdepth})
      {
        return qq['$val'];
      }
  
      # we have a blessed ref
      if ($realpack and !$no_bless) {
        $out = $s->{'bless'} . '( ';
        $blesspad = $s->{apad};
        $s->{apad} .= '       ' if ($s->{indent} >= 2);
      }
  
      $s->{level}++;
      $ipad = $s->{xpad} x $s->{level};
  
      if ($is_regex) {
          my $pat;
          # This really sucks, re:regexp_pattern is in ext/re/re.xs and not in 
          # universal.c, and even worse we cant just require that re to be loaded
          # we *have* to use() it. 
          # We should probably move it to universal.c for 5.10.1 and fix this.
          # Currently we only use re::regexp_pattern when the re is blessed into another
          # package. This has the disadvantage of meaning that a DD dump won't round trip
          # as the pattern will be repeatedly wrapped with the same modifiers.
          # This is an aesthetic issue so we will leave it for now, but we could use
          # regexp_pattern() in list context to get the modifiers separately.
          # But since this means loading the full debugging engine in process we wont
          # bother unless its necessary for accuracy.
          if (($realpack ne 'Regexp') && defined(*re::regexp_pattern{CODE})) {
              $pat = re::regexp_pattern($val);
          } else {
              $pat = "$val";
          }
          $pat =~ s,/,\\/,g;
          $out .= "qr/$pat/";
      }
      elsif ($realtype eq 'SCALAR' || $realtype eq 'REF') {
        if ($realpack) {
  	$out .= 'do{\\(my $o = ' . $s->_dump($$val, "\${$name}") . ')}';
        }
        else {
  	$out .= '\\' . $s->_dump($$val, "\${$name}");
        }
      }
      elsif ($realtype eq 'GLOB') {
  	$out .= '\\' . $s->_dump($$val, "*{$name}");
      }
      elsif ($realtype eq 'ARRAY') {
        my($pad, $mname);
        my($i) = 0;
        $out .= ($name =~ /^\@/) ? '(' : '[';
        $pad = $s->{sep} . $s->{pad} . $s->{apad};
        ($name =~ /^\@(.*)$/) ? ($mname = "\$" . $1) : 
  	# omit -> if $foo->[0]->{bar}, but not ${$foo->[0]}->{bar}
  	($name =~ /^\\?[\%\@\*\$][^{].*[]}]$/) ? ($mname = $name) :
  	  ($mname = $name . '->');
        $mname .= '->' if $mname =~ /^\*.+\{[A-Z]+\}$/;
        for my $v (@$val) {
  	$sname = $mname . '[' . $i . ']';
  	$out .= $pad . $ipad . '#' . $i if $s->{indent} >= 3;
  	$out .= $pad . $ipad . $s->_dump($v, $sname);
  	$out .= "," if $i++ < $#$val;
        }
        $out .= $pad . ($s->{xpad} x ($s->{level} - 1)) if $i;
        $out .= ($name =~ /^\@/) ? ')' : ']';
      }
      elsif ($realtype eq 'HASH') {
        my($k, $v, $pad, $lpad, $mname, $pair);
        $out .= ($name =~ /^\%/) ? '(' : '{';
        $pad = $s->{sep} . $s->{pad} . $s->{apad};
        $lpad = $s->{apad};
        $pair = $s->{pair};
        ($name =~ /^\%(.*)$/) ? ($mname = "\$" . $1) :
  	# omit -> if $foo->[0]->{bar}, but not ${$foo->[0]}->{bar}
  	($name =~ /^\\?[\%\@\*\$][^{].*[]}]$/) ? ($mname = $name) :
  	  ($mname = $name . '->');
        $mname .= '->' if $mname =~ /^\*.+\{[A-Z]+\}$/;
        my ($sortkeys, $keys, $key) = ("$s->{sortkeys}");
        if ($sortkeys) {
  	if (ref($s->{sortkeys}) eq 'CODE') {
  	  $keys = $s->{sortkeys}($val);
  	  unless (ref($keys) eq 'ARRAY') {
  	    carp "Sortkeys subroutine did not return ARRAYREF";
  	    $keys = [];
  	  }
  	}
  	else {
  	  $keys = [ sort keys %$val ];
  	}
        }
  
        # Ensure hash iterator is reset
        keys(%$val);
  
        while (($k, $v) = ! $sortkeys ? (each %$val) :
  	     @$keys ? ($key = shift(@$keys), $val->{$key}) :
  	     () ) 
        {
  	my $nk = $s->_dump($k, "");
  	$nk = $1 if !$s->{quotekeys} and $nk =~ /^[\"\']([A-Za-z_]\w*)[\"\']$/;
  	$sname = $mname . '{' . $nk . '}';
  	$out .= $pad . $ipad . $nk . $pair;
  
  	# temporarily alter apad
  	$s->{apad} .= (" " x (length($nk) + 4)) if $s->{indent} >= 2;
  	$out .= $s->_dump($val->{$k}, $sname) . ",";
  	$s->{apad} = $lpad if $s->{indent} >= 2;
        }
        if (substr($out, -1) eq ',') {
  	chop $out;
  	$out .= $pad . ($s->{xpad} x ($s->{level} - 1));
        }
        $out .= ($name =~ /^\%/) ? ')' : '}';
      }
      elsif ($realtype eq 'CODE') {
        if ($s->{deparse}) {
  	require B::Deparse;
  	my $sub =  'sub ' . (B::Deparse->new)->coderef2text($val);
  	$pad    =  $s->{sep} . $s->{pad} . $s->{apad} . $s->{xpad} x ($s->{level} - 1);
  	$sub    =~ s/\n/$pad/gse;
  	$out   .=  $sub;
        } else {
          $out .= 'sub { "DUMMY" }';
          carp "Encountered CODE ref, using dummy placeholder" if $s->{purity};
        }
      }
      else {
        croak "Can\'t handle $realtype type.";
      }
      
      if ($realpack and !$no_bless) { # we have a blessed ref
        $out .= ', ' . _quote($realpack) . ' )';
        $out .= '->' . $s->{toaster} . '()'  if $s->{toaster} ne '';
        $s->{apad} = $blesspad;
      }
      $s->{level}--;
  
    }
    else {                                 # simple scalar
  
      my $ref = \$_[1];
      # first, catalog the scalar
      if ($name ne '') {
        $id = format_refaddr($ref);
        if (exists $s->{seen}{$id}) {
          if ($s->{seen}{$id}[2]) {
  	  $out = $s->{seen}{$id}[0];
  	  #warn "[<$out]\n";
  	  return "\${$out}";
  	}
        }
        else {
  	#warn "[>\\$name]\n";
  	$s->{seen}{$id} = ["\\$name", $ref];
        }
      }
      if (ref($ref) eq 'GLOB' or "$ref" =~ /=GLOB\([^()]+\)$/) {  # glob
        my $name = substr($val, 1);
        if ($name =~ /^[A-Za-z_][\w:]*$/) {
  	$name =~ s/^main::/::/;
  	$sname = $name;
        }
        else {
  	$sname = $s->_dump($name, "");
  	$sname = '{' . $sname . '}';
        }
        if ($s->{purity}) {
  	my $k;
  	local ($s->{level}) = 0;
  	for $k (qw(SCALAR ARRAY HASH)) {
  	  my $gval = *$val{$k};
  	  next unless defined $gval;
  	  next if $k eq "SCALAR" && ! defined $$gval;  # always there
  
  	  # _dump can push into @post, so we hold our place using $postlen
  	  my $postlen = scalar @post;
  	  $post[$postlen] = "\*$sname = ";
  	  local ($s->{apad}) = " " x length($post[$postlen]) if $s->{indent} >= 2;
  	  $post[$postlen] .= $s->_dump($gval, "\*$sname\{$k\}");
  	}
        }
        $out .= '*' . $sname;
      }
      elsif (!defined($val)) {
        $out .= "undef";
      }
      elsif ($val =~ /^(?:0|-?[1-9]\d{0,8})\z/) { # safe decimal number
        $out .= $val;
      }
      else {				 # string
        if ($s->{useqq} or $val =~ tr/\0-\377//c) {
          # Fall back to qq if there's Unicode
  	$out .= qquote($val, $s->{useqq});
        }
        else {
          $out .= _quote($val);
        }
      }
    }
    if ($id) {
      # if we made it this far, $id was added to seen list at current
      # level, so remove it to get deep copies
      if ($s->{deepcopy}) {
        delete($s->{seen}{$id});
      }
      elsif ($name) {
        $s->{seen}{$id}[2] = 1;
      }
    }
    return $out;
  }
    
  #
  # non-OO style of earlier version
  #
  sub Dumper {
    return Data::Dumper->Dump([@_]);
  }
  
  # compat stub
  sub DumperX {
    return Data::Dumper->Dumpxs([@_], []);
  }
  
  sub Dumpf { return Data::Dumper->Dump(@_) }
  
  sub Dumpp { print Data::Dumper->Dump(@_) }
  
  #
  # reset the "seen" cache 
  #
  sub Reset {
    my($s) = shift;
    $s->{seen} = {};
    return $s;
  }
  
  sub Indent {
    my($s, $v) = @_;
    if (defined($v)) {
      if ($v == 0) {
        $s->{xpad} = "";
        $s->{sep} = "";
      }
      else {
        $s->{xpad} = "  ";
        $s->{sep} = "\n";
      }
      $s->{indent} = $v;
      return $s;
    }
    else {
      return $s->{indent};
    }
  }
  
  sub Pair {
      my($s, $v) = @_;
      defined($v) ? (($s->{pair} = $v), return $s) : $s->{pair};
  }
  
  sub Pad {
    my($s, $v) = @_;
    defined($v) ? (($s->{pad} = $v), return $s) : $s->{pad};
  }
  
  sub Varname {
    my($s, $v) = @_;
    defined($v) ? (($s->{varname} = $v), return $s) : $s->{varname};
  }
  
  sub Purity {
    my($s, $v) = @_;
    defined($v) ? (($s->{purity} = $v), return $s) : $s->{purity};
  }
  
  sub Useqq {
    my($s, $v) = @_;
    defined($v) ? (($s->{useqq} = $v), return $s) : $s->{useqq};
  }
  
  sub Terse {
    my($s, $v) = @_;
    defined($v) ? (($s->{terse} = $v), return $s) : $s->{terse};
  }
  
  sub Freezer {
    my($s, $v) = @_;
    defined($v) ? (($s->{freezer} = $v), return $s) : $s->{freezer};
  }
  
  sub Toaster {
    my($s, $v) = @_;
    defined($v) ? (($s->{toaster} = $v), return $s) : $s->{toaster};
  }
  
  sub Deepcopy {
    my($s, $v) = @_;
    defined($v) ? (($s->{deepcopy} = $v), return $s) : $s->{deepcopy};
  }
  
  sub Quotekeys {
    my($s, $v) = @_;
    defined($v) ? (($s->{quotekeys} = $v), return $s) : $s->{quotekeys};
  }
  
  sub Bless {
    my($s, $v) = @_;
    defined($v) ? (($s->{'bless'} = $v), return $s) : $s->{'bless'};
  }
  
  sub Maxdepth {
    my($s, $v) = @_;
    defined($v) ? (($s->{'maxdepth'} = $v), return $s) : $s->{'maxdepth'};
  }
  
  sub Useperl {
    my($s, $v) = @_;
    defined($v) ? (($s->{'useperl'} = $v), return $s) : $s->{'useperl'};
  }
  
  sub Sortkeys {
    my($s, $v) = @_;
    defined($v) ? (($s->{'sortkeys'} = $v), return $s) : $s->{'sortkeys'};
  }
  
  sub Deparse {
    my($s, $v) = @_;
    defined($v) ? (($s->{'deparse'} = $v), return $s) : $s->{'deparse'};
  }
  
  # used by qquote below
  my %esc = (  
      "\a" => "\\a",
      "\b" => "\\b",
      "\t" => "\\t",
      "\n" => "\\n",
      "\f" => "\\f",
      "\r" => "\\r",
      "\e" => "\\e",
  );
  
  # put a string value in double quotes
  sub qquote {
    local($_) = shift;
    s/([\\\"\@\$])/\\$1/g;
    my $bytes; { use bytes; $bytes = length }
    s/([^\x00-\x7f])/'\x{'.sprintf("%x",ord($1)).'}'/ge if $bytes > length;
    return qq("$_") unless 
      /[^ !"\#\$%&'()*+,\-.\/0-9:;<=>?\@A-Z[\\\]^_`a-z{|}~]/;  # fast exit
  
    my $high = shift || "";
    s/([\a\b\t\n\f\r\e])/$esc{$1}/g;
  
    if (ord('^')==94)  { # ascii
      # no need for 3 digits in escape for these
      s/([\0-\037])(?!\d)/'\\'.sprintf('%o',ord($1))/eg;
      s/([\0-\037\177])/'\\'.sprintf('%03o',ord($1))/eg;
      # all but last branch below not supported --BEHAVIOR SUBJECT TO CHANGE--
      if ($high eq "iso8859") {
        s/([\200-\240])/'\\'.sprintf('%o',ord($1))/eg;
      } elsif ($high eq "utf8") {
  #     use utf8;
  #     $str =~ s/([^\040-\176])/sprintf "\\x{%04x}", ord($1)/ge;
      } elsif ($high eq "8bit") {
          # leave it as it is
      } else {
        s/([\200-\377])/'\\'.sprintf('%03o',ord($1))/eg;
        s/([^\040-\176])/sprintf "\\x{%04x}", ord($1)/ge;
      }
    }
    else { # ebcdic
        s{([^ !"\#\$%&'()*+,\-.\/0-9:;<=>?\@A-Z[\\\]^_`a-z{|}~])(?!\d)}
         {my $v = ord($1); '\\'.sprintf(($v <= 037 ? '%o' : '%03o'), $v)}eg;
        s{([^ !"\#\$%&'()*+,\-.\/0-9:;<=>?\@A-Z[\\\]^_`a-z{|}~])}
         {'\\'.sprintf('%03o',ord($1))}eg;
    }
  
    return qq("$_");
  }
  
  # helper sub to sort hash keys in Perl < 5.8.0 where we don't have
  # access to sortsv() from XS
  sub _sortkeys { [ sort keys %{$_[0]} ] }
  
  1;
  __END__
  
  =head1 NAME
  
  Data::Dumper - stringified perl data structures, suitable for both printing and C<eval>
  
  =head1 SYNOPSIS
  
      use Data::Dumper;
  
      # simple procedural interface
      print Dumper($foo, $bar);
  
      # extended usage with names
      print Data::Dumper->Dump([$foo, $bar], [qw(foo *ary)]);
  
      # configuration variables
      {
        local $Data::Dumper::Purity = 1;
        eval Data::Dumper->Dump([$foo, $bar], [qw(foo *ary)]);
      }
  
      # OO usage
      $d = Data::Dumper->new([$foo, $bar], [qw(foo *ary)]);
         ...
      print $d->Dump;
         ...
      $d->Purity(1)->Terse(1)->Deepcopy(1);
      eval $d->Dump;
  
  
  =head1 DESCRIPTION
  
  Given a list of scalars or reference variables, writes out their contents in
  perl syntax. The references can also be objects.  The content of each
  variable is output in a single Perl statement.  Handles self-referential
  structures correctly.
  
  The return value can be C<eval>ed to get back an identical copy of the
  original reference structure.
  
  Any references that are the same as one of those passed in will be named
  C<$VAR>I<n> (where I<n> is a numeric suffix), and other duplicate references
  to substructures within C<$VAR>I<n> will be appropriately labeled using arrow
  notation.  You can specify names for individual values to be dumped if you
  use the C<Dump()> method, or you can change the default C<$VAR> prefix to
  something else.  See C<$Data::Dumper::Varname> and C<$Data::Dumper::Terse>
  below.
  
  The default output of self-referential structures can be C<eval>ed, but the
  nested references to C<$VAR>I<n> will be undefined, since a recursive
  structure cannot be constructed using one Perl statement.  You should set the
  C<Purity> flag to 1 to get additional statements that will correctly fill in
  these references.  Moreover, if C<eval>ed when strictures are in effect,
  you need to ensure that any variables it accesses are previously declared.
  
  In the extended usage form, the references to be dumped can be given
  user-specified names.  If a name begins with a C<*>, the output will 
  describe the dereferenced type of the supplied reference for hashes and
  arrays, and coderefs.  Output of names will be avoided where possible if
  the C<Terse> flag is set.
  
  In many cases, methods that are used to set the internal state of the
  object will return the object itself, so method calls can be conveniently
  chained together.
  
  Several styles of output are possible, all controlled by setting
  the C<Indent> flag.  See L<Configuration Variables or Methods> below 
  for details.
  
  
  =head2 Methods
  
  =over 4
  
  =item I<PACKAGE>->new(I<ARRAYREF [>, I<ARRAYREF]>)
  
  Returns a newly created C<Data::Dumper> object.  The first argument is an
  anonymous array of values to be dumped.  The optional second argument is an
  anonymous array of names for the values.  The names need not have a leading
  C<$> sign, and must be comprised of alphanumeric characters.  You can begin
  a name with a C<*> to specify that the dereferenced type must be dumped
  instead of the reference itself, for ARRAY and HASH references.
  
  The prefix specified by C<$Data::Dumper::Varname> will be used with a
  numeric suffix if the name for a value is undefined.
  
  Data::Dumper will catalog all references encountered while dumping the
  values. Cross-references (in the form of names of substructures in perl
  syntax) will be inserted at all possible points, preserving any structural
  interdependencies in the original set of values.  Structure traversal is
  depth-first,  and proceeds in order from the first supplied value to
  the last.
  
  =item I<$OBJ>->Dump  I<or>  I<PACKAGE>->Dump(I<ARRAYREF [>, I<ARRAYREF]>)
  
  Returns the stringified form of the values stored in the object (preserving
  the order in which they were supplied to C<new>), subject to the
  configuration options below.  In a list context, it returns a list
  of strings corresponding to the supplied values.
  
  The second form, for convenience, simply calls the C<new> method on its
  arguments before dumping the object immediately.
  
  =item I<$OBJ>->Seen(I<[HASHREF]>)
  
  Queries or adds to the internal table of already encountered references.
  You must use C<Reset> to explicitly clear the table if needed.  Such
  references are not dumped; instead, their names are inserted wherever they
  are encountered subsequently.  This is useful especially for properly
  dumping subroutine references.
  
  Expects an anonymous hash of name => value pairs.  Same rules apply for names
  as in C<new>.  If no argument is supplied, will return the "seen" list of
  name => value pairs, in a list context.  Otherwise, returns the object
  itself.
  
  =item I<$OBJ>->Values(I<[ARRAYREF]>)
  
  Queries or replaces the internal array of values that will be dumped.
  When called without arguments, returns the values.  Otherwise, returns the
  object itself.
  
  =item I<$OBJ>->Names(I<[ARRAYREF]>)
  
  Queries or replaces the internal array of user supplied names for the values
  that will be dumped.  When called without arguments, returns the names.
  Otherwise, returns the object itself.
  
  =item I<$OBJ>->Reset
  
  Clears the internal table of "seen" references and returns the object
  itself.
  
  =back
  
  =head2 Functions
  
  =over 4
  
  =item Dumper(I<LIST>)
  
  Returns the stringified form of the values in the list, subject to the
  configuration options below.  The values will be named C<$VAR>I<n> in the
  output, where I<n> is a numeric suffix.  Will return a list of strings
  in a list context.
  
  =back
  
  =head2 Configuration Variables or Methods
  
  Several configuration variables can be used to control the kind of output
  generated when using the procedural interface.  These variables are usually
  C<local>ized in a block so that other parts of the code are not affected by
  the change.  
  
  These variables determine the default state of the object created by calling
  the C<new> method, but cannot be used to alter the state of the object
  thereafter.  The equivalent method names should be used instead to query
  or set the internal state of the object.
  
  The method forms return the object itself when called with arguments,
  so that they can be chained together nicely.
  
  =over 4
  
  =item *
  
  $Data::Dumper::Indent  I<or>  I<$OBJ>->Indent(I<[NEWVAL]>)
  
  Controls the style of indentation.  It can be set to 0, 1, 2 or 3.  Style 0
  spews output without any newlines, indentation, or spaces between list
  items.  It is the most compact format possible that can still be called
  valid perl.  Style 1 outputs a readable form with newlines but no fancy
  indentation (each level in the structure is simply indented by a fixed
  amount of whitespace).  Style 2 (the default) outputs a very readable form
  which takes into account the length of hash keys (so the hash value lines
  up).  Style 3 is like style 2, but also annotates the elements of arrays
  with their index (but the comment is on its own line, so array output
  consumes twice the number of lines).  Style 2 is the default.
  
  =item *
  
  $Data::Dumper::Purity  I<or>  I<$OBJ>->Purity(I<[NEWVAL]>)
  
  Controls the degree to which the output can be C<eval>ed to recreate the
  supplied reference structures.  Setting it to 1 will output additional perl
  statements that will correctly recreate nested references.  The default is
  0.
  
  =item *
  
  $Data::Dumper::Pad  I<or>  I<$OBJ>->Pad(I<[NEWVAL]>)
  
  Specifies the string that will be prefixed to every line of the output.
  Empty string by default.
  
  =item *
  
  $Data::Dumper::Varname  I<or>  I<$OBJ>->Varname(I<[NEWVAL]>)
  
  Contains the prefix to use for tagging variable names in the output. The
  default is "VAR".
  
  =item *
  
  $Data::Dumper::Useqq  I<or>  I<$OBJ>->Useqq(I<[NEWVAL]>)
  
  When set, enables the use of double quotes for representing string values.
  Whitespace other than space will be represented as C<[\n\t\r]>, "unsafe"
  characters will be backslashed, and unprintable characters will be output as
  quoted octal integers.  Since setting this variable imposes a performance
  penalty, the default is 0.  C<Dump()> will run slower if this flag is set,
  since the fast XSUB implementation doesn't support it yet.
  
  =item *
  
  $Data::Dumper::Terse  I<or>  I<$OBJ>->Terse(I<[NEWVAL]>)
  
  When set, Data::Dumper will emit single, non-self-referential values as
  atoms/terms rather than statements.  This means that the C<$VAR>I<n> names
  will be avoided where possible, but be advised that such output may not
  always be parseable by C<eval>.
  
  =item *
  
  $Data::Dumper::Freezer  I<or>  $I<OBJ>->Freezer(I<[NEWVAL]>)
  
  Can be set to a method name, or to an empty string to disable the feature.
  Data::Dumper will invoke that method via the object before attempting to
  stringify it.  This method can alter the contents of the object (if, for
  instance, it contains data allocated from C), and even rebless it in a
  different package.  The client is responsible for making sure the specified
  method can be called via the object, and that the object ends up containing
  only perl data types after the method has been called.  Defaults to an empty
  string.
  
  If an object does not support the method specified (determined using
  UNIVERSAL::can()) then the call will be skipped.  If the method dies a
  warning will be generated.
  
  =item *
  
  $Data::Dumper::Toaster  I<or>  $I<OBJ>->Toaster(I<[NEWVAL]>)
  
  Can be set to a method name, or to an empty string to disable the feature.
  Data::Dumper will emit a method call for any objects that are to be dumped
  using the syntax C<bless(DATA, CLASS)-E<gt>METHOD()>.  Note that this means that
  the method specified will have to perform any modifications required on the
  object (like creating new state within it, and/or reblessing it in a
  different package) and then return it.  The client is responsible for making
  sure the method can be called via the object, and that it returns a valid
  object.  Defaults to an empty string.
  
  =item *
  
  $Data::Dumper::Deepcopy  I<or>  $I<OBJ>->Deepcopy(I<[NEWVAL]>)
  
  Can be set to a boolean value to enable deep copies of structures.
  Cross-referencing will then only be done when absolutely essential
  (i.e., to break reference cycles).  Default is 0.
  
  =item *
  
  $Data::Dumper::Quotekeys  I<or>  $I<OBJ>->Quotekeys(I<[NEWVAL]>)
  
  Can be set to a boolean value to control whether hash keys are quoted.
  A false value will avoid quoting hash keys when it looks like a simple
  string.  Default is 1, which will always enclose hash keys in quotes.
  
  =item *
  
  $Data::Dumper::Bless  I<or>  $I<OBJ>->Bless(I<[NEWVAL]>)
  
  Can be set to a string that specifies an alternative to the C<bless>
  builtin operator used to create objects.  A function with the specified
  name should exist, and should accept the same arguments as the builtin.
  Default is C<bless>.
  
  =item *
  
  $Data::Dumper::Pair  I<or>  $I<OBJ>->Pair(I<[NEWVAL]>)
  
  Can be set to a string that specifies the separator between hash keys
  and values. To dump nested hash, array and scalar values to JavaScript,
  use: C<$Data::Dumper::Pair = ' : ';>. Implementing C<bless> in JavaScript
  is left as an exercise for the reader.
  A function with the specified name exists, and accepts the same arguments
  as the builtin.
  
  Default is: C< =E<gt> >.
  
  =item *
  
  $Data::Dumper::Maxdepth  I<or>  $I<OBJ>->Maxdepth(I<[NEWVAL]>)
  
  Can be set to a positive integer that specifies the depth beyond which
  we don't venture into a structure.  Has no effect when
  C<Data::Dumper::Purity> is set.  (Useful in debugger when we often don't
  want to see more than enough).  Default is 0, which means there is 
  no maximum depth. 
  
  =item *
  
  $Data::Dumper::Useperl  I<or>  $I<OBJ>->Useperl(I<[NEWVAL]>)
  
  Can be set to a boolean value which controls whether the pure Perl
  implementation of C<Data::Dumper> is used. The C<Data::Dumper> module is
  a dual implementation, with almost all functionality written in both
  pure Perl and also in XS ('C'). Since the XS version is much faster, it
  will always be used if possible. This option lets you override the
  default behavior, usually for testing purposes only. Default is 0, which
  means the XS implementation will be used if possible.
  
  =item *
  
  $Data::Dumper::Sortkeys  I<or>  $I<OBJ>->Sortkeys(I<[NEWVAL]>)
  
  Can be set to a boolean value to control whether hash keys are dumped in
  sorted order. A true value will cause the keys of all hashes to be
  dumped in Perl's default sort order. Can also be set to a subroutine
  reference which will be called for each hash that is dumped. In this
  case C<Data::Dumper> will call the subroutine once for each hash,
  passing it the reference of the hash. The purpose of the subroutine is
  to return a reference to an array of the keys that will be dumped, in
  the order that they should be dumped. Using this feature, you can
  control both the order of the keys, and which keys are actually used. In
  other words, this subroutine acts as a filter by which you can exclude
  certain keys from being dumped. Default is 0, which means that hash keys
  are not sorted.
  
  =item *
  
  $Data::Dumper::Deparse  I<or>  $I<OBJ>->Deparse(I<[NEWVAL]>)
  
  Can be set to a boolean value to control whether code references are
  turned into perl source code. If set to a true value, C<B::Deparse>
  will be used to get the source of the code reference. Using this option
  will force using the Perl implementation of the dumper, since the fast
  XSUB implementation doesn't support it.
  
  Caution : use this option only if you know that your coderefs will be
  properly reconstructed by C<B::Deparse>.
  
  =back
  
  =head2 Exports
  
  =over 4
  
  =item Dumper
  
  =back
  
  =head1 EXAMPLES
  
  Run these code snippets to get a quick feel for the behavior of this
  module.  When you are through with these examples, you may want to
  add or change the various configuration variables described above,
  to see their behavior.  (See the testsuite in the Data::Dumper
  distribution for more examples.)
  
  
      use Data::Dumper;
  
      package Foo;
      sub new {bless {'a' => 1, 'b' => sub { return "foo" }}, $_[0]};
  
      package Fuz;                       # a weird REF-REF-SCALAR object
      sub new {bless \($_ = \ 'fu\'z'), $_[0]};
  
      package main;
      $foo = Foo->new;
      $fuz = Fuz->new;
      $boo = [ 1, [], "abcd", \*foo,
               {1 => 'a', 023 => 'b', 0x45 => 'c'}, 
               \\"p\q\'r", $foo, $fuz];
  
      ########
      # simple usage
      ########
  
      $bar = eval(Dumper($boo));
      print($@) if $@;
      print Dumper($boo), Dumper($bar);  # pretty print (no array indices)
  
      $Data::Dumper::Terse = 1;          # don't output names where feasible
      $Data::Dumper::Indent = 0;         # turn off all pretty print
      print Dumper($boo), "\n";
  
      $Data::Dumper::Indent = 1;         # mild pretty print
      print Dumper($boo);
  
      $Data::Dumper::Indent = 3;         # pretty print with array indices
      print Dumper($boo);
  
      $Data::Dumper::Useqq = 1;          # print strings in double quotes
      print Dumper($boo);
  
      $Data::Dumper::Pair = " : ";       # specify hash key/value separator
      print Dumper($boo);
  
  
      ########
      # recursive structures
      ########
  
      @c = ('c');
      $c = \@c;
      $b = {};
      $a = [1, $b, $c];
      $b->{a} = $a;
      $b->{b} = $a->[1];
      $b->{c} = $a->[2];
      print Data::Dumper->Dump([$a,$b,$c], [qw(a b c)]);
  
  
      $Data::Dumper::Purity = 1;         # fill in the holes for eval
      print Data::Dumper->Dump([$a, $b], [qw(*a b)]); # print as @a
      print Data::Dumper->Dump([$b, $a], [qw(*b a)]); # print as %b
  
  
      $Data::Dumper::Deepcopy = 1;       # avoid cross-refs
      print Data::Dumper->Dump([$b, $a], [qw(*b a)]);
  
  
      $Data::Dumper::Purity = 0;         # avoid cross-refs
      print Data::Dumper->Dump([$b, $a], [qw(*b a)]);
  
      ########
      # deep structures
      ########
  
      $a = "pearl";
      $b = [ $a ];
      $c = { 'b' => $b };
      $d = [ $c ];
      $e = { 'd' => $d };
      $f = { 'e' => $e };
      print Data::Dumper->Dump([$f], [qw(f)]);
  
      $Data::Dumper::Maxdepth = 3;       # no deeper than 3 refs down
      print Data::Dumper->Dump([$f], [qw(f)]);
  
  
      ########
      # object-oriented usage
      ########
  
      $d = Data::Dumper->new([$a,$b], [qw(a b)]);
      $d->Seen({'*c' => $c});            # stash a ref without printing it
      $d->Indent(3);
      print $d->Dump;
      $d->Reset->Purity(0);              # empty the seen cache
      print join "----\n", $d->Dump;
  
  
      ########
      # persistence
      ########
  
      package Foo;
      sub new { bless { state => 'awake' }, shift }
      sub Freeze {
          my $s = shift;
  	print STDERR "preparing to sleep\n";
  	$s->{state} = 'asleep';
  	return bless $s, 'Foo::ZZZ';
      }
  
      package Foo::ZZZ;
      sub Thaw {
          my $s = shift;
  	print STDERR "waking up\n";
  	$s->{state} = 'awake';
  	return bless $s, 'Foo';
      }
  
      package Foo;
      use Data::Dumper;
      $a = Foo->new;
      $b = Data::Dumper->new([$a], ['c']);
      $b->Freezer('Freeze');
      $b->Toaster('Thaw');
      $c = $b->Dump;
      print $c;
      $d = eval $c;
      print Data::Dumper->Dump([$d], ['d']);
  
  
      ########
      # symbol substitution (useful for recreating CODE refs)
      ########
  
      sub foo { print "foo speaking\n" }
      *other = \&foo;
      $bar = [ \&other ];
      $d = Data::Dumper->new([\&other,$bar],['*other','bar']);
      $d->Seen({ '*foo' => \&foo });
      print $d->Dump;
  
  
      ########
      # sorting and filtering hash keys
      ########
  
      $Data::Dumper::Sortkeys = \&my_filter;
      my $foo = { map { (ord, "$_$_$_") } 'I'..'Q' };
      my $bar = { %$foo };
      my $baz = { reverse %$foo };
      print Dumper [ $foo, $bar, $baz ];
  
      sub my_filter {
          my ($hash) = @_;
          # return an array ref containing the hash keys to dump
          # in the order that you want them to be dumped
          return [
            # Sort the keys of %$foo in reverse numeric order
              $hash eq $foo ? (sort {$b <=> $a} keys %$hash) :
            # Only dump the odd number keys of %$bar
              $hash eq $bar ? (grep {$_ % 2} keys %$hash) :
            # Sort keys in default order for all other hashes
              (sort keys %$hash)
          ];
      }
  
  =head1 BUGS
  
  Due to limitations of Perl subroutine call semantics, you cannot pass an
  array or hash.  Prepend it with a C<\> to pass its reference instead.  This
  will be remedied in time, now that Perl has subroutine prototypes.
  For now, you need to use the extended usage form, and prepend the
  name with a C<*> to output it as a hash or array.
  
  C<Data::Dumper> cheats with CODE references.  If a code reference is
  encountered in the structure being processed (and if you haven't set
  the C<Deparse> flag), an anonymous subroutine that
  contains the string '"DUMMY"' will be inserted in its place, and a warning
  will be printed if C<Purity> is set.  You can C<eval> the result, but bear
  in mind that the anonymous sub that gets created is just a placeholder.
  Someday, perl will have a switch to cache-on-demand the string
  representation of a compiled piece of code, I hope.  If you have prior
  knowledge of all the code refs that your data structures are likely
  to have, you can use the C<Seen> method to pre-seed the internal reference
  table and make the dumped output point to them, instead.  See L</EXAMPLES>
  above.
  
  The C<Useqq> and C<Deparse> flags makes Dump() run slower, since the
  XSUB implementation does not support them.
  
  SCALAR objects have the weirdest looking C<bless> workaround.
  
  Pure Perl version of C<Data::Dumper> escapes UTF-8 strings correctly
  only in Perl 5.8.0 and later.
  
  =head2 NOTE
  
  Starting from Perl 5.8.1 different runs of Perl will have different
  ordering of hash keys.  The change was done for greater security,
  see L<perlsec/"Algorithmic Complexity Attacks">.  This means that
  different runs of Perl will have different Data::Dumper outputs if
  the data contains hashes.  If you need to have identical Data::Dumper
  outputs from different runs of Perl, use the environment variable
  PERL_HASH_SEED, see L<perlrun/PERL_HASH_SEED>.  Using this restores
  the old (platform-specific) ordering: an even prettier solution might
  be to use the C<Sortkeys> filter of Data::Dumper.
  
  =head1 AUTHOR
  
  Gurusamy Sarathy        gsar@activestate.com
  
  Copyright (c) 1996-98 Gurusamy Sarathy. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 VERSION
  
  Version 2.128  (Sep 10 2010)
  
  =head1 SEE ALSO
  
  perl(1)
  
  =cut
DARWIN-2LEVEL_DATA_DUMPER

$fatpacked{"darwin-2level/File/Spec.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC';
  package File::Spec;
  
  use strict;
  use vars qw(@ISA $VERSION);
  
  $VERSION = '3.33';
  $VERSION = eval $VERSION;
  
  my %module = (MacOS   => 'Mac',
  	      MSWin32 => 'Win32',
  	      os2     => 'OS2',
  	      VMS     => 'VMS',
  	      epoc    => 'Epoc',
  	      NetWare => 'Win32', # Yes, File::Spec::Win32 works on NetWare.
  	      symbian => 'Win32', # Yes, File::Spec::Win32 works on symbian.
  	      dos     => 'OS2',   # Yes, File::Spec::OS2 works on DJGPP.
  	      cygwin  => 'Cygwin');
  
  
  my $module = $module{$^O} || 'Unix';
  
  require "File/Spec/$module.pm";
  @ISA = ("File::Spec::$module");
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Spec - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec;
  
  	$x=File::Spec->catfile('a', 'b', 'c');
  
  which returns 'a/b/c' under Unix. Or:
  
  	use File::Spec::Functions;
  
  	$x = catfile('a', 'b', 'c');
  
  =head1 DESCRIPTION
  
  This module is designed to support operations commonly performed on file
  specifications (usually called "file names", but not to be confused with the
  contents of a file, or Perl's file handles), such as concatenating several
  directory and file names into a single path, or determining whether a path
  is rooted. It is based on code directly taken from MakeMaker 5.17, code
  written by Andreas KE<ouml>nig, Andy Dougherty, Charles Bailey, Ilya
  Zakharevich, Paul Schinder, and others.
  
  Since these functions are different for most operating systems, each set of
  OS specific routines is available in a separate module, including:
  
  	File::Spec::Unix
  	File::Spec::Mac
  	File::Spec::OS2
  	File::Spec::Win32
  	File::Spec::VMS
  
  The module appropriate for the current OS is automatically loaded by
  File::Spec. Since some modules (like VMS) make use of facilities available
  only under that OS, it may not be possible to load all modules under all
  operating systems.
  
  Since File::Spec is object oriented, subroutines should not be called directly,
  as in:
  
  	File::Spec::catfile('a','b');
  
  but rather as class methods:
  
  	File::Spec->catfile('a','b');
  
  For simple uses, L<File::Spec::Functions> provides convenient functional
  forms of these methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  X<canonpath>
  
  No physical check on the filesystem, but a logical cleanup of a
  path.
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =item catdir
  X<catdir>
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS/2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
      $path = File::Spec->catdir( @directories );
  
  =item catfile
  X<catfile>
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
      $path = File::Spec->catfile( @directories, $filename );
  
  =item curdir
  X<curdir>
  
  Returns a string representation of the current directory.
  
      $curdir = File::Spec->curdir();
  
  =item devnull
  X<devnull>
  
  Returns a string representation of the null device.
  
      $devnull = File::Spec->devnull();
  
  =item rootdir
  X<rootdir>
  
  Returns a string representation of the root directory.
  
      $rootdir = File::Spec->rootdir();
  
  =item tmpdir
  X<tmpdir>
  
  Returns a string representation of the first writable directory from a
  list of possible temporary directories.  Returns the current directory
  if no writable temporary directories are found.  The list of directories
  checked depends on the platform; e.g. File::Spec::Unix checks C<$ENV{TMPDIR}>
  (unless taint is on) and F</tmp>.
  
      $tmpdir = File::Spec->tmpdir();
  
  =item updir
  X<updir>
  
  Returns a string representation of the parent directory.
  
      $updir = File::Spec->updir();
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
      @paths = File::Spec->no_upwards( @paths );
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  case is not or is significant when comparing file specifications.
  Cygwin and Win32 accept an optional drive argument.
  
      $is_case_tolerant = File::Spec->case_tolerant();
  
  =item file_name_is_absolute
  
  Takes as its argument a path, and returns true if it is an absolute path.
  
      $is_absolute = File::Spec->file_name_is_absolute( $path );
  
  This does not consult the local filesystem on Unix, Win32, OS/2, or
  Mac OS (Classic).  It does consult the working environment for VMS
  (see L<File::Spec::VMS/file_name_is_absolute>).
  
  =item path
  X<path>
  
  Takes no argument.  Returns the environment variable C<PATH> (or the local
  platform's equivalent) as a list.
  
      @PATH = File::Spec->path();
  
  =item join
  X<join, path>
  
  join is the same as catfile.
  
  =item splitpath
  X<splitpath> X<split, path>
  
  Splits a path in to volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path, $no_file );
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless C<$no_file> is true or a
  trailing separator or F</.> or F</..> is present. On Unix, this means that C<$no_file>
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =item splitdir
  X<splitdir> X<split, dir>
  
  The opposite of L</catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  C<$directories> must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSes.
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, C<$volume> is ignored, and directory and file are concatenated.  A '/' is
  inserted if need be.  On other OSes, C<$volume> is significant.
  
      $full_path = File::Spec->catpath( $volume, $directory, $file );
  
  =item abs2rel
  X<abs2rel> X<absolute, path> X<relative, path>
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =item rel2abs()
  X<rel2abs> X<absolute, path> X<relative, path>
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is relative,
  then it is converted to absolute form using L</rel2abs()>. This means that it
  is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is absolute, it is cleaned up and returned using L</canonpath>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =back
  
  For further information, please see L<File::Spec::Unix>,
  L<File::Spec::Mac>, L<File::Spec::OS2>, L<File::Spec::Win32>, or
  L<File::Spec::VMS>.
  
  =head1 SEE ALSO
  
  L<File::Spec::Unix>, L<File::Spec::Mac>, L<File::Spec::OS2>,
  L<File::Spec::Win32>, L<File::Spec::VMS>, L<File::Spec::Functions>,
  L<ExtUtils::MakeMaker>
  
  =head1 AUTHOR
  
  Currently maintained by Ken Williams C<< <KWILLIAMS@cpan.org> >>.
  
  The vast majority of the code was written by
  Kenneth Albanowski C<< <kjahds@kjahds.com> >>,
  Andy Dougherty C<< <doughera@lafayette.edu> >>,
  Andreas KE<ouml>nig C<< <A.Koenig@franz.ww.TU-Berlin.DE> >>,
  Tim Bunce C<< <Tim.Bunce@ig.co.uk> >>.
  VMS support by Charles Bailey C<< <bailey@newman.upenn.edu> >>.
  OS/2 support by Ilya Zakharevich C<< <ilya@math.ohio-state.edu> >>.
  Mac support by Paul Schinder C<< <schinder@pobox.com> >>, and
  Thomas Wegner C<< <wegner_thomas@yahoo.com> >>.
  abs2rel() and rel2abs() written by Shigio Yamaguchi C<< <shigio@tamacom.com> >>,
  modified by Barrie Slaymaker C<< <barries@slaysys.com> >>.
  splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-2010 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_FILE_SPEC

$fatpacked{"darwin-2level/File/Spec/Cygwin.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_CYGWIN';
  package File::Spec::Cygwin;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.33';
  $VERSION = eval $VERSION;
  
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Cygwin - methods for Cygwin file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Cygwin; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  This module is still in beta.  Cygwin-knowledgeable folks are invited
  to offer patches and suggestions.
  
  =cut
  
  =pod
  
  =over 4
  
  =item canonpath
  
  Any C<\> (backslashes) are converted to C</> (forward slashes),
  and then File::Spec::Unix canonpath() is called on the result.
  
  =cut
  
  sub canonpath {
      my($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|\\|/|g;
  
      # Handle network path names beginning with double slash
      my $node = '';
      if ( $path =~ s@^(//[^/]+)(?:/|\z)@/@s ) {
          $node = $1;
      }
      return $node . $self->SUPER::canonpath($path);
  }
  
  sub catdir {
      my $self = shift;
      return unless @_;
  
      # Don't create something that looks like a //network/path
      if ($_[0] and ($_[0] eq '/' or $_[0] eq '\\')) {
          shift;
          return $self->SUPER::catdir('', @_);
      }
  
      $self->SUPER::catdir(@_);
  }
  
  =pod
  
  =item file_name_is_absolute
  
  True is returned if the file name begins with C<drive_letter:>,
  and if not, File::Spec::Unix file_name_is_absolute() is called.
  
  =cut
  
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return 1 if $file =~ m{^([a-z]:)?[\\/]}is; # C:/test
      return $self->SUPER::file_name_is_absolute($file);
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      /tmp
      $ENV{'TMP'}
      $ENV{'TEMP'}
      C:/temp
  
  Since Perl 5.8.0, if running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp", $ENV{'TMP'}, $ENV{'TEMP'}, 'C:/temp' );
  }
  
  =item case_tolerant
  
  Override Unix. Cygwin case-tolerance depends on managed mount settings and
  as with MsWin32 on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Default: 1
  
  =cut
  
  sub case_tolerant {
    return 1 unless $^O eq 'cygwin'
      and defined &Cygwin::mount_flags;
  
    my $drive = shift;
    if (! $drive) {
        my @flags = split(/,/, Cygwin::mount_flags('/cygwin'));
        my $prefix = pop(@flags);
        if (! $prefix || $prefix eq 'cygdrive') {
            $drive = '/cygdrive/c';
        } elsif ($prefix eq '/') {
            $drive = '/c';
        } else {
            $drive = "$prefix/c";
        }
    }
    my $mntopts = Cygwin::mount_flags($drive);
    if ($mntopts and ($mntopts =~ /,managed/)) {
      return 0;
    }
    eval { require Win32API::File; } or return 1;
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  1;
DARWIN-2LEVEL_FILE_SPEC_CYGWIN

$fatpacked{"darwin-2level/File/Spec/Epoc.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_EPOC';
  package File::Spec::Epoc;
  
  use strict;
  use vars qw($VERSION @ISA);
  
  $VERSION = '3.33';
  $VERSION = eval $VERSION;
  
  require File::Spec::Unix;
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Epoc - methods for Epoc file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Epoc; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  This package is still work in progress ;-)
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =pod
  
  =over 4
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  
  =back
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                        # xx/././xx -> xx/xx
      $path =~ s|^(\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(\.\./)+|/|s;                     # /../../xx -> xx
      $path =~  s|/\Z(?!\n)|| unless $path eq "/";          # xx/       -> xx
      return $path;
  }
  
  =pod
  
  =head1 AUTHOR
  
  o.flebbe@gmx.de
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
DARWIN-2LEVEL_FILE_SPEC_EPOC

$fatpacked{"darwin-2level/File/Spec/Functions.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_FUNCTIONS';
  package File::Spec::Functions;
  
  use File::Spec;
  use strict;
  
  use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);
  
  $VERSION = '3.33';
  $VERSION = eval $VERSION;
  
  require Exporter;
  
  @ISA = qw(Exporter);
  
  @EXPORT = qw(
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  );
  
  @EXPORT_OK = qw(
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  );
  
  %EXPORT_TAGS = ( ALL => [ @EXPORT_OK, @EXPORT ] );
  
  foreach my $meth (@EXPORT, @EXPORT_OK) {
      my $sub = File::Spec->can($meth);
      no strict 'refs';
      *{$meth} = sub {&$sub('File::Spec', @_)};
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::Functions - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec::Functions;
  	$x = catfile('a','b');
  
  =head1 DESCRIPTION
  
  This module exports convenience functions for all of the class methods
  provided by File::Spec.
  
  For a reference of available functions, please consult L<File::Spec::Unix>,
  which contains the entire set, and which is inherited by the modules for
  other platforms. For further information, please see L<File::Spec::Mac>,
  L<File::Spec::OS2>, L<File::Spec::Win32>, or L<File::Spec::VMS>.
  
  =head2 Exports
  
  The following functions are exported by default.
  
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  
  
  The following functions are exported only by request.
  
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  
  All the functions may be imported using the C<:ALL> tag.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  File::Spec, File::Spec::Unix, File::Spec::Mac, File::Spec::OS2,
  File::Spec::Win32, File::Spec::VMS, ExtUtils::MakeMaker
  
  =cut
  
DARWIN-2LEVEL_FILE_SPEC_FUNCTIONS

$fatpacked{"darwin-2level/File/Spec/Mac.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_MAC';
  package File::Spec::Mac;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.33';
  $VERSION = eval $VERSION;
  
  @ISA = qw(File::Spec::Unix);
  
  my $macfiles;
  if ($^O eq 'MacOS') {
  	$macfiles = eval { require Mac::Files };
  }
  
  sub case_tolerant { 1 }
  
  
  =head1 NAME
  
  File::Spec::Mac - File::Spec for Mac OS (Classic)
  
  =head1 SYNOPSIS
  
   require File::Spec::Mac; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  
  On Mac OS, there's nothing to be done. Returns what it's given.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return $path;
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a path separated by colons
  (":") ending with a directory. Resulting paths are B<relative> by default,
  but can be forced to be absolute (but avoid this, see below). Automatically
  puts a trailing ":" on the end of the complete path, because that's what's
  done in MacPerl's environment and helps to distinguish a file path from a
  directory path.
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the resulting
  path is relative by default and I<not> absolute. This decision was made due
  to portability reasons. Since C<File::Spec-E<gt>catdir()> returns relative paths
  on all other operating systems, it will now also follow this convention on Mac
  OS. Note that this may break some existing scripts.
  
  The intended purpose of this routine is to concatenate I<directory names>.
  But because of the nature of Macintosh paths, some additional possibilities
  are allowed to make using this routine give reasonable results for some
  common situations. In other words, you are also allowed to concatenate
  I<paths> instead of directory names (strictly speaking, a string like ":a"
  is a path, but not a name, since it contains a punctuation character ":").
  
  So, beside calls like
  
      catdir("a") = ":a:"
      catdir("a","b") = ":a:b:"
      catdir() = ""                    (special case)
  
  calls like the following
  
      catdir(":a:") = ":a:"
      catdir(":a","b") = ":a:b:"
      catdir(":a:","b") = ":a:b:"
      catdir(":a:",":b:") = ":a:b:"
      catdir(":") = ":"
  
  are allowed.
  
  Here are the rules that are used in C<catdir()>; note that we try to be as
  compatible as possible to Unix:
  
  =over 2
  
  =item 1.
  
  The resulting path is relative by default, i.e. the resulting path will have a
  leading colon.
  
  =item 2.
  
  A trailing colon is added automatically to the resulting path, to denote a
  directory.
  
  =item 3.
  
  Generally, each argument has one leading ":" and one trailing ":"
  removed (if any). They are then joined together by a ":". Special
  treatment applies for arguments denoting updir paths like "::lib:",
  see (4), or arguments consisting solely of colons ("colon paths"),
  see (5).
  
  =item 4.
  
  When an updir path like ":::lib::" is passed as argument, the number
  of directories to climb up is handled correctly, not removing leading
  or trailing colons when necessary. E.g.
  
      catdir(":::a","::b","c")    = ":::a::b:c:"
      catdir(":::a::","::b","c")  = ":::a:::b:c:"
  
  =item 5.
  
  Adding a colon ":" or empty string "" to a path at I<any> position
  doesn't alter the path, i.e. these arguments are ignored. (When a ""
  is passed as the first argument, it has a special meaning, see
  (6)). This way, a colon ":" is handled like a "." (curdir) on Unix,
  while an empty string "" is generally ignored (see
  C<Unix-E<gt>canonpath()> ). Likewise, a "::" is handled like a ".."
  (updir), and a ":::" is handled like a "../.." etc.  E.g.
  
      catdir("a",":",":","b")   = ":a:b:"
      catdir("a",":","::",":b") = ":a::b:"
  
  =item 6.
  
  If the first argument is an empty string "" or is a volume name, i.e. matches
  the pattern /^[^:]+:/, the resulting path is B<absolute>.
  
  =item 7.
  
  Passing an empty string "" as the first argument to C<catdir()> is
  like passingC<File::Spec-E<gt>rootdir()> as the first argument, i.e.
  
      catdir("","a","b")          is the same as
  
      catdir(rootdir(),"a","b").
  
  This is true on Unix, where C<catdir("","a","b")> yields "/a/b" and
  C<rootdir()> is "/". Note that C<rootdir()> on Mac OS is the startup
  volume, which is the closest in concept to Unix' "/". This should help
  to run existing scripts originally written for Unix.
  
  =item 8.
  
  For absolute paths, some cleanup is done, to ensure that the volume
  name isn't immediately followed by updirs. This is invalid, because
  this would go beyond "root". Generally, these cases are handled like
  their Unix counterparts:
  
   Unix:
      Unix->catdir("","")                 =  "/"
      Unix->catdir("",".")                =  "/"
      Unix->catdir("","..")               =  "/"              # can't go beyond root
      Unix->catdir("",".","..","..","a")  =  "/a"
   Mac:
      Mac->catdir("","")                  =  rootdir()         # (e.g. "HD:")
      Mac->catdir("",":")                 =  rootdir()
      Mac->catdir("","::")                =  rootdir()         # can't go beyond root
      Mac->catdir("",":","::","::","a")   =  rootdir() . "a:"  # (e.g. "HD:a:")
  
  However, this approach is limited to the first arguments following
  "root" (again, see C<Unix-E<gt>canonpath()> ). If there are more
  arguments that move up the directory tree, an invalid path going
  beyond root can be created.
  
  =back
  
  As you've seen, you can force C<catdir()> to create an absolute path
  by passing either an empty string or a path that begins with a volume
  name as the first argument. However, you are strongly encouraged not
  to do so, since this is done only for backward compatibility. Newer
  versions of File::Spec come with a method called C<catpath()> (see
  below), that is designed to offer a portable solution for the creation
  of absolute paths.  It takes volume, directory and file portions and
  returns an entire path. While C<catdir()> is still suitable for the
  concatenation of I<directory names>, you are encouraged to use
  C<catpath()> to concatenate I<volume names> and I<directory
  paths>. E.g.
  
      $dir      = File::Spec->catdir("tmp","sources");
      $abs_path = File::Spec->catpath("MacintoshHD:", $dir,"");
  
  yields
  
      "MacintoshHD:tmp:sources:" .
  
  =cut
  
  sub catdir {
  	my $self = shift;
  	return '' unless @_;
  	my @args = @_;
  	my $first_arg;
  	my $relative;
  
  	# take care of the first argument
  
  	if ($args[0] eq '')  { # absolute path, rootdir
  		shift @args;
  		$relative = 0;
  		$first_arg = $self->rootdir;
  
  	} elsif ($args[0] =~ /^[^:]+:/) { # absolute path, volume name
  		$relative = 0;
  		$first_arg = shift @args;
  		# add a trailing ':' if need be (may be it's a path like HD:dir)
  		$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  
  	} else { # relative path
  		$relative = 1;
  		if ( $args[0] =~ /^::+\Z(?!\n)/ ) {
  			# updir colon path ('::', ':::' etc.), don't shift
  			$first_arg = ':';
  		} elsif ($args[0] eq ':') {
  			$first_arg = shift @args;
  		} else {
  			# add a trailing ':' if need be
  			$first_arg = shift @args;
  			$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  		}
  	}
  
  	# For all other arguments,
  	# (a) ignore arguments that equal ':' or '',
  	# (b) handle updir paths specially:
  	#     '::' 			-> concatenate '::'
  	#     '::' . '::' 	-> concatenate ':::' etc.
  	# (c) add a trailing ':' if need be
  
  	my $result = $first_arg;
  	while (@args) {
  		my $arg = shift @args;
  		unless (($arg eq '') || ($arg eq ':')) {
  			if ($arg =~ /^::+\Z(?!\n)/ ) { # updir colon path like ':::'
  				my $updir_count = length($arg) - 1;
  				while ((@args) && ($args[0] =~ /^::+\Z(?!\n)/) ) { # while updir colon path
  					$arg = shift @args;
  					$updir_count += (length($arg) - 1);
  				}
  				$arg = (':' x $updir_count);
  			} else {
  				$arg =~ s/^://s; # remove a leading ':' if any
  				$arg = "$arg:" unless ($arg =~ /:\Z(?!\n)/); # ensure trailing ':'
  			}
  			$result .= $arg;
  		}#unless
  	}
  
  	if ( ($relative) && ($result !~ /^:/) ) {
  		# add a leading colon if need be
  		$result = ":$result";
  	}
  
  	unless ($relative) {
  		# remove updirs immediately following the volume name
  		$result =~ s/([^:]+:)(:*)(.*)\Z(?!\n)/$1$3/;
  	}
  
  	return $result;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename. Resulting paths are B<relative>
  by default, but can be forced to be absolute (but avoid this).
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the
  resulting path is relative by default and I<not> absolute. This
  decision was made due to portability reasons. Since
  C<File::Spec-E<gt>catfile()> returns relative paths on all other
  operating systems, it will now also follow this convention on Mac OS.
  Note that this may break some existing scripts.
  
  The last argument is always considered to be the file portion. Since
  C<catfile()> uses C<catdir()> (see above) for the concatenation of the
  directory portions (if any), the following with regard to relative and
  absolute paths is true:
  
      catfile("")     = ""
      catfile("file") = "file"
  
  but
  
      catfile("","")        = rootdir()         # (e.g. "HD:")
      catfile("","file")    = rootdir() . file  # (e.g. "HD:file")
      catfile("HD:","file") = "HD:file"
  
  This means that C<catdir()> is called only when there are two or more
  arguments, as one might expect.
  
  Note that the leading ":" is removed from the filename, so that
  
      catfile("a","b","file")  = ":a:b:file"    and
  
      catfile("a","b",":file") = ":a:b:file"
  
  give the same answer.
  
  To concatenate I<volume names>, I<directory paths> and I<filenames>,
  you are encouraged to use C<catpath()> (see below).
  
  =cut
  
  sub catfile {
      my $self = shift;
      return '' unless @_;
      my $file = pop @_;
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $file =~ s/^://s;
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representing the current directory. On Mac OS, this is ":".
  
  =cut
  
  sub curdir {
      return ":";
  }
  
  =item devnull
  
  Returns a string representing the null device. On Mac OS, this is "Dev:Null".
  
  =cut
  
  sub devnull {
      return "Dev:Null";
  }
  
  =item rootdir
  
  Returns a string representing the root directory.  Under MacPerl,
  returns the name of the startup volume, since that's the closest in
  concept, although other volumes aren't rooted there. The name has a
  trailing ":", because that's the correct specification for a volume
  name on Mac OS.
  
  If Mac::Files could not be loaded, the empty string is returned.
  
  =cut
  
  sub rootdir {
  #
  #  There's no real root directory on Mac OS. The name of the startup
  #  volume is returned, since that's the closest in concept.
  #
      return '' unless $macfiles;
      my $system = Mac::Files::FindFolder(&Mac::Files::kOnSystemDisk,
  	&Mac::Files::kSystemFolderType);
      $system =~ s/:.*\Z(?!\n)/:/s;
      return $system;
  }
  
  =item tmpdir
  
  Returns the contents of $ENV{TMPDIR}, if that directory exits or the
  current working directory otherwise. Under MacPerl, $ENV{TMPDIR} will
  contain a path like "MacintoshHD:Temporary Items:", which is a hidden
  directory on your startup volume.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR} );
  }
  
  =item updir
  
  Returns a string representing the parent directory. On Mac OS, this is "::".
  
  =cut
  
  sub updir {
      return "::";
  }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true, if it is an absolute path.
  If the path has a leading ":", it's a relative path. Otherwise, it's an
  absolute path, unless the path doesn't contain any colons, i.e. it's a name
  like "a". In this particular case, the path is considered to be relative
  (i.e. it is considered to be a filename). Use ":" in the appropriate place
  in the path if you want to distinguish unambiguously. As a special case,
  the filename '' is always considered to be absolute. Note that with version
  1.2 of File::Spec::Mac, this does no longer consult the local filesystem.
  
  E.g.
  
      File::Spec->file_name_is_absolute("a");             # false (relative)
      File::Spec->file_name_is_absolute(":a:b:");         # false (relative)
      File::Spec->file_name_is_absolute("MacintoshHD:");  # true (absolute)
      File::Spec->file_name_is_absolute("");              # true (absolute)
  
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      if ($file =~ /:/) {
  	return (! ($file =~ m/^:/s) );
      } elsif ( $file eq '' ) {
          return 1 ;
      } else {
  	return 0; # i.e. a file like "a"
      }
  }
  
  =item path
  
  Returns the null list for the MacPerl application, since the concept is
  usually meaningless under Mac OS. But if you're using the MacPerl tool under
  MPW, it gives back $ENV{Commands} suitably split, as is done in
  :lib:ExtUtils:MM_Mac.pm.
  
  =cut
  
  sub path {
  #
  #  The concept is meaningless under the MacPerl application.
  #  Under MPW, it has a meaning.
  #
      return unless exists $ENV{Commands};
      return split(/,/, $ENV{Commands});
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path, $no_file );
  
  Splits a path into volume, directory, and filename portions.
  
  On Mac OS, assumes that the last part of the path is a filename unless
  $no_file is true or a trailing separator ":" is present.
  
  The volume portion is always returned with a trailing ":". The directory portion
  is always returned with a leading (to denote a relative path) and a trailing ":"
  (to denote a directory). The file portion is always returned I<without> a leading ":".
  Empty portions are returned as empty string ''.
  
  The results can be passed to C<catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file);
  
      if ( $nofile ) {
          ( $volume, $directory ) = $path =~ m|^((?:[^:]+:)?)(.*)|s;
      }
      else {
          $path =~
              m|^( (?: [^:]+: )? )
                 ( (?: .*: )? )
                 ( .* )
               |xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      $volume = '' unless defined($volume);
  	$directory = ":$directory" if ( $volume && $directory ); # take care of "HD::dir"
      if ($directory) {
          # Make sure non-empty directories begin and end in ':'
          $directory .= ':' unless (substr($directory,-1) eq ':');
          $directory = ":$directory" unless (substr($directory,0,1) eq ':');
      } else {
  	$directory = '';
      }
      $file = '' unless defined($file);
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of C<catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories should be only the directory portion of the path on systems
  that have the concept of a volume or that have path syntax that differentiates
  files from directories. Consider using C<splitpath()> otherwise.
  
  Unlike just splitting the directories on the separator, empty directory names
  (C<"">) can be returned. Since C<catdir()> on Mac OS always appends a trailing
  colon to distinguish a directory path from a file path, a single trailing colon
  will be ignored, i.e. there's no empty directory name after it.
  
  Hence, on Mac OS, both
  
      File::Spec->splitdir( ":a:b::c:" );    and
      File::Spec->splitdir( ":a:b::c" );
  
  yield:
  
      ( "a", "b", "::", "c")
  
  while
  
      File::Spec->splitdir( ":a:b::c::" );
  
  yields:
  
      ( "a", "b", "::", "c", "::")
  
  
  =cut
  
  sub splitdir {
  	my ($self, $path) = @_;
  	my @result = ();
  	my ($head, $sep, $tail, $volume, $directories);
  
  	return @result if ( (!defined($path)) || ($path eq '') );
  	return (':') if ($path eq ':');
  
  	( $volume, $sep, $directories ) = $path =~ m|^((?:[^:]+:)?)(:*)(.*)|s;
  
  	# deprecated, but handle it correctly
  	if ($volume) {
  		push (@result, $volume);
  		$sep .= ':';
  	}
  
  	while ($sep || $directories) {
  		if (length($sep) > 1) {
  			my $updir_count = length($sep) - 1;
  			for (my $i=0; $i<$updir_count; $i++) {
  				# push '::' updir_count times;
  				# simulate Unix '..' updirs
  				push (@result, '::');
  			}
  		}
  		$sep = '';
  		if ($directories) {
  			( $head, $sep, $tail ) = $directories =~ m|^((?:[^:]+)?)(:*)(.*)|s;
  			push (@result, $head);
  			$directories = $tail;
  		}
  	}
  	return @result;
  }
  
  
  =item catpath
  
      $path = File::Spec->catpath($volume,$directory,$file);
  
  Takes volume, directory and file portions and returns an entire path. On Mac OS,
  $volume, $directory and $file are concatenated.  A ':' is inserted if need be. You
  may pass an empty string for each portion. If all portions are empty, the empty
  string is returned. If $volume is empty, the result will be a relative path,
  beginning with a ':'. If $volume and $directory are empty, a leading ":" (if any)
  is removed form $file and the remainder is returned. If $file is empty, the
  resulting path will have a trailing ':'.
  
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( (! $volume) && (! $directory) ) {
  	$file =~ s/^:// if $file;
  	return $file ;
      }
  
      # We look for a volume in $volume, then in $directory, but not both
  
      my ($dir_volume, $dir_dirs) = $self->splitpath($directory, 1);
  
      $volume = $dir_volume unless length $volume;
      my $path = $volume; # may be ''
      $path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
  
      if ($directory) {
  	$directory = $dir_dirs if $volume;
  	$directory =~ s/^://; # remove leading ':' if any
  	$path .= $directory;
  	$path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
      }
  
      if ($file) {
  	$file =~ s/^://; # remove leading ':' if any
  	$path .= $file;
      }
  
      return $path;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path and returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then the current working directory is used.
  If $base is relative, then it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  If $path and $base appear to be on two different volumes, we will not
  attempt to resolve the two paths, and we will instead simply return
  $path.  Note that previous versions of this module ignored the volume
  of $base, which resulted in garbage results part of the time.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is relative, it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  Based on code written by Shigio Yamaguchi.
  
  
  =cut
  
  # maybe this should be done in canonpath() ?
  sub _resolve_updirs {
  	my $path = shift @_;
  	my $proceed;
  
  	# resolve any updirs, e.g. "HD:tmp::file" -> "HD:file"
  	do {
  		$proceed = ($path =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/);
  	} while ($proceed);
  
  	return $path;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = $self->_cwd();
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
  	$base = _resolve_updirs( $base ); # resolve updirs in $base
      }
      else {
  	$base = _resolve_updirs( $base );
      }
  
      # Split up paths - ignore $base's file
      my ( $path_vol, $path_dirs, $path_file ) =  $self->splitpath( $path );
      my ( $base_vol, $base_dirs )             =  $self->splitpath( $base );
  
      return $path unless lc( $path_vol ) eq lc( $base_vol );
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_dirs );
      my @basechunks = $self->splitdir( $base_dirs );
  	
      while ( @pathchunks &&
  	    @basechunks &&
  	    lc( $pathchunks[0] ) eq lc( $basechunks[0] ) ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @pathchunks now has the directories to descend in to.
      # ensure relative path, even if @pathchunks is empty
      $path_dirs = $self->catdir( ':', @pathchunks );
  
      # @basechunks now contains the number of directories to climb out of.
      $base_dirs = (':' x @basechunks) . ':' ;
  
      return $self->catpath( '', $self->catdir( $base_dirs, $path_dirs ), $path_file ) ;
  }
  
  =item rel2abs
  
  Converts a relative path to an absolute path:
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then $base is set to the current working
  directory. If $base is relative, then it is converted to absolute form
  using C<rel2abs()>. This means that it is taken to be relative to the
  current working directory.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is already absolute, it is returned and $base is ignored.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base) = @_;
  
      if ( ! $self->file_name_is_absolute($path) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute($base) ) {
              $base = $self->rel2abs($base) ;
          }
  
  	# Split up paths
  
  	# igonore $path's volume
          my ( $path_dirs, $path_file ) = ($self->splitpath($path))[1,2] ;
  
          # ignore $base's file part
  	my ( $base_vol, $base_dirs ) = $self->splitpath($base) ;
  
  	# Glom them together
  	$path_dirs = ':' if ($path_dirs eq '');
  	$base_dirs =~ s/:$//; # remove trailing ':', if any
  	$base_dirs = $base_dirs . $path_dirs;
  
          $path = $self->catpath( $base_vol, $base_dirs, $path_file );
      }
      return $path;
  }
  
  
  =back
  
  =head1 AUTHORS
  
  See the authors list in I<File::Spec>. Mac OS support by Paul Schinder
  <schinder@pobox.com> and Thomas Wegner <wegner_thomas@yahoo.com>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
DARWIN-2LEVEL_FILE_SPEC_MAC

$fatpacked{"darwin-2level/File/Spec/OS2.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_OS2';
  package File::Spec::OS2;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.33';
  $VERSION = eval $VERSION;
  
  @ISA = qw(File::Spec::Unix);
  
  sub devnull {
      return "/dev/nul";
  }
  
  sub case_tolerant {
      return 1;
  }
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m{^([a-z]:)?[\\/]}is);
  }
  
  sub path {
      my $path = $ENV{PATH};
      $path =~ s:\\:/:g;
      my @path = split(';',$path);
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  sub _cwd {
      # In OS/2 the "require Cwd" is unnecessary bloat.
      return Cwd::sys_cwd();
  }
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      my @d = @ENV{qw(TMPDIR TEMP TMP)};	# function call could autovivivy
      $tmpdir = $_[0]->_tmpdir( @d, '/tmp', '/'  );
  }
  
  sub catdir {
      my $self = shift;
      my @args = @_;
      foreach (@args) {
  	tr[\\][/];
          # append a backslash to each argument unless it has one there
          $_ .= "/" unless m{/$};
      }
      return $self->canonpath(join('', @args));
  }
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s/^([a-z]:)/\l$1/s;
      $path =~ s|\\|/|g;
      $path =~ s|([^/])/+|$1/|g;                  # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                     # xx/././xx -> xx/xx
      $path =~ s|^(\./)+(?=[^/])||s;		# ./xx      -> xx
      $path =~ s|/\Z(?!\n)||
               unless $path =~ m#^([a-z]:)?/\Z(?!\n)#si;# xx/       -> xx
      $path =~ s{^/\.\.$}{/};                     # /..    -> /
      1 while $path =~ s{^/\.\.}{};               # /../xx -> /xx
      return $path;
  }
  
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^( (?:[a-zA-Z]:|(?:\\\\|//)[^\\/]+[\\/][^\\/]+)? ) 
                   (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( (?: [a-zA-Z]: |
                        (?:\\\\|//)[^\\/]+[\\/][^\\/]+
                    )?
                  )
                  ( (?:.*[\\\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      split m|[\\/]|, $directories, -1;
  }
  
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      $volume .= $1
          if ( $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '/' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      } else {
          $path = $self->canonpath( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = $self->_cwd();
      } elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
      } else {
          $base = $self->canonpath( $base ) ;
      }
  
      # Split up paths
      my ( $path_volume, $path_directories, $path_file ) = $self->splitpath( $path, 1 ) ;
      my ( $base_volume, $base_directories ) = $self->splitpath( $base, 1 ) ;
      return $path unless $path_volume eq $base_volume;
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # No need to catdir, we know these are well formed.
      $path_directories = CORE::join( '/', @pathchunks );
      $base_directories = CORE::join( '/', @basechunks );
  
      # $base_directories now contains the directories the resulting relative
      # path must ascend out of before it can descend to $path_directory.  So, 
      # replace all names with $parentDir
  
      #FA Need to replace between backslashes...
      $base_directories =~ s|[^\\/]+|..|g ;
  
      # Glue the two together, using a separator if necessary, and preventing an
      # empty result.
  
      #FA Must check that new directories are not empty.
      if ( $path_directories ne '' && $base_directories ne '' ) {
          $path_directories = "$base_directories/$path_directories" ;
      } else {
          $path_directories = "$base_directories$path_directories" ;
      }
  
      return $self->canonpath( 
          $self->catpath( "", $path_directories, $path_file ) 
      ) ;
  }
  
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      if ( ! $self->file_name_is_absolute( $path ) ) {
  
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path, 1 ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base, 1 ) ;
  
          $path = $self->catpath( 
              $base_volume, 
              $self->catdir( $base_directories, $path_directories ), 
              $path_file
          ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::OS2 - methods for OS/2 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::OS2; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  Amongst the changes made for OS/2 are...
  
  =over 4
  
  =item tmpdir
  
  Modifies the list of places temp directory information is looked for.
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      /tmp
      /
  
  =item splitpath
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_FILE_SPEC_OS2

$fatpacked{"darwin-2level/File/Spec/Unix.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_UNIX';
  package File::Spec::Unix;
  
  use strict;
  use vars qw($VERSION);
  
  $VERSION = '3.33';
  $VERSION = eval $VERSION;
  
  =head1 NAME
  
  File::Spec::Unix - File::Spec for Unix, base for other File::Spec modules
  
  =head1 SYNOPSIS
  
   require File::Spec::Unix; # Done automatically by File::Spec
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.  Other File::Spec
  modules, such as File::Spec::Mac, inherit from File::Spec::Unix and
  override specific methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminates successive slashes and successive "/.".
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
      
      # Handle POSIX-style node names beginning with double slash (qnx, nto)
      # (POSIX says: "a pathname that begins with two successive slashes
      # may be interpreted in an implementation-defined manner, although
      # more than two leading slashes shall be treated as a single slash.")
      my $node = '';
      my $double_slashes_special = $^O eq 'qnx' || $^O eq 'nto';
  
  
      if ( $double_slashes_special
           && ( $path =~ s{^(//[^/]+)/?\z}{}s || $path =~ s{^(//[^/]+)/}{/}s ) ) {
        $node = $1;
      }
      # This used to be
      # $path =~ s|/+|/|g unless ($^O eq 'cygwin');
      # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail
      # (Mainly because trailing "" directories didn't get stripped).
      # Why would cygwin avoid collapsing multiple slashes into one? --jhi
      $path =~ s|/{2,}|/|g;                            # xx////xx  -> xx/xx
      $path =~ s{(?:/\.)+(?:/|\z)}{/}g;                # xx/././xx -> xx/xx
      $path =~ s|^(?:\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(?:\.\./)+|/|;                      # /../../xx -> xx
      $path =~ s|^/\.\.$|/|;                         # /..       -> /
      $path =~ s|/\z|| unless $path eq "/";          # xx/       -> xx
      return "$node$path";
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
  =cut
  
  sub catdir {
      my $self = shift;
  
      $self->canonpath(join('/', @_, '')); # '' because need a trailing '/'
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $file = $self->canonpath(pop @_);
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $dir .= "/" unless substr($dir,-1) eq "/";
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representation of the current directory.  "." on UNIX.
  
  =cut
  
  sub curdir { '.' }
  
  =item devnull
  
  Returns a string representation of the null device. "/dev/null" on UNIX.
  
  =cut
  
  sub devnull { '/dev/null' }
  
  =item rootdir
  
  Returns a string representation of the root directory.  "/" on UNIX.
  
  =cut
  
  sub rootdir { '/' }
  
  =item tmpdir
  
  Returns a string representation of the first writable directory from
  the following list or the current directory if none from the list are
  writable:
  
      $ENV{TMPDIR}
      /tmp
  
  Since perl 5.8.0, if running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my $tmpdir;
  sub _tmpdir {
      return $tmpdir if defined $tmpdir;
      my $self = shift;
      my @dirlist = @_;
      {
  	no strict 'refs';
  	if (${"\cTAINT"}) { # Check for taint mode on perl >= 5.8.0
              require Scalar::Util;
  	    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;
  	}
      }
      foreach (@dirlist) {
  	next unless defined && -d && -w _;
  	$tmpdir = $_;
  	last;
      }
      $tmpdir = $self->curdir unless defined $tmpdir;
      $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);
      return $tmpdir;
  }
  
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp" );
  }
  
  =item updir
  
  Returns a string representation of the parent directory.  ".." on UNIX.
  
  =cut
  
  sub updir { '..' }
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
  =cut
  
  sub no_upwards {
      my $self = shift;
      return grep(!/^\.{1,2}\z/s, @_);
  }
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  is not or is significant when comparing file specifications.
  
  =cut
  
  sub case_tolerant { 0 }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true if it is an absolute path.
  
  This does not consult the local filesystem on Unix, Win32, OS/2 or Mac 
  OS (Classic).  It does consult the working environment for VMS (see
  L<File::Spec::VMS/file_name_is_absolute>).
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m:^/:s);
  }
  
  =item path
  
  Takes no argument, returns the environment variable PATH as an array.
  
  =cut
  
  sub path {
      return () unless exists $ENV{PATH};
      my @path = split(':', $ENV{PATH});
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  =item join
  
  join is the same as catfile.
  
  =cut
  
  sub join {
      my $self = shift;
      return $self->catfile(@_);
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path, $no_file );
  
  Splits a path into volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless $no_file is true or a 
  trailing separator or /. or /.. is present. On Unix this means that $no_file
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
  
      my ($volume,$directory,$file) = ('','','');
  
      if ( $nofile ) {
          $directory = $path;
      }
      else {
          $path =~ m|^ ( (?: .* / (?: \.\.?\z )? )? ) ([^/]*) |xs;
          $directory = $1;
          $file      = $2;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L</catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSs.
  
  On Unix,
  
      File::Spec->splitdir( "/a/b//c/" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      return split m|/|, $_[1], -1;  # Preserve trailing fields
  }
  
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and directory and file are concatenated.  A '/' is
  inserted if needed (though if the directory portion doesn't start with
  '/' it is not added).  On other OSs, $volume is significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( $directory ne ''                && 
           $file ne ''                     && 
           substr( $directory, -1 ) ne '/' && 
           substr( $file, 0, 1 ) ne '/' 
      ) {
          $directory .= "/$file" ;
      }
      else {
          $directory .= $file ;
      }
  
      return $directory ;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<cwd()|Cwd>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub abs2rel {
      my($self,$path,$base) = @_;
      $base = $self->_cwd() unless defined $base and length $base;
  
      ($path, $base) = map $self->canonpath($_), $path, $base;
  
      if (grep $self->file_name_is_absolute($_), $path, $base) {
  	($path, $base) = map $self->rel2abs($_), $path, $base;
      }
      else {
  	# save a couple of cwd()s if both paths are relative
  	($path, $base) = map $self->catdir('/', $_), $path, $base;
      }
  
      my ($path_volume) = $self->splitpath($path, 1);
      my ($base_volume) = $self->splitpath($base, 1);
  
      # Can't relativize across volumes
      return $path unless $path_volume eq $base_volume;
  
      my $path_directories = ($self->splitpath($path, 1))[1];
      my $base_directories = ($self->splitpath($base, 1))[1];
  
      # For UNC paths, the user might give a volume like //foo/bar that
      # strictly speaking has no directory portion.  Treat it as if it
      # had the root directory for that volume.
      if (!length($base_directories) and $self->file_name_is_absolute($base)) {
        $base_directories = $self->rootdir;
      }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      if ($base_directories eq $self->rootdir) {
        shift @pathchunks;
        return $self->canonpath( $self->catpath('', $self->catdir( @pathchunks ), '') );
      }
  
      while (@pathchunks && @basechunks && $self->_same($pathchunks[0], $basechunks[0])) {
          shift @pathchunks ;
          shift @basechunks ;
      }
      return $self->curdir unless @pathchunks || @basechunks;
  
      # $base now contains the directories the resulting relative path 
      # must ascend out of before it can descend to $path_directory.
      my $result_dirs = $self->catdir( ($self->updir) x @basechunks, @pathchunks );
      return $self->canonpath( $self->catpath('', $result_dirs, '') );
  }
  
  sub _same {
    $_[1] eq $_[2];
  }
  
  =item rel2abs()
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores
  the $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is absolute, it is cleaned up and returned using L</canonpath()>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Glom them together
          $path = $self->catdir( $base, $path ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<File::Spec>
  
  =cut
  
  # Internal routine to File::Spec, no point in making this public since
  # it is the standard Cwd interface.  Most of the platform-specific
  # File::Spec subclasses use this.
  sub _cwd {
      require Cwd;
      Cwd::getcwd();
  }
  
  
  # Internal method to reduce xx\..\yy -> yy
  sub _collapse {
      my($fs, $path) = @_;
  
      my $updir  = $fs->updir;
      my $curdir = $fs->curdir;
  
      my($vol, $dirs, $file) = $fs->splitpath($path);
      my @dirs = $fs->splitdir($dirs);
      pop @dirs if @dirs && $dirs[-1] eq '';
  
      my @collapsed;
      foreach my $dir (@dirs) {
          if( $dir eq $updir              and   # if we have an updir
              @collapsed                  and   # and something to collapse
              length $collapsed[-1]       and   # and its not the rootdir
              $collapsed[-1] ne $updir    and   # nor another updir
              $collapsed[-1] ne $curdir         # nor the curdir
            ) 
          {                                     # then
              pop @collapsed;                   # collapse
          }
          else {                                # else
              push @collapsed, $dir;            # just hang onto it
          }
      }
  
      return $fs->catpath($vol,
                          $fs->catdir(@collapsed),
                          $file
                         );
  }
  
  
  1;
DARWIN-2LEVEL_FILE_SPEC_UNIX

$fatpacked{"darwin-2level/File/Spec/VMS.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_VMS';
  package File::Spec::VMS;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.33';
  $VERSION = eval $VERSION;
  
  @ISA = qw(File::Spec::Unix);
  
  use File::Basename;
  use VMS::Filespec;
  
  =head1 NAME
  
  File::Spec::VMS - methods for VMS file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::VMS; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  The default behavior is to allow either VMS or Unix syntax on input and to 
  return VMS syntax on output, even when Unix syntax was given on input.
  
  When used with a Perl of version 5.10 or greater and a CRTL possessing the
  relevant capabilities, override behavior depends on the CRTL features
  C<DECC$FILENAME_UNIX_REPORT> and C<DECC$EFS_CHARSET>.  When the
  C<DECC$EFS_CHARSET> feature is enabled and the input parameters are clearly
  in Unix syntax, the output will be in Unix syntax.  If
  C<DECC$FILENAME_UNIX_REPORT> is enabled and the output syntax cannot be
  determined from the input syntax, the output will be in Unix syntax.
  
  =over 4
  
  =cut
  
  # Need to look up the feature settings.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_feature;
  BEGIN {
      if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
          $use_feature = 1;
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _unix_rpt {
      my $unix_rpt;
      if ($use_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  # Need to look up the EFS character set mode.  This may become a dynamic
  # mode in the future.
  sub _efs {
      my $efs;
      if ($use_feature) {
          $efs = VMS::Feature::current("efs_charset");
      } else {
          my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
          $efs = $env_efs =~ /^[ET1]/i; 
      }
      return $efs;
  }
  
  =item canonpath (override)
  
  Removes redundant portions of file specifications according to the syntax
  detected.
  
  =cut
  
  
  sub canonpath {
      my($self,$path) = @_;
  
      return undef unless defined $path;
  
      my $efs = $self->_efs;
  
      if ($path =~ m|/|) { # Fake Unix
        my $pathify = $path =~ m|/\Z(?!\n)|;
        $path = $self->SUPER::canonpath($path);
  
        # Do not convert to VMS when EFS character sets are in use
        return $path if $efs;
  
        if ($pathify) { return vmspath($path); }
        else          { return vmsify($path);  }
      }
      else {
  
  #FIXME - efs parsing has different rules.  Characters in a VMS filespec
  #        are only delimiters if not preceded by '^';
  
  	$path =~ tr/<>/[]/;			# < and >       ==> [ and ]
  	$path =~ s/\]\[\./\.\]\[/g;		# ][.		==> .][
  	$path =~ s/\[000000\.\]\[/\[/g;		# [000000.][	==> [
  	$path =~ s/\[000000\./\[/g;		# [000000.	==> [
  	$path =~ s/\.\]\[000000\]/\]/g;		# .][000000]	==> ]
  	$path =~ s/\.\]\[/\./g;			# foo.][bar     ==> foo.bar
  	1 while ($path =~ s/([\[\.])(-+)\.(-+)([\.\]])/$1$2$3$4/);
  						# That loop does the following
  						# with any amount of dashes:
  						# .-.-.		==> .--.
  						# [-.-.		==> [--.
  						# .-.-]		==> .--]
  						# [-.-]		==> [--]
  	1 while ($path =~ s/([\[\.])[^\]\.]+\.-(-+)([\]\.])/$1$2$3/);
  						# That loop does the following
  						# with any amount (minimum 2)
  						# of dashes:
  						# .foo.--.	==> .-.
  						# .foo.--]	==> .-]
  						# [foo.--.	==> [-.
  						# [foo.--]	==> [-]
  						#
  						# And then, the remaining cases
  	$path =~ s/\[\.-/[-/;			# [.-		==> [-
  	$path =~ s/\.[^\]\.]+\.-\./\./g;	# .foo.-.	==> .
  	$path =~ s/\[[^\]\.]+\.-\./\[/g;	# [foo.-.	==> [
  	$path =~ s/\.[^\]\.]+\.-\]/\]/g;	# .foo.-]	==> ]
  	$path =~ s/\[[^\]\.]+\.-\]/\[000000\]/g;# [foo.-]       ==> [000000]
  	$path =~ s/\[\]// unless $path eq '[]';	# []		==>
  	return $path;
      }
  }
  
  =item catdir (override)
  
  Concatenates a list of file specifications, and returns the result as a
  directory specification.  No check is made for "impossible"
  cases (e.g. elements other than the first being absolute filespecs).
  
  =cut
  
  sub catdir {
      my $self = shift;
      my $dir = pop;
  
      my $efs = $self->_efs;
      my $unix_rpt = $self->_unix_rpt;
  
  
      my @dirs = grep {defined() && length()} @_;
      if ($efs) {
          # Legacy mode removes blank entries.
          # But that breaks existing generic perl code that
          # uses a blank path at the beginning of the array
          # to indicate an absolute path.
          # So put it back if found.
          if (@_) {
              if ($_[0] eq '') {
                  unshift @dirs, '';
              }
          }
      }
  
      my $rslt;
      if (@dirs) {
  	my $path = (@dirs == 1 ? $dirs[0] : $self->catdir(@dirs));
  	my ($spath,$sdir) = ($path,$dir);
  
          if ($efs) {
              # Extended character set in use, go into DWIM mode.
  
              # Now we need to identify what the directory is in
              # of the specification in order to merge them.
              my $path_unix = 0;
              $path_unix = 1 if ($path =~ m#/#);
              $path_unix = 1 if ($path =~ /^\.\.?$/);
              my $path_vms = 0;
              $path_vms = 1 if ($path =~ m#(?<!\^)[\[<\]:]#);
              $path_vms = 1 if ($path =~ /^--?$/);
              my $dir_unix = 0;
              $dir_unix = 1 if ($dir =~ m#/#);
              $dir_unix = 1 if ($dir =~ /^\.\.?$/);
              my $dir_vms = 0;
              $dir_vms = 1 if ($dir =~ m#(?<!\^)[\[<\]:]#);
              $dir_vms = 1 if ($dir =~ /^--?$/);
  
              my $unix_mode = 0;
              if (($path_unix != $dir_unix) && ($path_vms != $dir_vms)) {
                  # Ambiguous, so if in $unix_rpt mode then assume UNIX.
                  $unix_mode = 1 if $unix_rpt;
              } else {
                  $unix_mode = 1 if (!$path_vms && !$dir_vms && $unix_rpt);
                  $unix_mode = 1 if ($path_unix || $dir_unix);
              }
  
              if ($unix_mode) {
  
                  # Fix up mixed syntax imput as good as possible - GIGO
                  $path = unixify($path) if $path_vms;
                  $dir = unixify($dir) if $dir_vms;
  
                  $rslt = $path;
                  # Append a path delimiter
                  $rslt .= '/' unless ($rslt =~ m#/$#);
  
                  $rslt .= $dir;
                  return $self->SUPER::canonpath($rslt);
              } else {
  
                  #with <> posible instead of [.
                  # Normalize the brackets
                  # Fixme - need to not switch when preceded by ^.
                  $path =~ s/</\[/g;
                  $path =~ s/>/\]/g;
                  $dir =~ s/</\[/g;
                  $dir =~ s/>/\]/g;
  
                  # Fix up mixed syntax imput as good as possible - GIGO
                  $path = vmsify($path) if $path_unix;
                  $dir = vmsify($dir) if $dir_unix;
  
                  #Possible path values: foo: [.foo] [foo] foo, and $(foo)
                  #or starting with '-', or foo.dir
                  #If path is foo, it needs to be converted to [.foo]
  
                  # Fix up a bare path name.
                  unless ($path_vms) {
                      $path =~ s/\.dir\Z(?!\n)//i;
                      if (($path ne '') && ($path !~ /^-/)) {
                          # Non blank and not prefixed with '-', add a dot
                          $path = '[.' . $path;
                      } else {
                          # Just start a directory.
                          $path = '[' . $path;
                      }
                  } else {
                      $path =~ s/\]$//;
                  }
  
                  #Possible dir values: [.dir] dir and $(foo)
  
                  # No punctuation may have a trailing .dir
                  unless ($dir_vms) {
                      $dir =~ s/\.dir\Z(?!\n)//i;
                  } else {
  
                      #strip off the brackets
                      $dir =~ s/^\[//;
                      $dir =~ s/\]$//;
                  }
  
                  #strip off the leading dot if present.
                  $dir =~ s/^\.//;
  
                  # Now put the specifications together.
                  if ($dir ne '') {
                      # Add a separator unless this is an absolute path
                      $path .= '.' if ($path ne '[');
                      $rslt = $path . $dir . ']';
                  } else {
                      $rslt = $path . ']';
                  }
              }
  
  	} else {
  	    # Traditional ODS-2 mode.
  	    $spath =~ s/\.dir\Z(?!\n)//i; $sdir =~ s/\.dir\Z(?!\n)//i; 
  
  	    $sdir = $self->eliminate_macros($sdir)
  		unless $sdir =~ /^[\w\-]+\Z(?!\n)/s;
  	    $rslt = $self->fixpath($self->eliminate_macros($spath)."/$sdir",1);
  
  	    # Special case for VMS absolute directory specs: these will have
  	    # had device prepended during trip through Unix syntax in
  	    # eliminate_macros(), since Unix syntax has no way to express
  	    # "absolute from the top of this device's directory tree".
  	    if ($spath =~ /^[\[<][^.\-]/s) { $rslt =~ s/^[^\[<]+//s; }
  	} 
      } else {
  	# Single directory, just make sure it is in directory format
  	# Return an empty string on null input, and pass through macros.
  
  	if    (not defined $dir or not length $dir) { $rslt = ''; }
  	elsif ($dir =~ /^\$\([^\)]+\)\Z(?!\n)/s) { 
  	    $rslt = $dir;
  	} else {
              my $unix_mode = 0;
  
              if ($efs) {
                  my $dir_unix = 0;
                  $dir_unix = 1 if ($dir =~ m#/#);
                  $dir_unix = 1 if ($dir =~ /^\.\.?$/);
                  my $dir_vms = 0;
                  $dir_vms = 1 if ($dir =~ m#(?<!\^)[\[<\]:]#);
                  $dir_vms = 1 if ($dir =~ /^--?$/);
  
                  if ($dir_vms == $dir_unix) {
                      # Ambiguous, so if in $unix_rpt mode then assume UNIX.
                      $unix_mode = 1 if $unix_rpt;
                  } else {
                      $unix_mode = 1 if $dir_unix;
                  }
              }
  
              if ($unix_mode) {
                  return $dir;
              } else {
                  # For VMS, force it to be in directory format
  	 	$rslt = vmspath($dir);
  	    }
  	}
      }
      return $self->canonpath($rslt);
  }
  
  =item catfile (override)
  
  Concatenates a list of directory specifications with a filename specification
  to build a path.
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $tfile = pop();
      my $file = $self->canonpath($tfile);
      my @files = grep {defined() && length()} @_;
  
      my $efs = $self->_efs;
      my $unix_rpt = $self->_unix_rpt;
  
      # Assume VMS mode
      my $unix_mode = 0;
      my $file_unix = 0;
      my $file_vms = 0;
      if ($efs) {
  
          # Now we need to identify format the file is in
          # of the specification in order to merge them.
          $file_unix = 1 if ($tfile =~ m#/#);
          $file_unix = 1 if ($tfile =~ /^\.\.?$/);
          $file_vms = 1 if ($tfile =~ m#(?<!\^)[\[<\]:]#);
          $file_vms = 1 if ($tfile =~ /^--?$/);
  
          # We may know for sure what the format is.
          if (($file_unix != $file_vms)) {
              $unix_mode = 1 if ($file_unix && $unix_rpt);
          }
      }
  
      my $rslt;
      if (@files) {
  	# concatenate the directories.
  	my $path;
          if (@files == 1) {
             $path = $files[0];
          } else {
              if ($file_vms) {
                  # We need to make sure this is in VMS mode to avoid doing
                  # both a vmsify and unixfy on the same path, as that may
                  # lose significant data.
                  my $i = @files - 1;
                  my $tdir = $files[$i];
                  my $tdir_vms = 0;
                  my $tdir_unix = 0;
                  $tdir_vms = 1 if ($tdir =~ m#(?<!\^)[\[<\]:]#);
                  $tdir_unix = 1 if ($tdir =~ m#/#);
                  $tdir_unix = 1 if ($tdir =~ /^\.\.?$/);
  
                  if (!$tdir_vms) {
                      if ($tdir_unix) { 
                          $tdir = vmspath($tdir);
                      } else {
                          $tdir =~ s/\.dir\Z(?!\n)//i;
                          $tdir = '[.' . $tdir . ']';
                      }
                      $files[$i] = $tdir;
                  }
              }
              $path = $self->catdir(@files);
          }
  	my $spath = $path;
  
          # Some thing building a VMS path in pieces may try to pass a
          # directory name in filename format, so normalize it.
  	$spath =~ s/\.dir\Z(?!\n)//i;
  
          # if the spath ends with a directory delimiter and the file is bare,
          # then just concat them.
  	if ($spath =~ /^(?<!\^)[^\)\]\/:>]+\)\Z(?!\n)/s && basename($file) eq $file) {
  	    $rslt = "$spath$file";
  	} else {
              if ($efs) {
  
                  # Now we need to identify what the directory is in
                  # of the specification in order to merge them.
                  my $spath_unix = 0;
                  $spath_unix = 1 if ($spath =~ m#/#);
                  $spath_unix = 1 if ($spath =~ /^\.\.?$/);
                  my $spath_vms = 0;
                  $spath_vms = 1 if ($spath =~ m#(?<!\^)[\[<\]:]#);
                  $spath_vms = 1 if ($spath =~ /^--?$/);
  
                  # Assume VMS mode
                  if (($spath_unix == $spath_vms) &&
                      ($file_unix == $file_vms)) {
                       # Ambigous, so if in $unix_rpt mode then assume UNIX.
                       $unix_mode = 1 if $unix_rpt;
                  } else {
                       $unix_mode = 1
                           if (($spath_unix || $file_unix) && $unix_rpt);
                  }
  
                  if (!$unix_mode) {
                      if ($spath_vms) {
                          $spath = '[' . $spath . ']' if $spath =~ /^-/;
                          $rslt = vmspath($spath);
                      } else {
                          $rslt = '[.' . $spath . ']';
                      }
                      $file = vmsify($file) if ($file_unix);
                  } else {
                      $spath = unixify($spath) if ($spath_vms);
                      $rslt = $spath;
                      $file = unixify($file) if ($file_vms);
  
                      # Unix merge may need a directory delimitor.
                      # A null path indicates root on Unix.
                      $rslt .= '/' unless ($rslt =~ m#/$#);
                  }
  
                  $rslt .= $file;
                  $rslt =~ s/\]\[//;
  
  	    } else {
  		# Traditional VMS Perl mode expects that this is done.
  		# Note for future maintainers:
  		# This is left here for compatibility with perl scripts
  		# that have come to expect this behavior, even though
  		# usually the Perl scripts ported to VMS have to be
  		# patched because of it changing Unix syntax file
  		# to VMS format.
  
  		$rslt = $self->eliminate_macros($spath);
  
  
  	        $rslt = vmsify($rslt.((defined $rslt) &&
  		    ($rslt ne '') ? '/' : '').unixify($file));
  	    }
  	}
      }
      else {
          # Only passed a single file?
          my $xfile = $file;
  
          # Traditional VMS perl expects this conversion.
          $xfile = vmsify($file) unless ($efs);
  
          $rslt = (defined($file) && length($file)) ? $xfile : '';
      }
      return $self->canonpath($rslt) unless $unix_rpt;
  
      # In Unix report mode, do not strip off redundent path information.
      return $rslt;
  }
  
  
  =item curdir (override)
  
  Returns a string representation of the current directory: '[]' or '.'
  
  =cut
  
  sub curdir {
      my $self = shift @_;
      return '.' if ($self->_unix_rpt);
      return '[]';
  }
  
  =item devnull (override)
  
  Returns a string representation of the null device: '_NLA0:' or '/dev/null'
  
  =cut
  
  sub devnull {
      my $self = shift @_;
      return '/dev/null' if ($self->_unix_rpt);
      return "_NLA0:";
  }
  
  =item rootdir (override)
  
  Returns a string representation of the root directory: 'SYS$DISK:[000000]'
  or '/'
  
  =cut
  
  sub rootdir {
      my $self = shift @_;
      if ($self->_unix_rpt) {
         # Root may exist, try it first.
         my $try = '/';
         my ($dev1, $ino1) = stat('/');
         my ($dev2, $ino2) = stat('.');
  
         # Perl falls back to '.' if it can not determine '/'
         if (($dev1 != $dev2) || ($ino1 != $ino2)) {
             return $try;
         }
         # Fall back to UNIX format sys$disk.
         return '/sys$disk/';
      }
      return 'SYS$DISK:[000000]';
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first writable directory
  from the following list or '' if none are writable:
  
      /tmp if C<DECC$FILENAME_UNIX_REPORT> is enabled.
      sys$scratch:
      $ENV{TMPDIR}
  
  Since perl 5.8.0, if running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      my $self = shift @_;
      return $tmpdir if defined $tmpdir;
      if ($self->_unix_rpt) {
          $tmpdir = $self->_tmpdir('/tmp', '/sys$scratch', $ENV{TMPDIR});
          return $tmpdir;
      }
  
      $tmpdir = $self->_tmpdir( 'sys$scratch:', $ENV{TMPDIR} );
  }
  
  =item updir (override)
  
  Returns a string representation of the parent directory: '[-]' or '..'
  
  =cut
  
  sub updir {
      my $self = shift @_;
      return '..' if ($self->_unix_rpt);
      return '[-]';
  }
  
  =item case_tolerant (override)
  
  VMS file specification syntax is case-tolerant.
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =item path (override)
  
  Translate logical name DCL$PATH as a searchlist, rather than trying
  to C<split> string value of C<$ENV{'PATH'}>.
  
  =cut
  
  sub path {
      my (@dirs,$dir,$i);
      while ($dir = $ENV{'DCL$PATH;' . $i++}) { push(@dirs,$dir); }
      return @dirs;
  }
  
  =item file_name_is_absolute (override)
  
  Checks for VMS directory spec as well as Unix separators.
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      # If it's a logical name, expand it.
      $file = $ENV{$file} while $file =~ /^[\w\$\-]+\Z(?!\n)/s && $ENV{$file};
      return scalar($file =~ m!^/!s             ||
  		  $file =~ m![<\[][^.\-\]>]!  ||
  		  $file =~ /:[^<\[]/);
  }
  
  =item splitpath (override)
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path, $no_file );
  
  Passing a true value for C<$no_file> indicates that the path being
  split only contains directory components, even on systems where you
  can usually (when not supporting a foreign syntax) tell the difference
  between directories and files at a glance.
  
  =cut
  
  sub splitpath {
      my($self,$path, $nofile) = @_;
      my($dev,$dir,$file)      = ('','','');
      my $efs = $self->_efs;
      my $vmsify_path = vmsify($path);
      if ($efs) {
          my $path_vms = 0;
          $path_vms = 1 if ($path =~ m#(?<!\^)[\[<\]:]#);
          $path_vms = 1 if ($path =~ /^--?$/);
          if (!$path_vms) {
              return $self->SUPER::splitpath($path, $nofile);
          }
          $vmsify_path = $path;
      }
  
      if ( $nofile ) {
          #vmsify('d1/d2/d3') returns '[.d1.d2]d3'
          #vmsify('/d1/d2/d3') returns 'd1:[d2]d3'
          if( $vmsify_path =~ /(.*)\](.+)/ ){
              $vmsify_path = $1.'.'.$2.']';
          }
          $vmsify_path =~ /(.+:)?(.*)/s;
          $dir = defined $2 ? $2 : ''; # dir can be '0'
          return ($1 || '',$dir,$file);
      }
      else {
          $vmsify_path =~ /(.+:)?([\[<].*[\]>])?(.*)/s;
          return ($1 || '',$2 || '',$3);
      }
  }
  
  =item splitdir (override)
  
  Split a directory specification into the components.
  
  =cut
  
  sub splitdir {
      my($self,$dirspec) = @_;
      my @dirs = ();
      return @dirs if ( (!defined $dirspec) || ('' eq $dirspec) );
  
      my $efs = $self->_efs;
  
      my $dir_unix = 0;
      $dir_unix = 1 if ($dirspec =~ m#/#);
      $dir_unix = 1 if ($dirspec =~ /^\.\.?$/);
  
      # Unix filespecs in EFS mode handled by Unix routines.
      if ($efs && $dir_unix) {
          return $self->SUPER::splitdir($dirspec);
      }
  
      # FIX ME, only split for VMS delimiters not prefixed with '^'.
  
      $dirspec =~ tr/<>/[]/;			# < and >	==> [ and ]
      $dirspec =~ s/\]\[\./\.\]\[/g;		# ][.		==> .][
      $dirspec =~ s/\[000000\.\]\[/\[/g;		# [000000.][	==> [
      $dirspec =~ s/\[000000\./\[/g;		# [000000.	==> [
      $dirspec =~ s/\.\]\[000000\]/\]/g;		# .][000000]	==> ]
      $dirspec =~ s/\.\]\[/\./g;			# foo.][bar	==> foo.bar
      while ($dirspec =~ s/(^|[\[\<\.])\-(\-+)($|[\]\>\.])/$1-.$2$3/g) {}
  						# That loop does the following
  						# with any amount of dashes:
  						# .--.		==> .-.-.
  						# [--.		==> [-.-.
  						# .--]		==> .-.-]
  						# [--]		==> [-.-]
      $dirspec = "[$dirspec]" unless $dirspec =~ /(?<!\^)[\[<]/; # make legal
      $dirspec =~ s/^(\[|<)\./$1/;
      @dirs = split /(?<!\^)\./, vmspath($dirspec);
      $dirs[0] =~ s/^[\[<]//s;  $dirs[-1] =~ s/[\]>]\Z(?!\n)//s;
      @dirs;
  }
  
  
  =item catpath (override)
  
  Construct a complete filespec.
  
  =cut
  
  sub catpath {
      my($self,$dev,$dir,$file) = @_;
      
      my $efs = $self->_efs;
      my $unix_rpt = $self->_unix_rpt;
  
      my $unix_mode = 0;
      my $dir_unix = 0;
      $dir_unix = 1 if ($dir =~ m#/#);
      $dir_unix = 1 if ($dir =~ /^\.\.?$/);
      my $dir_vms = 0;
      $dir_vms = 1 if ($dir =~ m#(?<!\^)[\[<\]:]#);
      $dir_vms = 1 if ($dir =~ /^--?$/);
  
      if ($efs && (length($dev) == 0)) {
          if ($dir_unix == $dir_vms) {
              $unix_mode = $unix_rpt;
          } else {
              $unix_mode = $dir_unix;
          }
      } 
  
      # We look for a volume in $dev, then in $dir, but not both
      # but only if using VMS syntax.
      if (!$unix_mode) {
          $dir = vmspath($dir) if $dir_unix;
          my ($dir_volume, $dir_dir, $dir_file) = $self->splitpath($dir);
          $dev = $dir_volume unless length $dev;
          $dir = length $dir_file ? $self->catfile($dir_dir, $dir_file) :
                                    $dir_dir;
      }
      if ($dev =~ m|^/+([^/]+)|) { $dev = "$1:"; }
      else { $dev .= ':' unless $dev eq '' or $dev =~ /:\Z(?!\n)/; }
      if (length($dev) or length($dir)) {
        if ($efs) {
            if ($unix_mode) {
                $dir .= '/' unless ($dir =~ m#/$#);
            } else {
                $dir = vmspath($dir) if (($dir =~ m#/#) || ($dir =~ /^\.\.?$/));
                $dir = "[$dir]" unless $dir =~ /^[\[<]/;
            }
        } else {
            $dir = "[$dir]" unless $dir =~ /[\[<\/]/;
            $dir = vmspath($dir);
        }
      }
      $dir = '' if length($dev) && ($dir eq '[]' || $dir eq '<>');
      "$dev$dir$file";
  }
  
  =item abs2rel (override)
  
  Attempt to convert a file specification to a relative specification.
  On a system with volumes, like VMS, this may not be possible.
  
  =cut
  
  sub abs2rel {
      my $self = shift;
      my($path,$base) = @_;
  
      my $efs = $self->_efs;
      my $unix_rpt = $self->_unix_rpt;
  
      # We need to identify what the directory is in
      # of the specification in order to process them
      my $path_unix = 0;
      $path_unix = 1 if ($path =~ m#/#);
      $path_unix = 1 if ($path =~ /^\.\.?$/);
      my $path_vms = 0;
      $path_vms = 1 if ($path =~ m#(?<!\^)[\[<\]:]#);
      $path_vms = 1 if ($path =~ /^--?$/);
  
      my $unix_mode = 0;
      if ($path_vms == $path_unix) {
          $unix_mode = $unix_rpt;
      } else {
          $unix_mode = $path_unix;
      }
  
      my $base_unix = 0;
      my $base_vms = 0;
  
      if (defined $base) {
          $base_unix = 1 if ($base =~ m#/#);
          $base_unix = 1 if ($base =~ /^\.\.?$/);
          $base_vms = 1 if ($base =~ m#(?<!\^)[\[<\]:]#);
          $base_vms = 1 if ($base =~ /^--?$/);
  
          if ($path_vms == $path_unix) {
              if ($base_vms == $base_unix) {
                  $unix_mode = $unix_rpt;
              } else {
                  $unix_mode = $base_unix;
              }
          } else {
              $unix_mode = 0 if $base_vms;
          }
      }
  
      if ($efs) {
          if ($unix_mode) {
              # We are UNIX mode.
              $base = unixpath($base) if $base_vms;
              $base = unixify($path) if $path_vms;
  
              # Here VMS is different, and in order to do this right
              # we have to take the realpath for both the path and the base
              # so that we can remove the common components.
  
              if ($path =~ m#^/#) {
                  if (defined $base) {
  
                      # For the shorterm, if the starting directories are
                      # common, remove them.
                      my $bq = qq($base);
                      $bq =~ s/\$/\\\$/;
                      $path =~ s/^$bq//i;
                  }
                  return $path;
              }
  
              return File::Spec::Unix::abs2rel( $self, $path, $base );
  
          } else {
              $base = vmspath($base) if $base_unix;
              $path = vmsify($path) if $path_unix;
          }
      }
  
      unless (defined $base and length $base) {
          $base = $self->_cwd();
          if ($efs) {
              $base_unix = 1 if ($base =~ m#/#);
              $base_unix = 1 if ($base =~ /^\.\.?$/);
              $base = vmspath($base) if $base_unix;
          }
      }
  
      for ($path, $base) { $_ = $self->canonpath($_) }
  
      # Are we even starting $path on the same (node::)device as $base?  Note that
      # logical paths or nodename differences may be on the "same device" 
      # but the comparison that ignores device differences so as to concatenate 
      # [---] up directory specs is not even a good idea in cases where there is 
      # a logical path difference between $path and $base nodename and/or device.
      # Hence we fall back to returning the absolute $path spec
      # if there is a case blind device (or node) difference of any sort
      # and we do not even try to call $parse() or consult %ENV for $trnlnm()
      # (this module needs to run on non VMS platforms after all).
      
      my ($path_volume, $path_directories, $path_file) = $self->splitpath($path);
      my ($base_volume, $base_directories, $base_file) = $self->splitpath($base);
      return $path unless lc($path_volume) eq lc($base_volume);
  
      for ($path, $base) { $_ = $self->rel2abs($_) }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my $pathchunks = @pathchunks;
      unshift(@pathchunks,'000000') unless $pathchunks[0] eq '000000';
      my @basechunks = $self->splitdir( $base_directories );
      my $basechunks = @basechunks;
      unshift(@basechunks,'000000') unless $basechunks[0] eq '000000';
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @basechunks now contains the directories to climb out of,
      # @pathchunks now has the directories to descend in to.
      if ((@basechunks > 0) || ($basechunks != $pathchunks)) {
        $path_directories = join '.', ('-' x @basechunks, @pathchunks) ;
      }
      else {
        $path_directories = join '.', @pathchunks;
      }
      $path_directories = '['.$path_directories.']';
      return $self->canonpath( $self->catpath( '', $path_directories, $path_file ) ) ;
  }
  
  
  =item rel2abs (override)
  
  Return an absolute file specification from a relative one.
  
  =cut
  
  sub rel2abs {
      my $self = shift ;
      my ($path,$base ) = @_;
      return undef unless defined $path;
  
      my $efs = $self->_efs;
      my $unix_rpt = $self->_unix_rpt;
  
      # We need to identify what the directory is in
      # of the specification in order to process them
      my $path_unix = 0;
      $path_unix = 1 if ($path =~ m#/#);
      $path_unix = 1 if ($path =~ /^\.\.?$/);
      my $path_vms = 0;
      $path_vms = 1 if ($path =~ m#(?<!\^)[\[<\]:]#);
      $path_vms = 1 if ($path =~ /^--?$/);
  
      my $unix_mode = 0;
      if ($path_vms == $path_unix) {
          $unix_mode = $unix_rpt;
      } else {
          $unix_mode = $path_unix;
      }
  
      my $base_unix = 0;
      my $base_vms = 0;
  
      if (defined $base) {
          $base_unix = 1 if ($base =~ m#/#);
          $base_unix = 1 if ($base =~ /^\.\.?$/);
          $base_vms = 1 if ($base =~ m#(?<!\^)[\[<\]:]#);
          $base_vms = 1 if ($base =~ /^--?$/);
  
          # If we could not determine the path mode, see if we can find out
          # from the base.
          if ($path_vms == $path_unix) {
              if ($base_vms != $base_unix) {
                  $unix_mode = $base_unix;
              }
          }
      }
  
      if (!$efs) {
          # Legacy behavior, convert to VMS syntax.
          $unix_mode = 0;
          if (defined $base) {
              $base = vmspath($base) if $base =~ m/\//;
          }
  
          if ($path =~ m/\//) {
  	    $path = ( -d $path || $path =~ m/\/\z/  # educated guessing about
  		       ? vmspath($path)             # whether it's a directory
  		       : vmsify($path) );
          }
     }
  
      # Clean up and split up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
              $base = $self->_cwd;
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          if ($efs) {
              # base may have changed, so need to look up format again.
              if ($unix_mode) {
                  $base_vms = 1 if ($base =~ m#(?<!\^)[\[<\]:]#);
                  $base_vms = 1 if ($base =~ /^--?$/);
                  $base = unixpath($base) if $base_vms;
                  $base .= '/' unless ($base =~ m#/$#);
              } else {
                  $base_unix = 1 if ($base =~ m#/#);
                  $base_unix = 1 if ($base =~ /^\.\.?$/);
                  $base = vmspath($base) if $base_unix; 
              }
          }
  
          # Split up paths
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base ) ;
  
          $path_directories = '' if $path_directories eq '[]' ||
                                    $path_directories eq '<>';
          my $sep = '' ;
  
          if ($efs) {
              # Merge the paths assuming that the base is absolute.
              $base_directories = $self->catdir('',
                                                $base_directories,
                                                $path_directories);
          } else {
              # Legacy behavior assumes VMS only paths
              $sep = '.'
                  if ( $base_directories =~ m{[^.\]>]\Z(?!\n)} &&
                       $path_directories =~ m{^[^.\[<]}s
                  ) ;
              $base_directories = "$base_directories$sep$path_directories";
              $base_directories =~ s{\.?[\]>][\[<]\.?}{.};
          }
  
          $path_file = '' if ($path_file eq '.') && $unix_mode;
  
          $path = $self->catpath( $base_volume, $base_directories, $path_file );
     }
  
      return $self->canonpath( $path ) ;
  }
  
  
  # eliminate_macros() and fixpath() are MakeMaker-specific methods
  # which are used inside catfile() and catdir().  MakeMaker has its own
  # copies as of 6.06_03 which are the canonical ones.  We leave these
  # here, in peace, so that File::Spec continues to work with MakeMakers
  # prior to 6.06_03.
  # 
  # Please consider these two methods deprecated.  Do not patch them,
  # patch the ones in ExtUtils::MM_VMS instead.
  #
  # Update:  MakeMaker 6.48 is still using these routines on VMS.
  # so they need to be kept up to date with ExtUtils::MM_VMS.
  #
  # The traditional VMS mode using ODS-2 disks depends on these routines
  # being here.  These routines should not be called in when the
  # C<DECC$EFS_CHARSET> or C<DECC$FILENAME_UNIX_REPORT> modes are enabled.
  
  sub eliminate_macros {
      my($self,$path) = @_;
      return '' unless (defined $path) && ($path ne '');
      $self = {} unless ref $self;
  
      if ($path =~ /\s/) {
        return join ' ', map { $self->eliminate_macros($_) } split /\s+/, $path;
      }
  
      my $npath = unixify($path);
      # sometimes unixify will return a string with an off-by-one trailing null
      $npath =~ s{\0$}{};
  
      my($complex) = 0;
      my($head,$macro,$tail);
  
      # perform m##g in scalar context so it acts as an iterator
      while ($npath =~ m#(.*?)\$\((\S+?)\)(.*)#gs) { 
          if (defined $self->{$2}) {
              ($head,$macro,$tail) = ($1,$2,$3);
              if (ref $self->{$macro}) {
                  if (ref $self->{$macro} eq 'ARRAY') {
                      $macro = join ' ', @{$self->{$macro}};
                  }
                  else {
                      print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),
                            "\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";
                      $macro = "\cB$macro\cB";
                      $complex = 1;
                  }
              }
              else { ($macro = unixify($self->{$macro})) =~ s#/\Z(?!\n)##; }
              $npath = "$head$macro$tail";
          }
      }
      if ($complex) { $npath =~ s#\cB(.*?)\cB#\${$1}#gs; }
      $npath;
  }
  
  # Deprecated.  See the note above for eliminate_macros().
  
  # Catchall routine to clean up problem MM[SK]/Make macros.  Expands macros
  # in any directory specification, in order to avoid juxtaposing two
  # VMS-syntax directories when MM[SK] is run.  Also expands expressions which
  # are all macro, so that we can tell how long the expansion is, and avoid
  # overrunning DCL's command buffer when MM[KS] is running.
  
  # fixpath() checks to see whether the result matches the name of a
  # directory in the current default directory and returns a directory or
  # file specification accordingly.  C<$is_dir> can be set to true to
  # force fixpath() to consider the path to be a directory or false to force
  # it to be a file.
  
  sub fixpath {
      my($self,$path,$force_path) = @_;
      return '' unless $path;
      $self = bless {}, $self unless ref $self;
      my($fixedpath,$prefix,$name);
  
      if ($path =~ /\s/) {
        return join ' ',
               map { $self->fixpath($_,$force_path) }
  	     split /\s+/, $path;
      }
  
      if ($path =~ m#^\$\([^\)]+\)\Z(?!\n)#s || $path =~ m#[/:>\]]#) { 
          if ($force_path or $path =~ /(?:DIR\)|\])\Z(?!\n)/) {
              $fixedpath = vmspath($self->eliminate_macros($path));
          }
          else {
              $fixedpath = vmsify($self->eliminate_macros($path));
          }
      }
      elsif ((($prefix,$name) = ($path =~ m#^\$\(([^\)]+)\)(.+)#s)) && $self->{$prefix}) {
          my($vmspre) = $self->eliminate_macros("\$($prefix)");
          # is it a dir or just a name?
          $vmspre = ($vmspre =~ m|/| or $prefix =~ /DIR\Z(?!\n)/) ? vmspath($vmspre) : '';
          $fixedpath = ($vmspre ? $vmspre : $self->{$prefix}) . $name;
          $fixedpath = vmspath($fixedpath) if $force_path;
      }
      else {
          $fixedpath = $path;
          $fixedpath = vmspath($fixedpath) if $force_path;
      }
      # No hints, so we try to guess
      if (!defined($force_path) and $fixedpath !~ /[:>(.\]]/) {
          $fixedpath = vmspath($fixedpath) if -d $fixedpath;
      }
  
      # Trim off root dirname if it's had other dirs inserted in front of it.
      $fixedpath =~ s/\.000000([\]>])/$1/;
      # Special case for VMS absolute directory specs: these will have had device
      # prepended during trip through Unix syntax in eliminate_macros(), since
      # Unix syntax has no way to express "absolute from the top of this device's
      # directory tree".
      if ($path =~ /^[\[>][^.\-]/) { $fixedpath =~ s/^[^\[<]+//; }
      $fixedpath;
  }
  
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  An explanation of VMS file specs can be found at
  L<http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files>.
  
  =cut
  
  1;
DARWIN-2LEVEL_FILE_SPEC_VMS

$fatpacked{"darwin-2level/File/Spec/Win32.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_WIN32';
  package File::Spec::Win32;
  
  use strict;
  
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.33';
  $VERSION = eval $VERSION;
  
  @ISA = qw(File::Spec::Unix);
  
  # Some regexes we use for path splitting
  my $DRIVE_RX = '[a-zA-Z]:';
  my $UNC_RX = '(?:\\\\\\\\|//)[^\\\\/]+[\\\\/][^\\\\/]+';
  my $VOL_RX = "(?:$DRIVE_RX|$UNC_RX)";
  
  
  =head1 NAME
  
  File::Spec::Win32 - methods for Win32 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Win32; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over 4
  
  =item devnull
  
  Returns a string representation of the null device.
  
  =cut
  
  sub devnull {
      return "nul";
  }
  
  sub rootdir { '\\' }
  
  
  =item tmpdir
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      SYS:/temp
      C:\system\temp
      C:/temp
      /tmp
      /
  
  The SYS:/temp is preferred in Novell NetWare and the C:\system\temp
  for Symbian (the File::Spec::Win32 is used also for those platforms).
  
  Since Perl 5.8.0, if running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( map( $ENV{$_}, qw(TMPDIR TEMP TMP) ),
  			      'SYS:/temp',
  			      'C:\system\temp',
  			      'C:/temp',
  			      '/tmp',
  			      '/'  );
  }
  
  =item case_tolerant
  
  MSWin32 case-tolerance depends on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Since XP FS_CASE_SENSITIVE is effectively disabled for the NT subsubsystem.
  See http://cygwin.com/ml/cygwin/2007-07/msg00891.html
  Default: 1
  
  =cut
  
  sub case_tolerant {
    eval { require Win32API::File; } or return 1;
    my $drive = shift || "C:";
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =item file_name_is_absolute
  
  As of right now, this returns 2 if the path is absolute with a
  volume, 1 if it's absolute with no volume, 0 otherwise.
  
  =cut
  
  sub file_name_is_absolute {
  
      my ($self,$file) = @_;
  
      if ($file =~ m{^($VOL_RX)}o) {
        my $vol = $1;
        return ($vol =~ m{^$UNC_RX}o ? 2
  	      : $file =~ m{^$DRIVE_RX[\\/]}o ? 2
  	      : 0);
      }
      return $file =~  m{^[\\/]} ? 1 : 0;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      shift;
  
      # Legacy / compatibility support
      #
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catfile('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub catdir {
      shift;
  
      # Legacy / compatibility support
      #
      return ""
      	unless @_;
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catdir('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub path {
      my @path = split(';', $ENV{PATH});
      s/"//g for @path;
      @path = grep length, @path;
      unshift(@path, ".");
      return @path;
  }
  
  =item canonpath
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  On Win32 makes 
  
  	dir1\dir2\dir3\..\..\dir4 -> \dir\dir4 and even
  	dir1\dir2\dir3\...\dir4   -> \dir\dir4
  
  =cut
  
  sub canonpath {
      # Legacy / compatibility support
      #
      return $_[1] if !defined($_[1]) or $_[1] eq '';
      return _canon_cat( $_[1] );
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path, $no_file );
  
  Splits a path into volume, directory, and filename portions. Assumes that 
  the last file is a path unless the path ends in '\\', '\\.', '\\..'
  or $no_file is true.  On Win32 this means that $no_file true makes this return 
  ( $volume, $path, '' ).
  
  Separators accepted are \ and /.
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  The results can be passed to L</catpath> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^ ( $VOL_RX ? ) (.*) }sox;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( $VOL_RX ? )
                  ( (?:.*[\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }sox;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L<catdir()|File::Spec/catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, leading empty and 
  trailing directory entries can be returned, because these are significant
  on some OSs. So,
  
      File::Spec->splitdir( "/a/b/c" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      #
      # split() likes to forget about trailing null fields, so here we
      # check to be sure that there will not be any before handling the
      # simple case.
      #
      if ( $directories !~ m|[\\/]\Z(?!\n)| ) {
          return split( m|[\\/]|, $directories );
      }
      else {
          #
          # since there was a trailing separator, add a file name to the end, 
          # then do the split, then replace it with ''.
          #
          my( @directories )= split( m|[\\/]|, "${directories}dummy" ) ;
          $directories[ $#directories ]= '' ;
          return @directories ;
      }
  }
  
  
  =item catpath
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and this is just like catfile(). On other OSs,
  the $volume become significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      my $v;
      $volume .= $v
          if ( (($v) = $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s) &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '\\' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  sub _same {
    lc($_[1]) eq lc($_[2]);
  }
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      my $is_abs = $self->file_name_is_absolute($path);
  
      # Check for volume (should probably document the '2' thing...)
      return $self->canonpath( $path ) if $is_abs == 2;
  
      if ($is_abs) {
        # It's missing a volume, add one
        my $vol = ($self->splitpath( $self->_cwd() ))[0];
        return $self->canonpath( $vol . $path );
      }
  
      if ( !defined( $base ) || $base eq '' ) {
        require Cwd ;
        $base = Cwd::getdcwd( ($self->splitpath( $path ))[0] ) if defined &Cwd::getdcwd ;
        $base = $self->_cwd() unless defined $base ;
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
        $base = $self->rel2abs( $base ) ;
      }
      else {
        $base = $self->canonpath( $base ) ;
      }
  
      my ( $path_directories, $path_file ) =
        ($self->splitpath( $path, 1 ))[1,2] ;
  
      my ( $base_volume, $base_directories ) =
        $self->splitpath( $base, 1 ) ;
  
      $path = $self->catpath( 
  			   $base_volume, 
  			   $self->catdir( $base_directories, $path_directories ), 
  			   $path_file
  			  ) ;
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head2 Note For File::Spec::Win32 Maintainers
  
  Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  
  sub _canon_cat				# @path -> path
  {
      my ($first, @rest) = @_;
  
      my $volume = $first =~ s{ \A ([A-Za-z]:) ([\\/]?) }{}x	# drive letter
      	       ? ucfirst( $1 ).( $2 ? "\\" : "" )
  	       : $first =~ s{ \A (?:\\\\|//) ([^\\/]+)
  				 (?: [\\/] ([^\\/]+) )?
  	       			 [\\/]? }{}xs			# UNC volume
  	       ? "\\\\$1".( defined $2 ? "\\$2" : "" )."\\"
  	       : $first =~ s{ \A [\\/] }{}x			# root dir
  	       ? "\\"
  	       : "";
      my $path   = join "\\", $first, @rest;
  
      $path =~ tr#\\/#\\\\#s;		# xx/yy --> xx\yy & xx\\yy --> xx\yy
  
      					# xx/././yy --> xx/yy
      $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		\.
  		(?:\\\.)*		# and more
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}gx;
  
      # XXX I do not know whether more dots are supported by the OS supporting
      #     this ... annotation (NetWare or symbian but not MSWin32).
      #     Then .... could easily become ../../.. etc:
      # Replace \.\.\. by (\.\.\.+)  and substitute with
      # { $1 . ".." . "\\.." x (length($2)-2) }gex
  	     				# ... --> ../..
      $path =~ s{ (\A|\\)			# at begin or after a slash
      		\.\.\.
  		(?=\\|\z) 		# at end or followed by slash
  	     }{$1..\\..}gx;
      					# xx\yy\..\zz --> xx\zz
      while ( $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		[^\\]+			# rip this 'yy' off
  		\\\.\.
  		(?<!\A\.\.\\\.\.)	# do *not* replace ^..\..
  		(?<!\\\.\.\\\.\.)	# do *not* replace \..\..
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}sx ) {}
  
      $path =~ s#\A\\##;			# \xx --> xx  NOTE: this is *not* root
      $path =~ s#\\\z##;			# xx\ --> xx
  
      if ( $volume =~ m#\\\z# )
      {					# <vol>\.. --> <vol>\
  	$path =~ s{ \A			# at begin
  		    \.\.
  		    (?:\\\.\.)*		# and more
  		    (?:\\|\z) 		# at end or followed by slash
  		 }{}x;
  
  	return $1			# \\HOST\SHARE\ --> \\HOST\SHARE
  	    if    $path eq ""
  	      and $volume =~ m#\A(\\\\.*)\\\z#s;
      }
      return $path ne "" || $volume ? $volume.$path : ".";
  }
  
  1;
DARWIN-2LEVEL_FILE_SPEC_WIN32

$fatpacked{"darwin-2level/version.pm"} = <<'DARWIN-2LEVEL_VERSION';
  #!perl -w
  package version;
  
  use 5.005_04;
  use strict;
  
  use vars qw(@ISA $VERSION $CLASS $STRICT $LAX *declare *qv);
  
  $VERSION = 0.88;
  
  $CLASS = 'version';
  
  #--------------------------------------------------------------------------#
  # Version regexp components
  #--------------------------------------------------------------------------#
  
  # Fraction part of a decimal version number.  This is a common part of
  # both strict and lax decimal versions
  
  my $FRACTION_PART = qr/\.[0-9]+/;
  
  # First part of either decimal or dotted-decimal strict version number.
  # Unsigned integer with no leading zeroes (except for zero itself) to
  # avoid confusion with octal.
  
  my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;
  
  # First part of either decimal or dotted-decimal lax version number.
  # Unsigned integer, but allowing leading zeros.  Always interpreted
  # as decimal.  However, some forms of the resulting syntax give odd
  # results if used as ordinary Perl expressions, due to how perl treats
  # octals.  E.g.
  #   version->new("010" ) == 10
  #   version->new( 010  ) == 8
  #   version->new( 010.2) == 82  # "8" . "2"
  
  my $LAX_INTEGER_PART = qr/[0-9]+/;
  
  # Second and subsequent part of a strict dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.
  # Limited to three digits to avoid overflow when converting to decimal
  # form and also avoid problematic style with excessive leading zeroes.
  
  my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;
  
  # Second and subsequent part of a lax dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.  No
  # limit on the numerical value or number of digits, so there is the
  # possibility of overflow when converting to decimal form.
  
  my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;
  
  # Alpha suffix part of lax version number syntax.  Acts like a
  # dotted-decimal part.
  
  my $LAX_ALPHA_PART = qr/_[0-9]+/;
  
  #--------------------------------------------------------------------------#
  # Strict version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Strict decimal version number.
  
  my $STRICT_DECIMAL_VERSION =
      qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;
  
  # Strict dotted-decimal version number.  Must have both leading "v" and
  # at least three parts, to avoid confusion with decimal syntax.
  
  my $STRICT_DOTTED_DECIMAL_VERSION =
      qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;
  
  # Complete strict version number syntax -- should generally be used
  # anchored: qr/ \A $STRICT \z /x
  
  $STRICT =
      qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  # Lax version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Lax decimal version number.  Just like the strict one except for
  # allowing an alpha suffix or allowing a leading or trailing
  # decimal-point
  
  my $LAX_DECIMAL_VERSION =
      qr/ $LAX_INTEGER_PART (?: \. | $FRACTION_PART $LAX_ALPHA_PART? )?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;
  
  # Lax dotted-decimal version number.  Distinguished by having either
  # leading "v" or at least three non-alpha parts.  Alpha part is only
  # permitted if there are at least two non-alpha parts. Strangely
  # enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
  # so when there is no "v", the leading part is optional
  
  my $LAX_DOTTED_DECIMAL_VERSION =
      qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;
  
  # Complete lax version number syntax -- should generally be used
  # anchored: qr/ \A $LAX \z /x
  #
  # The string 'undef' is a special case to make for easier handling
  # of return values from ExtUtils::MM->parse_version
  
  $LAX =
      qr/ undef | $LAX_DECIMAL_VERSION | $LAX_DOTTED_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  
  eval "use version::vxs $VERSION";
  if ( $@ ) { # don't have the XS version installed
      eval "use version::vpp $VERSION"; # don't tempt fate
      die "$@" if ( $@ );
      push @ISA, "version::vpp";
      local $^W;
      *version::qv = \&version::vpp::qv;
      *version::declare = \&version::vpp::declare;
      *version::_VERSION = \&version::vpp::_VERSION;
      if ($] >= 5.009000 && $] < 5.011004) {
  	no strict 'refs';
  	*version::stringify = \&version::vpp::stringify;
  	*{'version::(""'} = \&version::vpp::stringify;
  	*version::new = \&version::vpp::new;
  	*version::parse = \&version::vpp::parse;
      }
  }
  else { # use XS module
      push @ISA, "version::vxs";
      local $^W;
      *version::declare = \&version::vxs::declare;
      *version::qv = \&version::vxs::qv;
      *version::_VERSION = \&version::vxs::_VERSION;
      *version::vcmp = \&version::vxs::VCMP;
      if ($] >= 5.009000 && $] < 5.011004) {
  	no strict 'refs';
  	*version::stringify = \&version::vxs::stringify;
  	*{'version::(""'} = \&version::vxs::stringify;
  	*version::new = \&version::vxs::new;
  	*version::parse = \&version::vxs::parse;
      }
  
  }
  
  # Preloaded methods go here.
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq 'version') {
  	local $^W;
  	*{$class.'::declare'} =  \&version::declare;
  	*{$class.'::qv'} = \&version::qv;
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
      	%args = 
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
      
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} = 
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	local $^W;
  	*UNIVERSAL::VERSION 
  		= \&version::_VERSION;
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&version::_VERSION;
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&version::is_strict
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&version::is_lax
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
  sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }
  
  1;
DARWIN-2LEVEL_VERSION

$fatpacked{"darwin-2level/version/vxs.pm"} = <<'DARWIN-2LEVEL_VERSION_VXS';
  #!perl -w
  package version::vxs;
  
  use 5.005_03;
  use strict;
  
  use vars qw(@ISA $VERSION $CLASS );
  
  $VERSION = 0.88;
  
  $CLASS = 'version::vxs';
  
  eval {
      require XSLoader;
      local $^W; # shut up the 'redefined' warning for UNIVERSAL::VERSION
      XSLoader::load('version::vxs', $VERSION);
      1;
  } or do {
      require DynaLoader;
      push @ISA, 'DynaLoader'; 
      local $^W; # shut up the 'redefined' warning for UNIVERSAL::VERSION
      bootstrap version::vxs $VERSION;
  };
  
  # Preloaded methods go here.
  
  1;
DARWIN-2LEVEL_VERSION_VXS

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE
#!/Users/gugod/perl5/perlbrew/perls/perl-5.12.3/bin/perl

eval 'exec /Users/gugod/perl5/perlbrew/perls/perl-5.12.3/bin/perl  -S $0 ${1+"$@"}'
    if 0; # not running under some shell

package
  patchperl;
# ABSTRACT: patch a perl source tree

use strict;
use warnings;
use Devel::PatchPerl;

Devel::PatchPerl->patch_source(undef, $ARGV[0]);

__END__
=pod

=head1 NAME

patchperl - patch a perl source tree

=head1 VERSION

version 0.36

=head1 AUTHOR

Chris Williams <chris@bingosnet.co.uk>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2011 by Chris Williams and Marcus Holland-Moritz.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut

